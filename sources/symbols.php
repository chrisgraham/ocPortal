<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2014

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

/*EXTRA FUNCTIONS: memory_get_usage|memory_get_peak_usage*/

/**
 * Standard code module initialisation function.
 */
function init__symbols()
{
	global $BLOCKS_CACHE,$PAGES_CACHE,$PANELS_CACHE,$EXTRA_SYMBOLS,$PREPROCESSABLE_SYMBOLS,$THEME_IMG_DIMS_CACHE,$CANONICAL_URL,$STATIC_TEMPLATE_TEST_MODE;
	$BLOCKS_CACHE=array();
	$PAGES_CACHE=array();
	$PANELS_CACHE=array();
	$PREPROCESSABLE_SYMBOLS=array(
		'PAGE_LINK'=>1,
		'SET'=>1,
		'BLOCK'=>1,
		'FACILITATE_AJAX_BLOCK_CALL'=>1,
		'REQUIRE_JAVASCRIPT'=>1,
		'REQUIRE_CSS'=>1,
		'LOAD_PANEL'=>1,
		'JS_TEMPCODE'=>1,
		'CSS_TEMPCODE'=>1,
		'LOAD_PAGE'=>1,
		'FRACTIONAL_EDITABLE'=>1,
	);
	$EXTRA_SYMBOLS=NULL;
	$CANONICAL_URL=NULL;
	$THEME_IMG_DIMS_CACHE=mixed();
	$STATIC_TEMPLATE_TEST_MODE=false;
}

/**
 * Evaluate a conventional tempcode variable, handling escaping
 *
 * @param  string				The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  integer			The type of symbol this is (TC_SYMBOL, TC_LANGUAGE_REFERENCE)
 * @set    0 2
 * @param  ID_TEXT			The name of the symbol
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return mixed				The result. Either tempcode, or a string.
 */
function ecv($lang,$escaped,$type,$name,$param)
{
	// SYMBOLS...
	if ($type==TC_SYMBOL)
	{
		// Built-in
		if ($name=='?')
		{
			$value=call_user_func('ecv_TERNARY',$lang,$escaped,$param);
		}
		elseif (function_exists('ecv_'.$name))
		{
			$value=call_user_func('ecv_'.$name,$lang,$escaped,$param);
		} else
		{
			// Maybe a hook?
			global $EXTRA_SYMBOLS;
			if ($EXTRA_SYMBOLS===NULL)
			{
				if (running_script('install'))
				{
					$EXTRA_SYMBOLS=array('BETA_CSS_PROPERTY'=>array()); // Needed for installer to look good ('find_all_hooks' won't run in initial steps of quick installer)
				} else
				{
					$EXTRA_SYMBOLS=array();
					$hooks=find_all_hooks('systems','symbols');
					foreach (array_keys($hooks) as $hook)
					{
						$EXTRA_SYMBOLS[$hook]=array();
					}
				}
			}
			if (isset($EXTRA_SYMBOLS[$name]))
			{
				if (!isset($EXTRA_SYMBOLS[$name]['ob']))
				{
					require_code('hooks/systems/symbols/'.filter_naughty_harsh($name));
					$EXTRA_SYMBOLS[$name]['ob']=object_factory('Hook_symbol_'.filter_naughty_harsh($name));
				}
				$value=$EXTRA_SYMBOLS[$name]['ob']->run($param);

				if ($escaped!=array())
				{
					if (is_object($value)) $value=$value->evaluate();
					apply_tempcode_escaping($escaped,$value);
				}
			}

			else
			{
				// A less common symbol?
				require_code('symbols2');
				if (function_exists('ecv2_'.$name))
				{
					$value=call_user_func('ecv2_'.$name,$lang,$escaped,$param);
				}

				// A constant?
				elseif (defined($name))
				{
					$value=@strval(constant($name));
					if (!is_string($value)) $value=strval($value);

					if ($escaped!=array())
					{
						if (is_object($value)) $value=$value->evaluate();
						apply_tempcode_escaping($escaped,$value);
					}
				}

				// Error :-(
				else
				{
					$value='';
					if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
					if (!running_script('install'))
					{
						require_code('site');
						attach_message(do_lang_tempcode('MISSING_SYMBOL',escape_html($name)),'warn');
					}
				}
			}
		}

		return $value;
	}

	// DIRECTIVES...

	if ($type==TC_DIRECTIVE)
	{
		$value='';
		if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

		// In our param we should have a map of bubbled template parameters (under 'vars') and our numbered directive parameters

		if ($param===NULL) $param=array();

		// Closure-based Tempcode parser may send in strings, so we need to adapt...
		foreach ($param as $key=>$val)
		{
			if (is_string($val)) $param[$key]=make_string_tempcode($val);
		}

		if (!isset($param['vars'])) $param['vars']=array();

		switch ($name)
		{
			case 'IF':
				require_code('symbols2');
				ecv2_IF($value,$lang,$escaped,$param);
				break;

			case 'IF_EMPTY':
				require_code('symbols2');
				ecv2_IF_EMPTY($value,$lang,$escaped,$param);
				break;

			case 'IF_NON_EMPTY':
				require_code('symbols2');
				ecv2_IF_NON_EMPTY($value,$lang,$escaped,$param);
				break;

			case 'IF_PASSED':
				require_code('symbols2');
				ecv2_IF_PASSED($value,$lang,$escaped,$param);
				break;

			case 'IF_NON_PASSED':
				require_code('symbols2');
				ecv2_IF_NON_PASSED($value,$lang,$escaped,$param);
				break;

			case 'IF_PASSED_AND_TRUE':
				require_code('symbols2');
				ecv2_IF_PASSED_AND_TRUE($value,$lang,$escaped,$param);
				break;

			case 'IF_NON_PASSED_OR_FALSE':
				require_code('symbols2');
				ecv2_IF_NON_PASSED_OR_FALSE($value,$lang,$escaped,$param);
				break;

			case 'WHILE':
				require_code('symbols2');
				ecv2_WHILE($value,$lang,$escaped,$param);
				break;

			case 'LOOP':
				require_code('symbols2');
				ecv2_LOOP($value,$lang,$escaped,$param);
				break;

			case 'PARAM_INFO':
				$_value=do_template('PARAM_INFO',array('_GUID'=>'960e11880fbc512a3170756ca43384fd','MAP'=>$param['vars']));
				$value=$_value->evaluate();
				break;

			case 'CSS_INHERIT':
				require_code('symbols2');
				ecv2_CSS_INHERIT($value,$lang,$escaped,$param);
				break;

			case 'FRACTIONAL_EDITABLE':
				require_javascript('javascript_ajax');
				require_javascript('javascript_fractional_edit');

				foreach (array_keys($param) as $key)
				{
					if (!is_numeric($key)) unset($param[$key]);
				}
				if (isset($param[3]))
				{
					$edit_text=$param[0]->evaluate();
					$edit_param_name=$param[1]->evaluate();
					$edit_page_link=$param[2]->evaluate();
					$supports_comcode=(isset($param[4])?$param[3]->evaluate():'0')=='1';

					list($zone,$attributes,)=page_link_decode($edit_page_link);
					if ($zone=='_SEARCH') $zone=get_module_zone($attributes['page']);
					if ((has_actual_page_access(get_member(),$attributes['page'],$zone)) && (((array_key_exists(4,$param)) && ($param[3]->evaluate()=='1')) || (has_zone_access(get_member(),'adminzone'))))
					{
						$keep=symbol_tempcode('KEEP');
						$url=find_script('fractional_edit').'?edit_param_name='.urlencode($edit_param_name).'&supports_comcode='.($supports_comcode?'1':'0').'&zone='.urlencode($zone).$keep->evaluate();
						foreach ($attributes as $key=>$val)
						{
							$url.='&'.$key.'='.urlencode($val);
						}

						$_value=$param[count($param)-1];
						$_value=do_template('FRACTIONAL_EDIT',array('_GUID'=>'075ac126c427d28b309004bc67b32b08','VALUE'=>$_value,'URL'=>$url,'EDIT_TEXT'=>$edit_text,'EDIT_PARAM_NAME'=>$edit_param_name));
						$value=$_value->evaluate();
					} else
					{
						$value=$param[count($param)-1]->evaluate();
					}
				}
				break;

			case 'SET_NOPREEVAL':
				if (isset($param[1]))
				{
					global $TEMPCODE_SETGET;

					$var=$param[0]->evaluate();
					$TEMPCODE_SETGET[$var]=$param[1]->bind($param['vars'],'');
				}
				break;

			case 'SET':
				if (isset($param[1]))
				{
					global $TEMPCODE_SETGET;

					$var=$param[0]->evaluate();
					$set_val='';
					$i=1;
					while (isset($param[$i]))
					{
						if ($i!=1) $set_val.=',';
						$set_val.=$param[1]->evaluate();
						$i++;
					}
					$TEMPCODE_SETGET[$var]=$set_val;
				}
				break;

			case 'IMPLODE':
				if (isset($param[1]))
				{
					$key=$param[1]->evaluate();
					$array=array_key_exists($key,$param['vars'])?$param['vars'][$key]:array();
					if ((isset($param[2])) && ($param[2]->evaluate()=='1'))
					{
						$delim=$param[0]->evaluate();
						foreach ($array as $key=>$val)
						{
							if ($value!='') $value.=$delim;
							$value.=(is_integer($key)?integer_format($key):$key).'='.$val;
						}
					} else
					{
						$value=implode($param[0]->evaluate(),$array);
					}
				}
				break;

			case 'COUNT':
				if (isset($param[0]))
				{
					$key=$param[0]->evaluate();
					$array=array_key_exists($key,$param['vars'])?$param['vars'][$key]:array();
					$value=strval(count($array));
				}
				break;

			case 'BOX':
				unset($param['vars']);
				$title=isset($param[1])?$param[0]->evaluate():'';
				$box_type=isset($param[2])?$param[1]->evaluate():'';
				$width=isset($param[3])?$param[2]->evaluate():'';
				$options=isset($param[4])?$param[3]->evaluate():'';
				$meta=isset($param[5])?$param[4]->evaluate():'';
				$links=isset($param[6])?$param[5]->evaluate():'';
				$top_links=isset($param[7])?$param[6]->evaluate():'';
				$tmp=put_in_standard_box(array_pop($param),$title,$box_type,$width,$options,$meta,$links,$top_links);
				$value=$tmp->evaluate();
				break;

			case 'NO_PREPROCESSING':
				$value=$param[0]->evaluate();
				break;

			case 'OF':
				if (isset($param[1]))
				{
					$key=$param[0]->evaluate();
					$x=$param[1]->evaluate();

					$array=array_key_exists($key,$param['vars'])?$param['vars'][$key]:array();
					$x2=is_numeric($x)?intval($x):$x;
					if (is_integer($x2))
					{
						if ($x2<0) $x2=count($array)-1;
						elseif ($x2>=count($array)) $x2-=count($array);
					}
					$value=array_key_exists($x2,$array)?$array[$x2]:'';
					if (is_object($value)) $value=$value->evaluate();
				}
				break;

			case 'RECONTEXTUALISE_IDS':
				require_code('symbols2');
				ecv2_RECONTEXTUALISE_IDS($value,$lang,$escaped,$param);
				break;

			case 'INCLUDE':
				if (isset($param[1]))
				{
					$tpl_params=$param['vars'];
					$explode=explode("\n",$param[1]->evaluate());
					foreach ($explode as $val)
					{
						$bits=explode('=',$val,2);
						if (count($bits)==2) $tpl_params[ltrim($bits[0])]=str_replace('\n',"\n",$bits[1]);
					}
					$td=isset($param[3])?$param[2]->evaluate():'';
					if ($td=='') $td='templates';
					$ex=isset($param[2])?$param[1]->evaluate():'';
					if ($ex=='') $ex='.tpl';
					$_value=do_template($param[0]->evaluate(),$tpl_params,NULL,false,NULL,$ex,$td);
					$value=$_value->evaluate();
				}
				break;

			case 'IF_IN_ARRAY':
				if (isset($param[2]))
				{
					$key=$param[0]->evaluate();
					$array=array_key_exists($key,$param['vars'])?$param['vars'][$key]:array();
					$value='';
					if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
					$i=1;
					while (array_key_exists($i+1,$param))
					{
						$checking_in=$param[$i]->evaluate();
						if (in_array($checking_in,$array))
						{
							$value=$param[count($param)-2]->evaluate();
							break;
						}
						$i++;
					}
				}
				break;

			case 'IF_NOT_IN_ARRAY':
				if (isset($param[2]))
				{
					$key=$param[0]->evaluate();
					$array=array_key_exists($key,$param['vars'])?$param['vars'][$key]:array();
					$value='';
					if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
					$ok=true;
					$i=1;
					while (array_key_exists($i+1,$param))
					{
						$checking_in=$param[$i]->evaluate();
						if (in_array($checking_in,$array))
						{
							$ok=false;
							break;
						}
						$i++;
					}
					if ($ok) $value=$param[$i]->evaluate();
				}
				break;

			case 'IF_ARRAY_EMPTY':
				if (isset($param[0]))
				{
					$looking_at=$param[0]->evaluate();
					if (array_key_exists($looking_at,$param['vars']))
						if (count($param['vars'][$looking_at])==0) $value=$param[1]->evaluate();
				}
				break;

			case 'IF_ARRAY_NON_EMPTY':
				if (isset($param[0]))
				{
					$looking_at=$param[0]->evaluate();
					if (array_key_exists($looking_at,$param['vars']))
						if (count($param['vars'][$looking_at])!=0) $value=$param[1]->evaluate();
				}
				break;

			case 'COMMENT':
				break;

			case 'CASES':
				if (isset($param[1]))
				{
					$value='';
					$compare=$param[0]->evaluate();
					$substring=(isset($param[2]) && $param[1]->evaluate()=='1');
					$regexp=(isset($param[2]) && $param[1]->evaluate()=='2');
					$explode=explode(chr(10),trim($param[isset($param[2])?2:1]->evaluate()));
					foreach ($explode as $i=>$case)
					{
						if (strpos($case,'=')===false) continue;
						list($compare_case,$value_case)=explode('=',$case,2);
						$compare_case=trim($compare_case);
						if (
							((!$substring) && (!$regexp) && ($compare_case==$compare)) || // Exact match
							(($substring) && (($compare_case=='') || (strpos($compare,$compare_case)!==false))) || // Substring
							(($regexp) && (preg_match('#'.str_replace('#','\#',$compare_case).'#',$compare)!=0)) || // Regexp
							(($compare_case=='') && (!isset($explode[$i+1]))) // The final default case
						)
						{
							$value=$value_case;
							break;
						}
					}
				}
				break;

			default:
				require_code('site');
				attach_message(do_lang_tempcode('UNKNOWN_DIRECTIVE',escape_html($name)),'warn');
		}

		if ($escaped!=array())
		{
			apply_tempcode_escaping($escaped,$value);
		}

		return $value;
	}

	// LANGUAGE STRINGS...

	$a=isset($param[0])?(is_object($param[0])?$param[0]->evaluate():$param[0]):NULL;
	$b=isset($param[1])?(is_object($param[1])?$param[1]->evaluate():$param[1]):NULL;
	$c=isset($param[2])?array_splice($param,2):NULL;
	if ($c!==NULL)
	{
		foreach ($c as $i=>$cc)
		{
			if (is_object($cc)) $c[$i]=$cc->evaluate();
		}
	}
	static $dle=false;
	if (!$dle) $dle=function_exists('do_lang');
	$value=$dle?do_lang($name,$a,$b,$c,$lang,false):escape_html($name.':'.(($a!==NULL)?$a:'').','.(($b!==NULL)?$b:''));
	if ($value===NULL)
	{
		require_code('site');
		attach_message(do_lang_tempcode('MISSING_LANG_ENTRY',escape_html($name)),'warn');

		$value='';
		if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
		return $value;
	}
	if ($escaped!=array() && $escaped!=array(ENTITY_ESCAPED))
		apply_tempcode_escaping(array_diff($escaped,array(ENTITY_ESCAPED)),$value); // Escape but without ENTITY_ESCAPED because we don't do that on lang strings
	elseif ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_PAGE_LINK($lang,$escaped,$param)
{
	if (isset($param[0]))
	{
		list($zone,$map,$hash)=page_link_decode(is_object($param[0])?$param[0]->evaluate():$param[0]);

		$skip=NULL;
		if (isset($param[4]))
		{
			$skip=array_flip(explode('|',$param[4]));
		}

		$avoid_remap=isset($param[1]) && ($param[1]=='1');
		$skip_keep=isset($param[2]) && ($param[2]=='1');
		$keep_all=isset($param[3]) && ($param[3]=='1');

		$value=_build_url($map,$zone,$skip,$keep_all,$avoid_remap,$skip_keep,$hash);
	} else
	{
		$value=get_zone_name().':'.get_page_name();
		foreach ($_GET as $key=>$val)
		{
			if ($key=='page') continue;
			if (is_array($val)) continue;
			if ((substr($key,0,5)=='keep_')  && (!skippable_keep($key,$val))) continue;
			$value.=':'.$key.'='.$val;
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_SET_NOPREEVAL($lang,$escaped,$param)
{
	return ecv_SET($lang,$escaped,$param);
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_SET($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		global $TEMPCODE_SETGET;
		if (isset($param[1]) && is_object($param[1]))
		{
			$TEMPCODE_SETGET[$param[0]]=$param[1];
		} else
		{
			$param_copy=$param;
			unset($param_copy[0]);
			$TEMPCODE_SETGET[$param[0]]=implode(',',$param_copy);
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_GET($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		global $TEMPCODE_SETGET;
		if (isset($TEMPCODE_SETGET[$param[0]]))
		{
			if (is_object($TEMPCODE_SETGET[$param[0]]))
			{
				if ((array_key_exists(1,$param)) && ($param[1]=='1')) // no-cache
				{
					$TEMPCODE_SETGET[$param[0]]->decache();
					$value=$TEMPCODE_SETGET[$param[0]]->evaluate();
					$TEMPCODE_SETGET[$param[0]]->decache();

					if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
					return $value;
				}

				$TEMPCODE_SETGET[$param[0]]=$TEMPCODE_SETGET[$param[0]]->evaluate();
			}

			$value=$TEMPCODE_SETGET[$param[0]];
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HAS_ACTUAL_PAGE_ACCESS($lang,$escaped,$param)
{
	$value='';

	if (isset($param[0]))
	{
		$value=has_actual_page_access(((($param!==NULL)) && (isset($param[2])))?intval($param[2]):get_member(),$param[0],isset($param[1])?$param[1]:NULL)?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_TERNARY($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		$value=(($param[0]=='1') || ($param[0]=='1'))?$param[1]:(isset($param[2])?$param[2]:$value);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IMG($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		if ((isset($GLOBALS['SITE_DB'])) && (function_exists('find_theme_image')) && (!$GLOBALS['IN_MINIKERNEL_VERSION']) && ($GLOBALS['FORUM_DRIVER']!==NULL))
		{
			$value=find_theme_image($param[0],((isset($param[3])) && ($param[3]=='1')),false,(isset($param[2]) && $param[2]!='')?$param[2]:NULL,NULL,((isset($param[1])) && ($param[1]=='1'))?$GLOBALS['FORUM_DB']:$GLOBALS['SITE_DB']);
		} else
		{
			$value='themes/default/images/'.$param[0].'.png';
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IMG_WIDTH($lang,$escaped,$param)
{
	require_code('images');
	list($value,)=_symbol_image_dims($param);

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IMG_HEIGHT($lang,$escaped,$param)
{
	require_code('images');
	list(,$value)=_symbol_image_dims($param);

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_($lang,$escaped,$param) // A Tempcode comment
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_REFRESH($lang,$escaped,$param)
{
	// Is this refreshing?
	global $REFRESH_URL,$FORCE_META_REFRESH;
	if ((!running_script('upgrader')) && (get_option('force_meta_refresh')=='1')) $FORCE_META_REFRESH=true;
	if ((array_key_exists(0,$REFRESH_URL)) && ($REFRESH_URL[0]!='') && ($FORCE_META_REFRESH)) // The page itself has actually told it to refresh itself DISABLED FOR ACCESSIBILITY REASONS: Now headers do refreshing when it's crucial
	{
		if (!array_key_exists(1,$REFRESH_URL)) $REFRESH_URL[1]=1;
		$refresh=do_template('META_REFRESH_LINE',array('_GUID'=>'6ee20694dfa474f160481a3ab5331d87','URL'=>$REFRESH_URL[0],'TIME'=>integer_format($REFRESH_URL[1])));
	} else $refresh=new ocp_tempcode();
	$value=$refresh->evaluate();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_FEEDS($lang,$escaped,$param)
{
	// Feeds
	if ((get_option('is_on_rss',true)==='1') && (addon_installed('syndication')))
	{
		$feeds=new ocp_tempcode();
		if (addon_installed('news'))
			$feeds->attach(do_template('RSS_HEADER',array('_GUID'=>'53e135b04502d6df64f1570b61310f30','FEED_URL'=>find_script('backend').'?mode=news','TITLE'=>do_lang('NEWS'))));
		if ($GLOBALS['FEED_URL']!==NULL)
		{
			if (substr($GLOBALS['FEED_URL'],0,1)=='?') $GLOBALS['FEED_URL']=find_script('backend').$GLOBALS['FEED_URL'];
			$feeds->attach(do_template('RSS_HEADER',array('_GUID'=>'3a289a821e87e954494753edf7cb2ebd','FEED_URL'=>$GLOBALS['FEED_URL'])));
		}
		if ($GLOBALS['FEED_URL_2']!==NULL)
		{
			if (substr($GLOBALS['FEED_URL_2'],0,1)=='?') $GLOBALS['FEED_URL_2']=find_script('backend').$GLOBALS['FEED_URL_2'];
			$feeds->attach(do_template('RSS_HEADER',array('_GUID'=>'fa8c7aaa3601c24d1986fa2598416558','FEED_URL'=>$GLOBALS['FEED_URL_2'],'TITLE'=>do_lang('COMMENTS'))));
		}
		$value=$feeds->evaluate();
	} else
	{
		$value='';
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_META_DATA($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		global $META_DATA;

		switch ($param[0])
		{
			case 'site_newestmember':
				$value=get_value('ocf_newest_member_username');
				if (is_null($value)) $value='';
				break;
			case 'site_nummembers':
				if (!is_null($GLOBALS['FORUM_DRIVER'])) $value=strval($GLOBALS['FORUM_DRIVER']->get_members());
				break;
			case 'site_bestmember':
				$value=get_value('site_bestmember');
				if (is_null($value)) $value='';
				break;
			case 'forum_numtopics':
				if (!is_null($GLOBALS['FORUM_DRIVER'])) $value=strval($GLOBALS['FORUM_DRIVER']->get_topics());
				break;
			case 'forum_numposts':
				if (!is_null($GLOBALS['FORUM_DRIVER'])) $value=strval($GLOBALS['FORUM_DRIVER']->get_num_forum_posts());
				break;

			case 'meta_description':
				if (isset($param[2]))
				{
					list(,$value)=seo_meta_get_for($param[1],$param[2]);
				} else
				{
					global $SEO_DESCRIPTION;
					if (($SEO_DESCRIPTION===NULL) || ($SEO_DESCRIPTION==''))
					{
						if (!empty($GLOBALS['META_DATA']['description']))
						{
							$value=strip_comcode($GLOBALS['META_DATA']['description']);
						} else
						{
							$value=get_option('description');
						}
					} else
					{
						$value=$SEO_DESCRIPTION;
					}
				}
				break;

			case 'raw_keywords':
				global $SEO_KEYWORDS;
				if ($SEO_KEYWORDS===NULL) $SEO_KEYWORDS=array();
				$keywords_array=$SEO_KEYWORDS;
				$value=implode(',',array_unique($keywords_array));
				break;

			case 'keywords':
				if (isset($param[2]))
				{
					list($value,)=seo_meta_get_for($param[1],$param[2]);
				} else
				{
					global $SEO_KEYWORDS;
					$keywords=get_option('keywords');
					if ($SEO_KEYWORDS===NULL) $SEO_KEYWORDS=array();
					$keywords_array=$SEO_KEYWORDS;
					if ($keywords!='') $keywords_array=array_merge($keywords_array,explode(',',$keywords));
					$value=implode(',',array_unique($keywords_array));
				}
				break;

			default:
				if (isset($param[1]))
				{
					$META_DATA[$param[0]]=$param[1];
				} else
				{
					if (isset($META_DATA[$param[0]]))
					{
						$value=$META_DATA[$param[0]];
						if (preg_match('#^[\:\s\w\-\_]*$#',$value)==0)
						{
							$value=strip_comcode($value);
						}
					}
				}
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_KEEP($lang,$escaped,$param)
{
	// What needs preserving in the URL
	$value=keep_symbol($param);

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * String to tack onto URL to keep 'keep_' parameters.
 *
 * @param  array			Parameters passed to the symbol (0=whether this starts off the query string, 1=force session append even if it's also available a session cookie e.g. when put into download manager)
 * @return string			The result.
 */
function keep_symbol($param)
{
	$value='';
	$get_vars=$_GET;
	if ((isset($param[1])) && ($param[1]=='1') && (!isset($get_vars['keep_session']))) $get_vars['keep_session']=strval(get_session_id());

	if (count($get_vars)>0)
	{
		$first=false;
		if ((isset($param[0])) && ($param[0]=='1')) $first=true;
		foreach ($get_vars as $key=>$val)
		{
			if (!is_string($key)) $key=strval($key);

			if ((get_magic_quotes_gpc()) && (is_string($val))) $val=stripslashes($val);

			if ((substr($key,0,5)=='keep_') && ((!skippable_keep($key,$val)) || (($key=='keep_session') && (is_null(get_bot_type())) && (isset($param[1])) && ($param[1]=='1'))) && (is_string($val)))
			{
				$value.=($first?'?':'&').urlencode($key).'='.ocp_url_encode($val);
				$first=false;
			}
		}
	}

	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_BROWSER($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		$q=false;
		foreach (explode('|',$param[0]) as $browser)
		{
			$q=browser_matches($browser);
			if ($q) break;
		}
		$value=$q?$param[1]:(isset($param[2])?$param[2]:'');
		if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_REQUIRE_JAVASCRIPT($lang,$escaped,$param)
{
	if (isset($param[0]))
	{
		global $JAVASCRIPTS;
		if (!isset($JAVASCRIPTS[$param[0]]))
		{
			if ((isset($param[1])) && ($param[1]=='1'))
			{
				global $JAVASCRIPT_BOTTOM;
				$JAVASCRIPT_BOTTOM[$param[0]]=1;
			}

			require_javascript($param[0]);
			/*// Has to do this inline, as you're not allowed to reference scripts outside head
			if (!array_key_exists($param[0],$GLOBALS['JAVASCRIPTS']))
			{
				$GLOBALS['JAVASCRIPTS'][$param[0]]=1;
				$file=javascript_enforce($param[0]);
				$_value=do_template('JAVASCRIPT_NEED_INLINE',array('_GUID'=>'d6c907e26c5a8dd8c65f1d36a1a674a9','CODE'=>file_get_contents($file)));
				$value=$_value->evaluate();
			}*/
		}
	}

	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_FACILITATE_AJAX_BLOCK_CALL($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		require_javascript('javascript_ajax');

		require_code('blocks');
		$_block_constraints=block_params_to_block_signature(block_params_str_to_arr($param[0]));
		if (isset($param[1]))
		{
			$_block_constraints=array_merge($_block_constraints,block_params_str_to_arr($param[1]));
			ksort($_block_constraints);
		}
		$block_constraints=block_params_arr_to_str($_block_constraints);

		// Store permissions
		$_auth_key=$GLOBALS['SITE_DB']->query_select('temp_block_permissions',array('id','p_time'),array(
			'p_session_id'=>get_session_id(),
			'p_block_constraints'=>$block_constraints,
		),'',1);
		if (!isset($_auth_key[0]))
		{
			$auth_key=$GLOBALS['SITE_DB']->query_insert('temp_block_permissions',array(
				'p_session_id'=>get_session_id(),
				'p_block_constraints'=>$block_constraints,
				'p_time'=>time(),
			),true);
		} else
		{
			$auth_key=$_auth_key[0]['id'];
			if (time()-$_auth_key[0]['p_time']>100)
			{
				$GLOBALS['SITE_DB']->query_update('temp_block_permissions',array('p_time'=>time()),array(
					'p_session_id'=>get_session_id(),
					'p_block_constraints'=>$block_constraints,
				),'',1);
			}
		}

		$keep=symbol_tempcode('KEEP');
		$value=find_script('snippet').'?snippet=block&auth_key='.urlencode(strval($auth_key)).'&block_map='.urlencode($param[0]).$keep->evaluate();
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv__GET($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=get_param($param[0],isset($param[1])?$param[1]:'',true);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_STRIP_TAGS($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		if ((isset($param[1])) && ($param[1]=='1'))
		{
			$value=strip_tags(str_replace('))',')',str_replace('((','(',str_replace('<em>','(',str_replace('</em>',')',$param[0])))));
		} else
		{
			if (strpos($param[0],'<')===false)
			{ // optimisation
				$value=$param[0];
			} else
			{
				$value=strip_tags($param[0],isset($param[2])?$param[2]:'');
			}
		}
		if ((isset($param[1])) && ($param[1]=='1')) $value=@html_entity_decode($value,ENT_QUOTES,get_charset());
		if ((!isset($param[2])) || ($param[2]=='0')) $value=trim($value);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_TRUNCATE_LEFT($lang,$escaped,$param)
{
	$value=symbol_truncator($param,'left');

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_TRUNCATE_SPREAD($lang,$escaped,$param)
{
	$value=symbol_truncator($param,'spread');

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Handle truncation symbols in all their complexity
 *
 * @param  array			Parameters passed to the symbol (0=text, 1=amount, 2=tooltip?, 3=is_html?, 4=use as grammatical length rather than HTML byte length, 5=fractional-deviation-tolerance for grammar-preservation)
 * @param  string			The type of truncation to do
 * @set    left right spread
 * @param  ?mixed			Tooltip to add on, but only if we end up creating our own tooltip (NULL: none)
 * @return string			The result.
 */
function symbol_truncator($param,$type,$tooltip_if_truncated=NULL)
{
	$value='';

	if (is_object($param[0]))
	{
		$param[0]=$param[0]->evaluate();
		if (!isset($param[2])) $param[2]='0';
		$param[3]='1';
	}

	$amount=intval(isset($param[1])?$param[1]:'60');
	$is_html=((isset($param[3])) && ($param[3]=='1'));
	if ($is_html)
	{
		$not_html=strip_html($param[0]); // In case it contains HTML. This is imperfect, but having to cut something up is imperfect from the offset.
		$html=$param[0];
		if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($html);
		if (($html==$not_html) && (strpos($html,'&')===false) && (strpos($html,'<')===false)) $is_html=false; // Conserve memory
	} else
	{
		$not_html=$param[0];
		$html=escape_html($param[0]);
	}

	if ((isset($not_html[$amount])/*optimisation*/) && (ocp_mb_strlen($not_html)>$amount))
	{
		$tooltip=((isset($param[2])) && ($param[2]=='1'));
		$literal_pos=isset($param[4])?($param[4]=='1'):false;
		$grammar_completeness_tolerance=isset($param[5])?floatval($param[5]):0.0;

		if ($is_html || $grammar_completeness_tolerance!=0.0)
		{
			require_code('xhtml');
		}

		$truncated=$not_html;
		switch ($type)
		{
			case 'left':
				$temp=(($is_html || $grammar_completeness_tolerance!=0.0)?xhtml_substr($html,0,$amount-3,$literal_pos,false,$grammar_completeness_tolerance):escape_html(ocp_mb_substr($not_html,0,$amount-3)));
				if ($temp!=$html && in_array(substr($temp,-1),array('.','?','!'))) $temp.='<br class="ellipsis_break" />'; // so the "..." does not go right after the sentence terminator
				$truncated=($temp==$html)?$temp:str_replace(array('</p>&hellip;','</div>&hellip;'),array('&hellip;</p>','&hellip;</div>'),(ocp_trim($temp,true).'&hellip;'));
				break;
			case 'expand':
				$temp=(($is_html || $grammar_completeness_tolerance!=0.0)?xhtml_substr($html,0,$amount-3,$literal_pos,false,$grammar_completeness_tolerance):escape_html(ocp_mb_substr($not_html,0,$amount-3)));
				if ($temp!=$html && in_array(substr($temp,-1),array('.','?','!'))) $temp.='<br class="ellipsis_break" />'; // so the "..." does not go right after the sentence terminator
				$_truncated=do_template('COMCODE_HIDE',array('_GUID'=>'3ead7fdb5b510930f54310e3c32147c2','TEXT'=>protect_from_escaping($temp),'CONTENT'=>protect_from_escaping($html)));
				$truncated=$_truncated->evaluate();
				break;
			case 'right':
				$truncated=str_replace(array('</p>&hellip;','</div>&hellip;'),array('&hellip;</p>','&hellip;</div>'),('&hellip;'.ltrim(($is_html || $grammar_completeness_tolerance!=0.0)?xhtml_substr($html,-$amount-3,NULL,$literal_pos,false,$grammar_completeness_tolerance):escape_html(ocp_mb_substr($not_html,-$amount-3)))));
				break;
			case 'spread':
				$pos=intval(floor(floatval($amount)/2.0))-1;
				$truncated=str_replace(array('</p>&hellip;','</div>&hellip;'),array('&hellip;</p>','&hellip;</div>'),ocp_trim((($is_html || $grammar_completeness_tolerance!=0.0)?xhtml_substr($html,0,$pos,$literal_pos,false,$grammar_completeness_tolerance):escape_html(ocp_mb_substr($not_html,0,$pos))).'&hellip;'.ltrim(($is_html || $grammar_completeness_tolerance!=0.0)?xhtml_substr($html,-$pos-1):escape_html(ocp_mb_substr($not_html,-$pos-1))),true));
				break;
		}

		if ($tooltip)
		{
			if (!is_null($tooltip_if_truncated))
			{
				$tif=(is_object($tooltip_if_truncated)?$tooltip_if_truncated->evaluate():$tooltip_if_truncated);
				if (strpos($tif,$html)!==false)
				{
					$html=$tif;
				} else
				{
					$html.=' &ndash; '.$tif;
				}
			}
			$tpl=((strpos($truncated,'<div')!==false || strpos($truncated,'<p')!==false || strpos($truncated,'<table')!==false)?'CROP_TEXT_MOUSE_OVER':'CROP_TEXT_MOUSE_OVER_INLINE');
			$value_tempcode=do_template($tpl,array('_GUID'=>'36ae945ed864633cfa0d67e5c3f2d1c8','TEXT_SMALL'=>$truncated,'TEXT_LARGE'=>$html));
			$value=$value_tempcode->evaluate();
			if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
		} else $value=$truncated;
	} else
	{
		$value=$html;
	}

	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_PARAGRAPH($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$is_blocky_already=($param[0]=='') || (preg_match('#<(p|div|ul|ol|dl|blockquote|h1|h2|h3|h4|h5|h6|table|iframe)(\s.*)?'.'>#',$param[0])!=0);
		$value.=($is_blocky_already?'':'<p>').$param[0].($is_blocky_already?'':'</p>');
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_COMMA_LIST_GET($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		require_code('blocks');
		$values=block_params_str_to_arr($param[0]);
		$value=isset($values[$param[1]])?$values[$param[1]]:'';
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IS_EMPTY($lang,$escaped,$param)
{
	$value='1';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=($param[0]=='')?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IS_NON_EMPTY($lang,$escaped,$param)
{
	$value='0';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=($param[0]!='')?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_CDN_FILTER($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=cdn_filter($param[0]);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_LOAD_PANEL($lang,$escaped,$param)
{
	$temp_array=array();
	handle_symbol_preprocessing(array($escaped,TC_SYMBOL,'LOAD_PANEL',$param),$temp_array); // Late preprocessing. Should not be needed in case of full screen output (as this was properly preprocessed), but is in other cases

	foreach ($param as $i=>$p)
		if (is_object($p)) $param[$i]=$p->evaluate();

	global $PANELS_CACHE;
	if (strpos($param[0],':')!==false)
		$param=array_reverse(explode(':',$param[0],2));
	if (substr($param[0],0,6)=='panel_') $param[0]=substr($param[0],6);
	$sr=serialize($param);
	$value=array_key_exists($sr,$PANELS_CACHE)?$PANELS_CACHE[$sr]:'';

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_JS_ON($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=has_js()?$param[0]:(isset($param[1])?$param[1]:'');
	} else $value=has_js()?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_ZONE($lang,$escaped,$param)
{
	$value=get_zone_name();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_PAGE($lang,$escaped,$param)
{
	$value=get_page_name();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HEADER_TEXT($lang,$escaped,$param)
{
	global $ZONE,$SHORT_TITLE,$DISPLAYED_TITLE;
	if ($ZONE===NULL) load_zone_data();
	if ($SHORT_TITLE===NULL) // Take from either zone header or screen title
	{
		if ($DISPLAYED_TITLE!==NULL) $_displayed_title=$DISPLAYED_TITLE->evaluate();
		if (($DISPLAYED_TITLE!==NULL) && (strip_tags($_displayed_title)!=''))
		{
			$value=strip_html($_displayed_title);
		} else
		{
			if ($ZONE!==NULL)
				$value=$ZONE['zone_header_text_trans'];
		}
	} else // Take from short title
	{
		$comcodeless=strip_comcode($SHORT_TITLE); // This is not HTML

		// Strip 'Welcome to' off if it's there
		$value=preg_replace('#'.preg_quote(do_lang('WELCOME_TO_STRIPPABLE').' '.get_site_name(),'#').'([^-]+\s*-\s*)?#','',$comcodeless);

		// Strip site name off it it's there (it'll be put on in the templates, so we don't want it twice)
		$stub=get_site_name().' - ';
		if (substr($value,strlen($stub))==$stub) $value=substr($value,strlen($stub));
		if ($value==get_site_name()) $value='';
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_CANONICAL_URL($lang,$escaped,$param)
{
	global $NON_CANONICAL_PARAMS,$CANONICAL_URL;
	if ($CANONICAL_URL===NULL)
	{
		$non_canonical=array();
		if (is_array($NON_CANONICAL_PARAMS)) foreach ($NON_CANONICAL_PARAMS as $n) $non_canonical[$n]=NULL;
		$CANONICAL_URL=get_self_url(true,false,$non_canonical);
	}
	$value=$CANONICAL_URL;

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_SHOW_HEADER($lang,$escaped,$param)
{
	$value=(is_wide_high()==1)?'0':'1';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_SHOW_FOOTER($lang,$escaped,$param)
{
	$value=(is_wide_high()==1)?'0':'1';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_WIDE($lang,$escaped,$param)
{
	$value=(is_wide()==1)?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_WIDE_HIGH($lang,$escaped,$param)
{
	$value=(is_wide_high()==1)?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_LOGO_URL($lang,$escaped,$param)
{
	$value=get_logo_url();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HELPER_PANEL_TUTORIAL($lang,$escaped,$param)
{
	if ($GLOBALS['HELPER_PANEL_TUTORIAL']===NULL) set_helper_panel_tutorial('');
	if (get_option('show_docs')=='0') set_helper_panel_tutorial('');
	$value=$GLOBALS['HELPER_PANEL_TUTORIAL'];

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HELPER_PANEL_TEXT($lang,$escaped,$param)
{
	if ($GLOBALS['HELPER_PANEL_TEXT']===NULL) $GLOBALS['HELPER_PANEL_TEXT']='';
	$value=is_object($GLOBALS['HELPER_PANEL_TEXT'])?$GLOBALS['HELPER_PANEL_TEXT']->evaluate():$GLOBALS['HELPER_PANEL_TEXT'];

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MESSAGES_TOP($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if ($GLOBALS['ATTACHED_MESSAGES']!==NULL)
	{
		$value=static_evaluate_tempcode($GLOBALS['ATTACHED_MESSAGES']);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MESSAGES_BOTTOM($lang,$escaped,$param)
{
	// Extra stuff we can tag on (like messages)
	$messages_bottom=new ocp_tempcode();
	if (get_option('site_closed')=='1')
	{
		require_code('global4');
		attach_message_site_closed($messages_bottom);
	}
	if ($GLOBALS['IS_ACTUALLY_ADMIN'])
	{
		require_code('global4');
		attach_message_su($messages_bottom);
	}
	if (get_param('special_page_type','')=='memory')
	{
		attach_message_memory_usage($messages_bottom);
	}
	$value=$messages_bottom->evaluate();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_LATE_MESSAGES($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if ($GLOBALS['LATE_ATTACHED_MESSAGES']!==NULL)
	{
		$value=static_evaluate_tempcode($GLOBALS['LATE_ATTACHED_MESSAGES']);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_BREADCRUMBS($lang,$escaped,$param)
{
	$show_self=(!isset($param[0]) || $param[0]=='1');
	if (!$show_self) $GLOBALS['BREADCRUMBS']=NULL;
	$value=static_evaluate_tempcode(breadcrumbs($show_self));

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HAS_SU($lang,$escaped,$param)
{
	$value='0';
	if (!is_guest())
	{
		$value=(get_option('show_su')=='1') && (has_privilege(get_member(),'assume_any_member'))?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_STAFF_ACTIONS($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (!is_guest())
	{
		// Different types of page type for staff (debug view, etc)
		if ((get_option('show_staff_page_actions')=='1') && (has_privilege(get_member(),'view_profiling_modes')) && (count($_POST)==0)) // We count POST because we don't want to allow double submits
		{
			require_code('site2');
			$value=get_staff_actions_list();
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_TRIM($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=$param[0];
		if ($value!='')
		{
			if (strpos($value,'<')===false && strpos($value,'&')===false)
			{
				$value=trim($value);
			} else
			{
				$value=ocp_trim($param[0],isset($param[1]) && $param[1]=='1');
			}
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Trim some text, supporting removing HTML white-space also.
 *
 * @param  string			Input text.
 * @param  boolean		Whether to keep doing it, while it changes (if complex mixtures are on the end).
 * @return string			The result text.
 */
function ocp_trim($text,$try_hard=false)
{
	if (memory_get_usage()>1024*1024*40) return trim($text); // Don't have enough memory
	do
	{
		$before=$text;
		$text=preg_replace(array('#^\s+#','#^(<br\s*/?'.'>\s*)+#','#^(&nbsp;)+#','#\s+$#','#(<br\s*/?'.'>\s*)+$#','#(&nbsp;)+$#'),array('','','','','',''),$text);
	}
	while (($try_hard) && ($before!=$text));
	return $text;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_CPF_VALUE($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		if (is_numeric($param[0]))
		{
			require_code('ocf_members');
			$fields=ocf_get_custom_fields_member(isset($param[1])?intval($param[1]):get_member());
			if (array_key_exists(intval($param[0]),$fields)) $_value=$fields[intval($param[0])];
		} elseif ((substr($param[0],0,2)=='m_') && (strpos(strtolower($param[0]),'hash')===false) && (strpos(strtolower($param[0]),'salt')===false))
		{
			$_value=$GLOBALS['FORUM_DRIVER']->get_member_row_field(isset($param[1])?intval($param[1]):get_member(),$param[0]);
		} else
		{
			if (preg_match('#^[a-z\_\d]*$#',$param[0])!=0)
			{
				$_value=get_ocp_cpf($param[0],isset($param[1])?intval($param[1]):NULL);
			} else
			{
				require_code('ocf_members');
				$cpf_id=find_cpf_field_id($param[0]);
				if (!is_null($cpf_id))
				{
					$fields=ocf_get_custom_fields_member(isset($param[1])?intval($param[1]):get_member());
					if (array_key_exists($cpf_id,$fields)) $_value=$fields[$cpf_id];
				} else $_value='';
			}
		}

		if (!is_string($_value))
		{
			$value=is_null($_value)?'':strval($_value);
		} else
		{
			$value=$_value;
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_BANNER($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (addon_installed('banners'))
	{
		global $SITE_INFO;
		$is_on_banners=((isset($param[1])) && ($param[1]=='1')) || (((!has_privilege(get_member(),'banner_free')) || (($GLOBALS['FORUM_DRIVER']->is_super_admin(get_member())) && (get_option('admin_banners')=='1')) || (!is_null($GLOBALS['CURRENT_SHARE_USER']))));
		if (array_key_exists('throttle_bandwidth_registered',$SITE_INFO))
		{
			$views_till_now=intval(get_value('page_views'));
			$bandwidth_allowed=$SITE_INFO['throttle_bandwidth_registered'];
			$total_bandwidth=intval(get_value('download_bandwidth'));
			if ($bandwidth_allowed*1024*1024>=$total_bandwidth) $is_on_banners=false;
		}
		if (($is_on_banners) && (!is_page_https(get_zone_name(),get_page_name()))) // We can't show when HTTPS, due to HTTPS security warnings (can't show HTTP requests on HTTPS page, and banner has them by nature).
		{
			require_code('banners');

			$b_type=isset($param[0])?$param[0]:'';
			if (!$GLOBALS['STATIC_TEMPLATE_TEST_MODE']) // Normal operation
			{
				$_value=banners_script(true,'','',$b_type,'');
				$value=$_value->evaluate();
			} else // Been told to behave statically
			{
				$value='Banner goes here';
			}
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_AVATAR($lang,$escaped,$param)
{
	$value=$GLOBALS['FORUM_DRIVER']->get_member_avatar_url(isset($param[0])?intval($param[0]):get_member());
	if ((url_is_local($value)) && ($value!='')) $value=get_base_url().'/'.$value;

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IS_GUEST($lang,$escaped,$param)
{
	if (isset($param[0]))
	{
		$value=(is_guest(intval($param[0])))?'1':'0';
	} else
	{
		$value=is_guest()?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MEMBER($lang,$escaped,$param)
{
	if (!isset($param[0]))
	{
		$value=strval(get_member());
	} else
	{
		$member_id=$GLOBALS['FORUM_DRIVER']->get_member_from_username($param[0]);
		$value=is_null($member_id)?'':strval($member_id);
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_REQUIRE_CSS($lang,$escaped,$param)
{
	if (isset($param[0]))
	{
		require_css($param[0]);
	}

	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IS_HTTPAUTH_LOGIN($lang,$escaped,$param)
{
	$value=is_httpauth_login()?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MEMBER_PROFILE_URL($lang,$escaped,$param)
{
	$member_id=((!is_null($param)) && (isset($param[0])))?intval($param[0]):get_member();
	$value=$GLOBALS['FORUM_DRIVER']->member_profile_url($member_id,false,true);
	if (is_object($value)) $value=$value->evaluate();
	if (is_null($value)) $value='';

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_USERNAME($lang,$escaped,$param)
{
	$member_id=((($param!==NULL)) && (isset($param[0])))?intval($param[0]):get_member();
	$value=$GLOBALS['FORUM_DRIVER']->get_username($member_id,(isset($param[1])) && ($param[1]=='1'));
	if ($value===NULL) $value=do_lang('UNKNOWN');

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_DISPLAYED_USERNAME($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=get_displayname($param[0]);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_CYCLE($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		global $CYCLES;
		if (!isset($CYCLES[$param[0]])) $CYCLES[$param[0]]=0;
		if (!isset($param[1])) // If we can't find a param simply return the index. Poor-mans cycle reader.
		{
			$value=strval($CYCLES[$param[0]]);
		} else // Cycle
		{
			if (count($param)==2)
			{
				$param=array_merge(array($param[0]),explode(',',$param[1]));
			}

			++$CYCLES[$param[0]];
			if (!array_key_exists($CYCLES[$param[0]],$param)) $CYCLES[$param[0]]=1;
			$value=$param[$CYCLES[$param[0]]];
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_THUMBNAIL($lang,$escaped,$param)
{
	require_code('images');
	$value=_symbol_thumbnail($param);

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IS_IN_GROUP($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		if (in_array($param[count($param)-1],array('','primary','secondary')))
		{
			$last_param=$param[count($param)-1];
			unset($param[count($param)-1]);
		} else $last_param='';

		$member_id=get_member();
		$new_param='';
		$param_2=array();
		foreach ($param as $group)
		{
			if ((substr($group,0,1)=='@') && (is_numeric(substr($group,1))))
			{
				$member_id=intval(substr($group,1));
			} else
			{
				$param_2=array_merge($param_2,explode(',',$group));
			}
		}
		foreach ($param_2 as $group)
		{
			if ($new_param!='') $new_param.=',';
			$new_param.=$group;
		}

		if ($last_param=='primary')
		{
			$member_row=$GLOBALS['FORUM_DRIVER']->get_member_row($member_id);
			$real_group_list=array($GLOBALS['FORUM_DRIVER']->mrow_group($member_row));
		}
		elseif ($last_param=='secondary')
		{
			$real_group_list=$GLOBALS['FORUM_DRIVER']->get_members_groups($member_id);
			$member_row=$GLOBALS['FORUM_DRIVER']->get_member_row($member_id);
			$real_group_list=array_diff($real_group_list,array($GLOBALS['FORUM_DRIVER']->mrow_group($member_row)));
		} else
		{
			$real_group_list=$GLOBALS['FORUM_DRIVER']->get_members_groups($member_id);
		}
		require_code('ocfiltering');
		$value=(count(array_intersect(ocfilter_to_idlist_using_memory($new_param,$GLOBALS['FORUM_DRIVER']->get_usergroup_list()),$real_group_list))!=0)?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IS_STAFF($lang,$escaped,$param)
{
	if ((isset($GLOBALS['FORUM_DRIVER'])) && (function_exists('get_member')))
		$value=$GLOBALS['FORUM_DRIVER']->is_staff(((!is_null($param)) && (isset($param[0])))?intval($param[0]):get_member())?'1':'0';
	else
		$value='0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IS_ADMIN($lang,$escaped,$param)
{
	if ((isset($GLOBALS['FORUM_DRIVER'])) && (function_exists('get_member')))
		$value=$GLOBALS['FORUM_DRIVER']->is_super_admin(((!is_null($param)) && (isset($param[0])))?intval($param[0]):get_member())?'1':'0';
	else
		$value='0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_PHOTO($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=$GLOBALS['FORUM_DRIVER']->get_member_photo_url(intval($param[0]));
		if ((url_is_local($value)) && ($value!='')) $value=get_base_url().'/'.$value;
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_OCF_RANK_IMAGE($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (addon_installed('ocf_forum'))
	{
		require_code('ocf_groups');
		$rank_images=new ocp_tempcode();
		$member_id=isset($param[0])?intval($param[0]):get_member();
		$posters_groups=$GLOBALS['FORUM_DRIVER']->get_members_groups($member_id,true);
		foreach ($posters_groups as $group)
		{
			$rank_image=ocf_get_group_property($group,'rank_image');
			$group_leader=ocf_get_group_property($group,'group_leader');
			$group_name=ocf_get_group_name($group);
			$rank_image_pri_only=ocf_get_group_property($group,'rank_image_pri_only');
			if (($rank_image!='') && (($rank_image_pri_only==0) || ($group==$GLOBALS['FORUM_DRIVER']->get_member_row_field($member_id,'m_primary_group'))))
			{
				$rank_images->attach(do_template('OCF_RANK_IMAGE',array('_GUID'=>'513032ef4693abc353f9934e8799943b','USERNAME'=>$GLOBALS['FORUM_DRIVER']->get_username($member_id),'GROUP_NAME'=>$group_name,'IMG'=>$rank_image,'IS_LEADER'=>$group_leader==$member_id)));
			}
		}
		$value=$rank_images->evaluate();
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_URL_FOR_GET_FORM($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$url_bits=parse_url($param[0]);
		if (array_key_exists('scheme',$url_bits))
		{
			$value=$url_bits['scheme'].'://'.(array_key_exists('host',$url_bits)?$url_bits['host']:'localhost');
			if ((array_key_exists('port',$url_bits)) && ($url_bits['port']!=80)) $value.=':'.$url_bits['port'];
		}
		if (array_key_exists('path',$url_bits)) $value.=$url_bits['path'];
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HIDDENS_FOR_GET_FORM($lang,$escaped,$param)
{
	$_value=new ocp_tempcode();
	$url_bits=parse_url($param[0]);
	if ((array_key_exists('query',$url_bits)) && ($url_bits['query']!=''))
	{
		foreach (explode('&',$url_bits['query']) as $exp)
		{
			$parts=explode('=',$exp,2);
			if (count($parts)==2)
			{
				if ((!in_array($parts[0],$param)) && (!in_array(preg_replace('#\d+#','*',$parts[0]),$param)) && (!in_array(preg_replace('#filter_\w+#','filter_*',$parts[0]),$param)))
				{
					$_value->attach(form_input_hidden($parts[0],urldecode($parts[1])));
				}
			}
		}
	}
	$value=$_value->evaluate();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_NOTIFICATIONS_ENABLED($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		require_code('notifications');
		$value=notifications_enabled(array_key_exists(1,$param)?$param[1]:get_page_name(),$param[0])?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_NOTIFICATIONS_AVAILABLE($lang,$escaped,$param)
{
	$value='1';
	if (isset($param[0]))
	{
		$test=$GLOBALS['SITE_DB']->query_select_value_if_there('notification_lockdown','l_setting',array(
			'l_notification_code'=>$param[0],
		));
		if ($test===0) $value='0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MAKE_RELATIVE_DATE($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		if ((get_option('use_contextual_dates')=='0') && ((!array_key_exists(1,$param)) || ($param[1]!='1')))
		{
			$value=get_timezoned_date(intval($param[0]));
		} else
		{
			$value=display_time_period(time()-intval($param[0]));
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_LOAD_PAGE($lang,$escaped,$param)
{
	$temp_array=array();
	handle_symbol_preprocessing(array($escaped,TC_SYMBOL,'LOAD_PAGE',$param),$temp_array); // Late preprocessing. Should not be needed in case of full screen output (as this was properly preprocessed), but is in other cases

	foreach ($param as $i=>$p)
		if (is_object($p)) $param[$i]=$p->evaluate();

	global $PAGES_CACHE;
	if (strpos($param[0],':')!==false)
		$param=array_reverse(explode(':',$param[0],2));
	$_value=$PAGES_CACHE[serialize($param)];
	$value=$_value->evaluate();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_RUNNING_SCRIPT($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=running_script($param[0])?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MATCH_KEY_MATCH($lang,$escaped,$param)
{
	$value='0';
	foreach ($param as $match_key)
	{
		if (($match_key=='1') || ($match_key=='0') || ($match_key=='')) continue;
		if (match_key_match($match_key,((isset($param[1])) && ($match_key=='1')))) $value='1';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_BLOCK($lang,$escaped,$param)
{
	if (!$GLOBALS['STATIC_TEMPLATE_TEST_MODE']) // Normal operation
	{
		$temp_array=array();
		handle_symbol_preprocessing(array($escaped,TC_SYMBOL,'BLOCK',$param),$temp_array); // Late preprocessing. Should not be needed in case of full screen output (as this was properly preprocessed), but is in other cases

		foreach ($param as $i=>$p)
			if (is_object($p)) $param[$i]=$p->evaluate();

		if ((count($param)==1) && (strpos($param[0],',')!==false)) // NB: This code is also in tempcode.php
		{
			$param_2=block_params_str_to_arr($param[0],true);
		} else
		{
			$param_2=$param;
		}

		if (in_array('defer=1',$param_2))
		{
			$value=static_evaluate_tempcode(do_template('JS_BLOCK',array('_GUID'=>'2334719e23b2773ad04fe0fcbdce684d','BLOCK_PARAMS'=>block_params_arr_to_str($param_2))));
		} else
		{
			global $BLOCKS_CACHE;
			if (isset($BLOCKS_CACHE[serialize($param_2)])) // Will always be set
			{
				$value=$BLOCKS_CACHE[serialize($param_2)]->evaluate();
			}
		}
	} else
	{
		$value='';
		if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_FORCE_PREVIEWS($lang,$escaped,$param)
{
	if (get_option('forced_preview_option')=='1')
	{
		if (get_forum_type()=='ocf')
		{
			if ((is_guest()) && (get_option('default_preview_guests')=='0'))
			{
				$value='0';
			} else
			{
				$value=($GLOBALS['FORUM_DRIVER']->get_member_row_field(get_member(),'m_preview_posts')==1)?'1':'0';
			}
		} else
		{
			$value=(get_option('default_preview_guests')=='0')?'0':'1';
		}
	} else
	{
		$value='0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_PREVIEW_URL($lang,$escaped,$param)
{
	$value=find_script('preview');
	$value.='?page='.get_page_name();
	$value.='&type='.get_param('type','',true);

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HIDE_HELP_PANEL($lang,$escaped,$param)
{
	$value=((array_key_exists('hide_helper_panel',$_COOKIE)) && ($_COOKIE['hide_helper_panel']=='1'))?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_FIND_SCRIPT_NOHTTP($lang,$escaped,$param)
{
	if ($GLOBALS['DEV_MODE']) // Debug mode changes base domain so we need to actually use it in full (fine, we don't have HTTPS in debug mode).
		return ecv_FIND_SCRIPT($lang,$escaped,$param);

	$value=preg_replace('#^https?://[^/]+#','',ecv_FIND_SCRIPT($lang,array(),$param));
	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_FIND_SCRIPT($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if ((isset($param[0])) && (function_exists('find_script')))
	{
		$value=find_script($param[0],false,isset($param[1])?intval($param[1]):0);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_CSS_TEMPCODE($lang,$escaped,$param)
{
	$temp_array=array();
	handle_symbol_preprocessing(array($escaped,TC_SYMBOL,'CSS_TEMPCODE',$param),$temp_array); // Late preprocessing. Should not be needed in case of full screen output (as this was properly preprocessed), but is in other cases

	$_value=css_tempcode();
	$value=$_value->evaluate();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_JS_TEMPCODE($lang,$escaped,$param)
{
	$temp_array=array();
	handle_symbol_preprocessing(array($escaped,TC_SYMBOL,'JS_TEMPCODE',$param),$temp_array); // Late preprocessing. Should not be needed in case of full screen output (as this was properly preprocessed), but is in other cases

	$_value=javascript_tempcode(((isset($param[0])) && ($param[0])!='')?$param[0]:NULL);
	$value=$_value->evaluate();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_PAGE_TITLE($lang,$escaped,$param)
{
	global $DISPLAYED_TITLE;
	$value=is_null($DISPLAYED_TITLE)?'':$DISPLAYED_TITLE->evaluate();

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_EXTRA_HEAD($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if ($GLOBALS['EXTRA_HEAD']!==NULL)
	{
		$_value=$GLOBALS['EXTRA_HEAD'];
		$value=$_value->evaluate();
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_EXTRA_FOOT($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if ($GLOBALS['EXTRA_FOOT']!==NULL)
	{
		$_value=$GLOBALS['EXTRA_FOOT'];

		if (array_key_exists(0,$param)) // Set
		{
			$GLOBALS['EXTRA_FOOT']->attach($param[0]);
		} else // Get
		{
			$value=$_value->evaluate();
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_RAND($lang,$escaped,$param)
{
	if (!$GLOBALS['STATIC_TEMPLATE_TEST_MODE']) // Normal operation
	{
		if ((array_key_exists(0,$param)) && ($param[0]=='1')) $GLOBALS['NO_EVAL_CACHE']=true;
		$value=strval(mt_rand(0,32000));
	} else // Been told to behave statically
	{
		$value='4';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_SET_RAND($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		if (!$GLOBALS['STATIC_TEMPLATE_TEST_MODE']) // Normal operation
		{
			if ((array_key_exists(0,$param)) && ($param[0]=='1')) $GLOBALS['NO_EVAL_CACHE']=true;
			$value=$param[mt_rand(0,count($param)-1)];
		} else // Been told to behave statically
		{
			$value=$param[0];
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MEMBER_EMAIL($lang,$escaped,$param)
{
	$value=$GLOBALS['FORUM_DRIVER']->get_member_email_address(isset($param[0])?intval($param[0]):get_member());

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HAS_PRIVILEGE($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if ((isset($param[0])) && (function_exists('has_privilege')))
	{
		$value=has_privilege(((!is_null($param)) && (isset($param[1])))?intval($param[1]):get_member(),$param[0])?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HAS_ZONE_ACCESS($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if ((isset($param[0])) && (function_exists('has_zone_access')))
	{
		$value=has_zone_access(((!is_null($param)) && (isset($param[1])))?intval($param[1]):get_member(),$param[0])?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HAS_DELETE_PERMISSION($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if ((isset($param[0])) && ((strtolower($param[0])=='low') || (strtolower($param[0])=='mid') || (strtolower($param[0])=='high')) && (isset($param[1])))
	{
		$value=has_delete_permission(strtolower($param[0]),((!is_null($param)) && (isset($param[2])))?intval($param[2]):get_member(),intval($param[1]),((!is_null($param)) && (isset($param[3])))?$param[3]:get_page_name())?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_DATE($lang,$escaped,$param)
{
	$use_contextual_dates=(isset($param[0]) && ($param[0]=='1'));
	$verbose=(isset($param[1]) && ($param[1]=='1'));
	$server_time=(isset($param[2]) && ($param[2]=='1'));
	$time=(!empty($param[3]))?intval($param[3]):time();
	$member=isset($param[4])?intval($param[2]):NULL;
	$value=get_timezoned_date($time,false,$verbose,$server_time,!$use_contextual_dates,$member);

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_TIME($lang,$escaped,$param)
{
	$time=(!empty($param[0]))?intval($param[0]):time();
	$use_contextual_dates=(isset($param[1]) && ($param[1]=='1'));
	$server_time=(isset($param[2]) && ($param[2]=='1'));
	$member=isset($param[3])?intval($param[3]):NULL;
	$value=get_timezoned_time($time,!$use_contextual_dates,$member,$server_time);

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_FROM_TIMESTAMP($lang,$escaped,$param)
{
	if (isset($param[0]))
	{
		$timestamp=(!empty($param[1]))?intval($param[1]):time();
		if ((!array_key_exists(2,$param)) || ($param[2]=='1')) $timestamp=utctime_to_usertime($timestamp);
		$value=locale_filter(my_strftime($param[0],$timestamp));
		if ($value==$param[0]) // If no conversion happened then the syntax must have been for 'date' not 'strftime'
			$value=date($param[0],$timestamp);
	} else
	{
		$timestamp=time();
		$value=strval($timestamp);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_DEV_MODE($lang,$escaped,$param)
{
	$value=$GLOBALS['DEV_MODE']?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_BROWSER_MATCHES($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$q=false;
		foreach (explode('|',$param[0]) as $browser)
		{
			$q=browser_matches($browser);
			if ($q) break;
		}
		$value=$q?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_INIT($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		global $TEMPCODE_SETGET;
		if (!isset($TEMPCODE_SETGET[$param[0]])) $TEMPCODE_SETGET[$param[0]]=$param[1];
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_INC($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		global $TEMPCODE_SETGET;
		if (!isset($TEMPCODE_SETGET[$param[0]])) $TEMPCODE_SETGET[$param[0]]='0';
		$TEMPCODE_SETGET[$param[0]]=strval(intval($TEMPCODE_SETGET[$param[0]])+1);
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_PREG_REPLACE($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[2]))
	{
		$value=preg_replace('#'.str_replace('#','\#',$param[0]).'#'.(isset($param[3])?str_replace('e','',$param[3]):''),$param[1],$param[2]);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MAX($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=strval(max(intval($param[0]),intval($param[1])));
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_MIN($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=strval(min(intval($param[0]),intval($param[1])));
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_DIV_FLOAT($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		$value=float_to_raw_string(floatval($param[0])/floatval($param[1]),20,true);
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_DIV($lang,$escaped,$param)
{
	if (floatval($param[1])==0.0)
	{
		$value='divide-by-zero';
	} else
	{
		if (floatval($param[1])==0.0)
		{
			$value='divide-by-zero';
		} else
		{
			$value=strval(intval(floor(floatval($param[0])/floatval($param[1]))));
		}
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_LCASE($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=ocp_mb_strtolower($param[0]);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv__POST($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=post_param($param[0],isset($param[1])?$param[1]:'');
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_REPLACE($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[2]))
	{
		$value=str_replace($param[0],$param[1],$param[2]);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_IN_STR($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		if ($param[1]=='') // Would generate a PHP notice
		{
			$value='0';
		} else
		{
			$value='0';
			foreach ($param as $i=>$check)
			{
				if ((is_integer($i)) && ($i!=0) && ($check!=''))
				{
					if (strpos($param[0],$check)!==false)
					{
						$value='1';
						break;
					}
				}
			}
		}
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_SUBSTR_COUNT($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		$value=strval(substr_count($param[0],$param[1]));
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_SUBSTR($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		$value=ocp_mb_substr($param[0],intval($param[1]),isset($param[2])?intval($param[2]):strlen($param[0]));
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_ALTERNATOR_TRUNCATED($lang,$escaped,$param) // Alternate values according to whether some given text WOULD have been truncated. 0: text to check against, 1: the truncate length, 2:IF would not be do this, 3: if it would be do this, 4: whether given text is encoded as HTML (0=no [default, plain-text], 1=yes)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[3]))
	{
		$amount=intval($param[1]);
		$is_html=((isset($param[4])) && ($param[4]=='1'));
		if (strlen($is_html?strip_tags($param[0]):$param[0])>$amount)
		{
			$value=$param[3];
		} else $value=$param[2];
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_EQ($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (!isset($param[0])) $param[0]='';
	if (!isset($param[1])) $param[1]='';
	$first=array_shift($param);
	$count=0;
	foreach ($param as $test)
	{
		if ($first==$test)
		{
			$count++;
			break;
		}
	}
	$value=($count!=0)?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_NEQ($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (!isset($param[0])) $param[0]='';
	if (!isset($param[1])) $param[1]='';
	$first=array_shift($param);
	$count=0;
	foreach ($param as $test)
	{
		if ($first==$test) $count++;
	}
	$value=($count==0)?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_NOT($lang,$escaped,$param)
{
	$value='1';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		$value=(($param[0]=='1') || ($param[0]=='1'))?'0':'1';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_OR($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	$count=0;
	foreach ($param as $test)
	{
		if (($test=='1') || ($test=='1')) $count++;
	}
	$value=($count>0)?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_AND($lang,$escaped,$param)
{
	$count=0;
	$total=0;
	foreach ($param as $test)
	{
		if (($test=='1') || ($test=='1')) $count++;
		$total++;
	}
	$value=($count==$total)?'1':'0';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_NOR($lang,$escaped,$param)
{
	$count=0;
	foreach ($param as $test)
	{
		if (($test=='1') || ($test=='1')) $count++;
	}
	$value=($count>0)?'0':'1';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_NAND($lang,$escaped,$param)
{
	$count=0;
	foreach ($param as $test)
	{
		if (($test=='1') || ($test=='1')) $count++;
	}
	$value=($count==count($param))?'0':'1';

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_GT($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		$value=(intval($param[0])>intval($param[1]))?'1':'0';
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_FIX_ID($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[0]))
	{
		if (preg_match('#^[A-Za-z][\w]*$#',$param[0])!=0) // Optimisation
		{
			$value=$param[0];
		} else
		{
			$value=fix_id($param[0]);
		}
		if (($GLOBALS['XSS_DETECT']) && (ocp_is_escaped($param[0]))) ocp_mark_as_escaped($value);
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_INSERT_SPAMMER_BLACKHOLE($lang,$escaped,$param)
{
	if (get_option('spam_blackhole_detection')=='1')
	{
		$field_name='x'.md5(get_site_name().': antispam');
		$value='<div id="'.escape_html($field_name).'_wrap" style="display:none"><label for="'.escape_html($field_name).'">'.do_lang('DO_NOT_FILL_ME_SPAMMER_BLACKHOLE').'</label><input id="'.escape_html($field_name).'" name="'.escape_html($field_name).'" value="" type="text" /></div>';
		if (!$GLOBALS['SEMI_DEV_MODE'])
			$value.='<script>// <'.'![CDATA['."\n".'var wrap=document.getElementById(\''.escape_html($field_name).'_wrap\'); wrap.parentNode.removeChild(wrap);'."\n".'//]]></script>';
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_HONEYPOT_LINK($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	$honeypot_url=get_option('honeypot_url');
	if (($honeypot_url!='') && (!is_null($honeypot_url)))
	{
		$first_char=substr(md5(get_page_name()),0,1);
		$bot_phrase=get_option('honeypot_phrase');
		switch ($first_char)
		{
			case '0':
			case '1':
				$value='<a rel="nofollow" href="'.escape_html($honeypot_url).'"><'.'!-- '.escape_html($bot_phrase).' --></a>';
				break;
			case '2':
			case '3':
				$value='<a rel="nofollow" href="'.escape_html($honeypot_url).'"><img alt="'.escape_html($bot_phrase).'" src="'.escape_html(find_theme_image('blank')).'" height="1" width="1" border="0" /></a>';
				break;
			case '4':
			case '5':
				$value='<a rel="nofollow" href="'.escape_html($honeypot_url).'" style="display: none;">'.escape_html($bot_phrase).'</a>';
				break;
			case '6':
			case '7':
				$value='<div style="display: none;"><a rel="nofollow" href="'.escape_html($honeypot_url).'">'.escape_html($bot_phrase).'</a></div>';
				break;
			case '8':
			case '9':
				$value='<a rel="nofollow" href="'.escape_html($honeypot_url).'"></a>';
				break;
			case 'a':
			case 'b':
				$value='<'.'!-- <a rel="nofollow" href="'.escape_html($honeypot_url).'">'.escape_html($bot_phrase).'</a> -->';
				break;
			case 'c':
			case 'd':
				$value='<div style="position: absolute; top: -250px; left: -250px;"><a rel="nofollow" href="'.escape_html($honeypot_url).'">'.escape_html($bot_phrase).'</a></div>';
				break;
			case 'e':
				$value='<a rel="nofollow" href="'.escape_html($honeypot_url).'"><span style="display: none;">'.escape_html($bot_phrase).'</span></a>';
				break;
			case 'f':
				$value='<a rel="nofollow" href="'.escape_html($honeypot_url).'"><div style="height: 0px; width: 0px;"></div></a>';
				break;
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_COMMENT_COUNT($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		static $cache_comment_count=array();
		$cache_key=$param[0].'_'.$param[1];
		if (isset($cache_comment_count[$cache_key]))
		{
			$value=$cache_comment_count[$cache_key];
		}	else
		{
			if (get_option('is_on_comments')=='1')
			{
				$count=0;
				$_comments=$GLOBALS['FORUM_DRIVER']->get_forum_topic_posts($GLOBALS['FORUM_DRIVER']->find_topic_id_for_topic_identifier(get_option('comments_forum_name'),$cache_key),$count,0,0,false);
				if (($count!=0) || (!array_key_exists(2,$param)) || ($param[2]=='0'))
				{
					if (is_array($_comments))
					{
						$_value=do_lang_tempcode('_COMMENTS',escape_html(integer_format($count)));
					} else
					{
						$_value=do_lang_tempcode('_COMMENTS',integer_format(0));
					}
					$value=$_value->evaluate();
				}
			} else
			{
				$value=do_lang('VIEW');
			}
			$cache_comment_count[$cache_key]=$value;
		}
	}

	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_SELF_URL($lang,$escaped,$param)
{
	$extra_params=NULL;
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[3]))
	{
		$extra_params=array();
		$i=3;
		while (isset($param[$i]))
		{
			$bits=explode('=',$param[$i],2);
			if (count($bits)==2)
			{
				if ($bits[1]=='<null>') $bits[1]=NULL;
				$extra_params[$bits[0]]=$bits[1];
			}
			$i++;
		}
	}
	$value=get_self_url(true,(isset($param[0])) && ($param[0]=='1'),$extra_params,(isset($param[1])) && ($param[1]=='1'),(isset($param[2])) && ($param[2]=='1'));

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}

/**
 * Evaluate a particular Tempcode symbol.
 *
 * @param  LANGUAGE_NAME	The language to evaluate this symbol in (some symbols refer to language elements).
 * @param  array				Array of escaping operations.
 * @param  array				Parameters to the symbol. For all but directive it is an array of strings. For directives it is an array of Tempcode objects. Actually there may be template-style parameters in here, as an influence of singular_bind and these may be Tempcode, but we ignore them.
 * @return string				The result.
 */
function ecv_REVIEW_STATUS($lang,$escaped,$param)
{
	$value='';
	if ($GLOBALS['XSS_DETECT']) ocp_mark_as_escaped($value);

	if (isset($param[1]))
	{
		if (addon_installed('content_reviews'))
		{
			require_code('content_reviews');
			$value=show_content_reviews($param[0],$param[1],array_key_exists(2,$param)?intval($param[2]):0);
		}
	}

	if ($escaped!=array()) apply_tempcode_escaping($escaped,$value);
	return $value;
}
