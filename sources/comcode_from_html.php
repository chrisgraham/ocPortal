<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2014

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core_rich_media
 */

/**
 * Standard code module initialisation function.
 */
function init__comcode_from_html()
{
	require_code('comcode_compiler');
}

/**
 * Used by semihtml_to_comcode to turn <img> to \[img\]. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _img_tag_fixup($matches)
{
	$params=trim($matches[1]);
	if ($params!='') $params.=' ';
	$params.=trim($matches[3]);
	if ($params!='') $params=' '.$params;
	$params=str_replace('alt="','param="',$params);
	$params=preg_replace('#style="[^"]*vertical-align: ([^;"]+)(;[^"]*)?;?"#i','align="${1}"',$params);
	$params=str_replace(' class="c_img"','',$params);
	$extraneous=array('border','height','hspace','ismap','longdesc','usemap','vspace','width','id','class','title','style','lang');
	foreach ($extraneous as $ex)
	{
		$params=preg_replace('# '.$ex.'="[^"]*"#','',$params);
	}
	$params=str_replace(' ismap','',$params);

	/*$referer=post_param('http_referer',ocp_srv('HTTP_REFERER'));*/ // CKEditor allows us to specify the base, so we know get_base_url() is right
	$caller_url=/*looks_like_url($referer)?preg_replace('#/[^/]*$#','',$referer):*/get_base_url();

	if ((strpos($matches[2],'{$FIND_SCRIPT')===false) && (strpos($matches[2],'{$IMG')===false))
		$new_url=qualify_url($matches[2],$caller_url);
	else $new_url=$matches[2];

	return '[img'.rtrim($params).']'.$new_url.'[/img]';
}

/**
 * Used by semihtml_to_comcode to turn fix URLs in <img> to be absolute. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _img_tag_fixup_raw($matches)
{
	/*$referer=post_param('http_referer',ocp_srv('HTTP_REFERER'));*/ // CKEditor allows us to specify the base, so we know get_base_url() is right
	$caller_url=/*looks_like_url($referer)?preg_replace('#/[^/]*$#','',$referer):*/get_base_url();

	$matches[2]=html_entity_decode($matches[2],ENT_QUOTES,get_charset());

	if ((strpos($matches[2],'{$FIND_SCRIPT')===false) && (strpos($matches[2],'{$IMG')===false))
		$new_url=qualify_url($matches[2],$caller_url);
	else $new_url=$matches[2];

	$ret='<img'.$matches[1].' src="'.escape_html($new_url).'"'.$matches[3].' />';

	return $ret;
}

/**
 * Used by semihtml_to_comcode to fix <a> tag links. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _a_tag_link_fixup($matches)
{
	$referer=post_param('http_referer',ocp_srv('HTTP_REFERER'));
	$caller_url=looks_like_url($referer)?preg_replace('#/[^/]*$#','',$referer):get_base_url();
	$ret='<a '.$matches[1].'href="'.qualify_url($matches[2],$caller_url).'"'.$matches[3].'>';
	return $ret;
}

/**
 * Used by semihtml_to_comcode to fix CSS colours aways from RGB notation. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _css_color_fixup($matches)
{
	$r=dechex(intval(trim($matches[2])));
	if (strlen($r)==1) $r='0'.$r;
	$g=dechex(intval(trim($matches[3])));
	if (strlen($g)==1) $g='0'.$g;
	$b=dechex(intval(trim($matches[4])));
	if (strlen($b)==1) $b='0'.$b;

	return $matches[1].'#'.$r.$g.$b.$matches[5];
}

/**
 * Used by semihtml_to_comcode to make it so inline CSS with quotes uses single quotes. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _css_quot_fixup($matches)
{
	return str_replace('&quot;','\'',$matches[0]);
}

/**
 * Apply temporary adhoc-escaping to a CDATA area (we'll reverse convert later). preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _cdata_protect($matches)
{
	$new=$matches[2];
	// We use a closing tag, as we can't just type these in the HTML normally (even in CDATA) - so they are safe unused strings
	$new=str_replace(' ','</CDATA__space>',$new);
	$new=str_replace("\t",'</CDATA__tab>',$new);
	$new=str_replace("\n",'</CDATA__nl>',$new);
	$new=str_replace("\r",'</CDATA__lf>',$new);
	$new=str_replace('&','</CDATA__amp>',$new);
	return $matches[1].$new.$matches[3];
}

/**
 * Apply temporary adhoc-escaping to a code tags (we'll reverse convert later). preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _codetag_protect($matches)
{
	$new=$matches[2];
	$new=str_replace('<','___lt___',$new);
	$new=str_replace('>','___gt___',$new);
	return $matches[1].$new.$matches[3];
}

/**
 * Apply temporary adhoc-escaping to a code tags (we'll reverse convert later). preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _codetag_unprotect($matches)
{
	$new=$matches[2];
	$new=str_replace('___lt___','<',$new);
	$new=str_replace('___gt___','>',$new);
	return $matches[1].$new.$matches[3];
}

/**
 * Reorder XHTML attributes alphabetically, so our regexp's match better. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _reorder_xhtml_attributes($matches)
{
	$middle=trim($matches[2]);
	$short=(substr($middle,-1)=='/');
	if ($short)
	{
		if (substr($middle,-2)!=' /') $middle=substr($middle,0,strlen($middle)-1); else $middle=substr($middle,0,strlen($middle)-2);
	}

	$bits=array_map('trim',preg_split('#\s(\w+=)\s*"#',' '.$middle,-1,PREG_SPLIT_DELIM_CAPTURE));
	array_shift($bits);
	$bits2=array();
	for ($i=0;$i<count($bits);$i++)
	{
		if ($i%2==0) $bits2[]=$bits[$i]; else $bits2[intval($i/2)].='"'.$bits[$i];
	}
	sort($bits2);
	$middle=implode(' ',$bits2);

	return '<'.$matches[1].' '.$middle.($short?' /':'').'>';
}

/**
 * Reorder style properties alphabetically, so our regexp's match better. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function _reorder_css_properties($matches)
{
	$middle=$matches[2];
	$bits=array_map('trim',explode(';',$middle));
	sort($bits);
	$middle='';
	foreach ($bits as $bit)
	{
		if (trim($bit)=='') continue;
		if ($middle!='') $middle.='; ';
		$middle.=trim($bit);
	}
	return $matches[1].$middle.$matches[3];
}

/**
 * Convert Semi-HTML into comcode. Cleanup where possible. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function semihtml_to_comcode_wrap($matches)
{
	$middle=semihtml_to_comcode($matches[2]);
	if (substr($middle,0,10)=='[semihtml]') return substr($middle,10,strlen($middle)-21);
	return $matches[1].$middle.$matches[3];
}

/**
 * Extract underlying Comcode from an editor Comcode-management button. preg_replace_callback callback
 *
 * @param  array			Array of matches
 * @return string			Substituted text
 */
function debuttonise($matches)
{
	return html_entity_decode($matches[1],ENT_QUOTES,get_charset());
}

/**
 * Convert HTML headers to Comcode titles
 *
 * @param  string			Semi-HTML
 * @return string			Semi-HTML, with headers converted to titles
 */
function convert_html_headers_to_titles($semihtml)
{
	$array_html_preg_replace=array();
	$array_html_preg_replace[]=array('#^\s*<h1 id="screen_title"[^<>]*>\s*<span class="inner">(.*)</span>\s*</h1>\s*$#siU',"\n\n".'[title="1"]${1}[/title]'."\n\n");
	$array_html_preg_replace[]=array('#^\s*<h1 class="screen_title"[^<>]*>\s*<span class="inner">(.*)</span>\s*</h1>\s*$#siU',"\n\n".'[title="1"]${1}[/title]'."\n\n");
	$array_html_preg_replace[]=array('#^\s*<h1 id="screen_title" class="screen_title">\s*<span class="inner">(.*)</span>\s*</h1>\s*$#siU',"\n\n".'[title="1"]${1}[/title]'."\n\n");
	$array_html_preg_replace[]=array('#^\s*<h1 id="screen_title"[^<>]*>(.*)</h1>\s*$#siU',"\n\n".'[title="1"]${1}[/title]'."\n\n");
	$array_html_preg_replace[]=array('#^\s*<h1 class="screen_title"[^<>]*>(.*)</h1>\s*$#siU',"\n\n".'[title="1"]${1}[/title]'."\n\n");
	$array_html_preg_replace[]=array('#^\s*<h1 id="screen_title" class="screen_title"[^<>]*>(.*)</h1>\s*$#siU',"\n\n".'[title="1"]${1}[/title]'."\n\n");
	$array_html_preg_replace[]=array('#^\s*<h1>(.*)</h1>\s*$#siU',"\n\n".'[title="1"]${1}[/title]'."\n\n");
	$semihtml=array_html_preg_replace('h1',$array_html_preg_replace,$semihtml);
	$semihtml=preg_replace('#^\s*<h1[^>]+>(.*)</h1>\s*#siU',"\n\n".'[title="1"]${1}[/title]'."\n\n",$semihtml);
	for ($i=2;$i<=4;$i++)
	{
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^\s*<h'.strval($i).'><span class="inner">(.*)</span></h'.strval($i).'>\s*$#siU',"\n\n".'[title="'.strval($i).'"]${1}[/title]'."\n\n");
		$array_html_preg_replace[]=array('#^\s*<h'.strval($i).'>(.*)</h'.strval($i).'>\s*$#siU',"\n\n".'[title="'.strval($i).'"]${1}[/title]'."\n\n");
		$semihtml=array_html_preg_replace('h'.strval($i).'',$array_html_preg_replace,$semihtml);
	}
	return $semihtml;
}

/**
 * Convert HTML-filled Comcode to cleaner Comcode.
 *
 * @param  LONG_TEXT		The messy Comcode.
 * @return LONG_TEXT		The cleaned Comcode.
 */
function force_clean_comcode($comcode)
{
	$matches=array();
	if (preg_match('#^\[semihtml\](.*)\[/semihtml\]$#s',$comcode,$matches)!=0)
	{
		if ((strpos($matches[1],'[semihtml]')===false) && (strpos($matches[1],'[html]')===false))
			return semihtml_to_comcode($matches[1],true);
	}
	if (preg_match('#^\[html\](.*)\[/html\]$#s',$comcode,$matches)!=0)
	{
		if ((strpos($matches[1],'[semihtml]')===false) && (strpos($matches[1],'[html]')===false))
			return html_to_comcode($matches[1],true);
	}
	return $comcode;
}

/**
 * Convert Semi-HTML into comcode. Cleanup where possible
 *
 * @param  LONG_TEXT		The Semi-HTML to converted
 * @param  boolean		Whether to force full conversion regardless of settings
 * @return LONG_TEXT		The equivalent Comcode
 */
function semihtml_to_comcode($semihtml,$force=false)
{
	require_code('obfuscate');
	$semihtml=trim($semihtml);

	@ini_set('pcre.backtrack_limit','10000000');

	$semihtml=preg_replace_callback('#<input [^>]*class="ocp_keep_ui_controlled" [^>]*title="([^"]*)" [^>]*type="text" [^>]*value="[^"]*"[^>]*/?'.'>#siU','debuttonise',$semihtml);
	$array_html_preg_replace=array();
	$semihtml=str_replace('&#8203;','',$semihtml);
	if (strtolower(get_charset())=='utf-8')
		$semihtml=str_replace(chr(hexdec('e2')).chr(hexdec('80')).chr(hexdec('8b')),'',$semihtml);
	$array_html_preg_replace[]=array('#^<kbd class="(ocp_keep|ocp_keep_block)"[^>]*>(.*)</kbd>$#siU',"\${2}");
	$semihtml=array_html_preg_replace('kbd',$array_html_preg_replace,$semihtml);
	$semihtml=str_replace('<!-- >','',$semihtml);
	$semihtml=preg_replace('#<span id="cke_bm_[^"]+" style="display: none;\s*">&nbsp;</span>#','',$semihtml);

	$semihtml=preg_replace('#(\[[\w\_]+)&nbsp;#','${1} ',$semihtml);

	$matches=array();
	if ((!$force) && ((get_option('eager_wysiwyg')=='0') && ((substr_count($semihtml,'://')<=preg_match_all('#(codebase="[^"]*://[^"]*"|data="[^"]*://[^"]*"|action="[^"]*://[^"]*"|href="[^"]*://[^"]*"|src="[^"]*://[^"]*"|url\([^\)]*://[^\)]*\))#',$semihtml,$matches)) || (count(find_all_hooks('systems','comcode_link_handlers'))==0)) && (has_privilege(get_member(),'allow_html'))) || (strpos($semihtml,'{$,page hint: no_smart_conversion}')!==false))
	{
		$semihtml=preg_replace_callback('#<img([^>]*) src="([^"]*)"([^>]*) />#siU','_img_tag_fixup_raw',$semihtml); // Resolve relative URLs
		$semihtml=preg_replace_callback('#<img([^>]*) src="([^"]*)"([^>]*)>#siU','_img_tag_fixup_raw',$semihtml); // Resolve relative URLs

		if (strpos($semihtml,'[contents')!==false) // Contents tag needs proper Comcode titles
		{
			$semihtml=convert_html_headers_to_titles($semihtml);
		}

		$count=substr_count($semihtml,'[/')+substr_count($semihtml,'@')+substr_count($semihtml,'{')+substr_count($semihtml,'[[')+substr_count($semihtml,'<h1');
		if (($count==0) && (strpos($semihtml,'<h1')===false)) return ($semihtml=='')?'':('[html]'.$semihtml.'[/html]');
		$count2=substr_count($semihtml,'[/attachment]')+substr_count($semihtml,'<h1');
		if ($count2==$count) // All HTML or attachments or headers, so we can encode mostly as 'html' (as opposed to 'semihtml')
		{
			if ($semihtml!='') $semihtml='[html]'.$semihtml.'[/html]';
			$semihtml=preg_replace('#<h1[^>]*>\s*<span class="inner">(.*)</span>\s*</h1>#Us','[/html][semihtml][title]${1}[/title][/semihtml][html]',$semihtml);
			$semihtml=preg_replace('#<h1[^>]*>(.*)</h1>#Us','[/html][semihtml][title]${1}[/title][/semihtml][html]',$semihtml);
			$semihtml=str_replace('[attachment','[/html][semihtml][attachment',str_replace('[/attachment]','[/attachment][/semihtml][html]',$semihtml));
			$semihtml=str_replace('[/html][html]','',$semihtml);
			$semihtml=str_replace('[html][/html]','',$semihtml);
			return $semihtml;
		}
		if ($semihtml!='') $semihtml='[semihtml]'.$semihtml.'[/semihtml]';
		$semihtml=preg_replace('#<h1[^>]*>\s*<span class="inner">(.*)</span>\s*</h1>#Us','[title]${1}[/title]',$semihtml);
		$semihtml=preg_replace('#<h1[^>]*>(.*)</h1>#Us','[title]${1}[/title]',$semihtml);
		return $semihtml;
	}

	require_code('xhtml');
	$semihtml=xhtmlise_html($semihtml,true); // Needed so we can parse it right

	// Safety from if these are typed in (could cause problems)
	$semihtml=str_replace('[html'.($force?']':''),$force?'':'[ html',$semihtml);
	$semihtml=str_replace('[semihtml'.($force?']':''),$force?'':'[ semihtml',$semihtml);
	$semihtml=str_replace('[/html'.($force?']':''),$force?'':'[ / html',$semihtml);
	$semihtml=str_replace('[/semihtml'.($force?']':''),$force?'':'[ / semihtml',$semihtml);

	// This is useful for generally stripping sensitive information anyway. Should be null-op if anti-leech was on, but worth doing just-in-case.
	$semihtml=preg_replace('#&amp;keep_session=[\d]*(&amp;for_session=[\w\d]*)?#','',$semihtml);

	// We must protect anything that is in CDATA from whitespace/entity cleanup (HTML or XHTML - we have to use lowest common denominator)
	$semihtml=preg_replace_callback('#(<script[^>]*>)(.*)(</script>)#siU','_cdata_protect',$semihtml);
	$semihtml=preg_replace_callback('#(<style[^>]*>)(.*)(</style>)#siU','_cdata_protect',$semihtml);
	$semihtml=preg_replace_callback('#(<textarea[^>]*>)(.*)(</textarea>)#siU','_cdata_protect',$semihtml);
	$semihtml=preg_replace_callback('#(<pre[^>]*>)(.*)(</pre>)#siU','_cdata_protect',$semihtml);
	$semihtml=preg_replace_callback('#(<![CDATA[)(.*)(]]>)#siU','_cdata_protect',$semihtml);
	// And use same method to protect our code tags
/*	foreach (array_keys($GLOBALS['CODE_TAGS']) as $code_tag)
		$semihtml=preg_replace_callback('#(\['.$code_tag.'[^\]]*\])(.*)(\[/'.$code_tag.'\])#siU','_codetag_protect',$semihtml);
Actually no, we don't want this. These tags are typed potentially to show HTML and thus the entities must get decoded
*/

	// Cleanup from certain word processors
	// LibreOffice
		$semihtml=str_replace('<h2 class="western">','<h2>',$semihtml);
		$semihtml=preg_replace('#</(ul|ol|h1|h2|h3|h4|h5|h6)>\s*<p style="margin-bottom: 0(cm|em|px)?">\s*&nbsp;\s*</p>\s*#Us','</${1}>',$semihtml);
		$semihtml=preg_replace('#<p style="margin-bottom: 0(cm|em|px)?">\s*&nbsp;\s*</p>\s*#Us','',$semihtml);
		$semihtml=preg_replace('#<li>\s*<p style="margin-bottom: 0(cm|em|px)?">(.*)</p>\s*</li>#Us','<li>${2}</li>',$semihtml);
		$semihtml=preg_replace('#<p style="margin-bottom: 0(cm|em|px)?">(.*)</p>\s*<(ul|ol|h1|h2|h3|h4|h5|h6)>#Us','${2}<${3}>',$semihtml);
		$semihtml=str_replace('<p style="margin-bottom: 0cm">','<p>',$semihtml);
	$semihtml=preg_replace('#(<style[^>]*>)(.*)(</style>)#siU','',$semihtml); // We shouldn't allow this nested anyway (invalid XHTML), and word abuses it
	$semihtml=preg_replace('#<span class="Apple-style-span"[^>]*>(.*)</span>#siU','${1}',$semihtml); // webkit
	$semihtml=preg_replace('#<meta[^>]*>#siU','',$semihtml); // We shouldn't allow this nested anyway (invalid XHTML), and word abuses it
	$semihtml=preg_replace('#(<[^>]*) lang="[^"]*"#i','${1}',$semihtml);
	$semihtml=preg_replace('#(<[^>]*) style="margin-right: 0\w*;?"#i','${1}',$semihtml);
	$semihtml=preg_replace('#(<[^>]*) dir="'.do_lang('dir').'"#i','${1}',$semihtml);
	$semihtml=preg_replace_callback('#<[^>"]* style="([^">]*&quot;[^">]*)*"#i','_css_quot_fixup',$semihtml);
	$semihtml=preg_replace('#<a name="OLE_LINK1">([^<]*)</a>#siU','${1}',$semihtml);
	$semihtml=preg_replace('#(<[^>]* align="right"[^>]*) style="(margin-right: [\d\.]+pt;\s*)?text-align: right;?"#is','${1}',$semihtml); // trim off redundancy
	$semihtml=preg_replace('#(<[^>]* align="center"[^>]*) style="(margin-right: [\d\.]+pt;\s*)?text-align: center;?"#is','${1}',$semihtml); // trim off redundancy
	$semihtml=preg_replace('#(?U)(<[^>]* style="[^"]*)(?-U);?\s*page-break-after: avoid;?"#is','${1}"',$semihtml);
	$semihtml=str_replace('<place>','',$semihtml);
	$semihtml=str_replace('</place>','',$semihtml);
	$semihtml=preg_replace('#<link [^>]*href="file://[^"]*"[^>]*/>#sU','',$semihtml);
	$semihtml=preg_replace('#<!--\[if(.*)-->#sU','',$semihtml);
	$semihtml=preg_replace('#<!--(.*)\[endif(.*)-->#sU','',$semihtml);
	$semihtml=str_replace('<!-- >','',$semihtml);
	$semihtml=preg_replace('#</?[ovw]:[^>]*>#s','',$semihtml);
	$semihtml=preg_replace('#(<[^>]*) [ovw]:[^>"]*"[^"]*"([^>]*>)#s','${1}${2}',$semihtml);
	$semihtml=preg_replace('#</?st1:[^>]*>#','',$semihtml); // Word smart tags
	$semihtml=str_replace('<br class="Apple-interchange-newline" />','<br />',$semihtml);

	$semihtml=str_replace("\n",' ',$semihtml);
	// Clean some whitespace (they have a special Comcode meaning, but no special HTML meaning)
	$inline_elements=array(
		'font','s','u','strike','span','abbr','acronym','cite',
		'code','dfn','em','strong','kbd','q','samp','var',
		'sub','sup','tt','del','ruby','a','bdo','img',
		'ins','param','textarea','button','input','select',
		'object','caption','label','b','i','small','big');
	$semihtml=preg_replace('#(<('.implode('|',$inline_elements).')( [^>]*)?'.'>)\s+#','${1}</CDATA__space>',$semihtml);
	$semihtml=preg_replace('#\s+(</('.implode('|',$inline_elements).')>)#','</CDATA__space>${1}',$semihtml);
	$semihtml=preg_replace('#([^\>\s])\s+(<('.implode('|',$inline_elements).')( [^>]*)?'.'>)#','${1}</CDATA__space>${2}',$semihtml);
	$semihtml=preg_replace('#(</('.implode('|',$inline_elements).')>)\s+#','${1}</CDATA__space>',$semihtml);
	$semihtml=preg_replace('#>\s+#','>',$semihtml);
	$semihtml=preg_replace('#\s+<#','<',$semihtml);
	$semihtml=preg_replace('#\s+#',' ',$semihtml);

	// Cleanup impossible stuff in code tags
	global $CODE_TAGS;
	foreach (array_keys($CODE_TAGS) as $tag)
	{
		$semihtml=comcode_preg_replace($tag,'#^(\['.$tag.'\])(.*)(\[/'.$tag.'\])$#si',array('comcode_strip_html_tags'),$semihtml);
	}

	// Cleanup how blocks are converted into a line break model. We need to clean up the case where inline leads onto block, by adding a linebreak inbetween. Note that this kind of break does not go *between* blocks, which is the reason we can't arbitrarily place it later on.
	$semihtml=preg_replace('#([^\s<>]|</('.implode('|',$inline_elements).')>)(<(div|p))#','${1}<br />${3}',$semihtml);

	// Reorder XHTML attributes alphabetically, so our regexp's match better
	$semihtml=preg_replace_callback('#<([^>\s]+)\s([^>]+)>#','_reorder_xhtml_attributes',$semihtml);

	// Reorder style properties alphabetically, so our regexp's match better
	$semihtml=preg_replace_callback('#(<[^>]*style=")([^"]*)("[^>]*>)#','_reorder_css_properties',$semihtml);

	$semihtml=str_replace('<p  />','<br /><br />',str_replace('<p />','<br /><br />',$semihtml));

	// Remove proprietary stylings put in by RTF->HTML conversions performed by certain browsers
	$old_semihtml='';
	do
	{
		$old_semihtml=$semihtml;
		$semihtml=preg_replace('#(<[^>]* style="(?U)[^">]*(?-U))-\w+-[^";>]*(;\s*)?#s','${1}',$semihtml);
	}
	while ($semihtml!=$old_semihtml);

	// Perform lots of conversions. We can't convert everything. Sometimes we reverse-convert what Comcode forward-converts; sometimes we match generic HTML; sometimes we match Microsoft Word or Open Office; sometimes we do lossy match
	$semihtml=convert_html_headers_to_titles($semihtml);
	$array_html_preg_replace=array();
	$array_html_preg_replace[]=array('#^<span>(.*)</span>$#siU','${1}');
	$array_html_preg_replace[]=array('#^<span( charset="[^"]*")?( content="[^"]*")?( name="[^"]*")?'.'>(.*)</span>$#siU','${4}');
	$array_html_preg_replace[]=array('#^<span style="\s*?font-family:\s*monospace;\s*?font-size:\s*[\d\.]*em;?">(.*)</span>$#siU','[tt]${1}[/tt]');
	$array_html_preg_replace[]=array('#^<span style="\s*?font-weight:\s*bold;?">(.*)</span>$#siU','[b]${1}[/b]');
	$array_html_preg_replace[]=array('#^<span style="\s*?font-style:\s*italic;?">(.*)</span>$#siU','[i]${1}[/i]');
	$array_html_preg_replace[]=array('#^<span style="\s*?text-decoration:\s*underline;?">(.*)</span>$#siU','[u]${1}[/u]');
	$array_html_preg_replace[]=array('#^<span( href="[^"]*")?( rel="[^"]*")?'.'>(.*)</span>$#siU','${3}');
	$array_html_preg_replace[]=array('#^<span style="\s*?font-weight:\s*bold;?">(.*)</span>$#siU','[b]${1}[/b]');
	$array_html_preg_replace[]=array('#^<span style="\s*?font-style:\s*italic;?">(.*)</span>$#siU','[i]${1}[/i]');
	$array_html_preg_replace[]=array('#^<span style="\s*?text-decoration:\s*underline;?">(.*)</span>$#siU','[u]${1}[/u]');
	$array_html_preg_replace[]=array('#^<span style="\s*?color:\s*?([^";]+);\s*?font-family:\s*?([^";]+);\s*?font-size:\s*?([^";]+);?"([^>]*)>(.*)</span>$#siU','[font param="${2}" color="${1}" size="${3}"]${5}[/font]');
	$array_html_preg_replace[]=array('#^<span style="\s*?color:\s*?([^";]+);\s*?font-size:\s*?([^";]+);?"([^>]*)>(.*)</span>$#siU','[font color="${1}" size="${2}"]${4}[/font]');
	$array_html_preg_replace[]=array('#^<span style="\s*?color:\s*?([^";]+);\s*?font-family:\s*?([^";]+);?"([^>]*)>(.*)</span>$#siU','[font param="${2}" color="${1}"]${4}[/font]');
	$array_html_preg_replace[]=array('#^<span style="\s*?color:\s*?([^";]+);?\s*?"([^>]*)>(.*)</span>$#siU','[font color="${1}"]${3}[/font]');
	$array_html_preg_replace[]=array('#^<span style="\s*?font-family:\s*?([^";]+);\s*?font-size:\s*?([^";]+);?"([^>]*)>(.*)</span>$#siU','[font param="${1}" size="${2}"]${4}[/font]');
	$array_html_preg_replace[]=array('#^<span style="\s*?font-size:\s*?([0-9\.]+\w\w);?\s*?"([^>]*)>(.*)</span>$#siU','[font size="${1}"]${3}[/font]');
	$array_html_preg_replace[]=array('#^<span style="\s*?font-family:\s*?([^";]+);?\s*?"([^>]*)>(.*)</span>$#siU','[font param="${1}"]${3}[/font]');
	$complex_equivs=array('<span class="comcode_highlight">(.*)</span>'=>'highlight','<span class="comcode_bold">(.*)</span>'=>'b','<span class="comcode_italic">(.*)</span>'=>'i','<span class="comcode_underline">(.*)</span>'=>'u');
	foreach ($complex_equivs as $from=>$to)
	{
		$array_html_preg_replace[]=array('#^'.$from.'$#siU','['.$to.']${1}[/'.$to.']');
	}
	$semihtml=array_html_preg_replace('span',$array_html_preg_replace,$semihtml);
	$_array_html_preg_replace=array();
	foreach ($array_html_preg_replace as $i=>$x)
	{
		$_array_html_preg_replace[$i]=array();
		$_array_html_preg_replace[$i][0]=str_replace('span','div',$x[0]);
		$_array_html_preg_replace[$i][1]='<div>'.$x[1].'</div>';
	}
	$semihtml=array_html_preg_replace('div',$_array_html_preg_replace,$semihtml);
	$_array_html_preg_replace=array();
	foreach ($array_html_preg_replace as $i=>$x)
	{
		$_array_html_preg_replace[$i]=array();
		$_array_html_preg_replace[$i][0]=str_replace('div','p',$x[0]);
		$_array_html_preg_replace[$i][1]='<p>'.$x[1].'</p>';
	}
	$semihtml=array_html_preg_replace('p',$_array_html_preg_replace,$semihtml);
	$array_html_preg_replace=array();
	$array_html_preg_replace[]=array('#^<font>(.*)</font>$#siU','${1}');
	$array_html_preg_replace[]=array('#^<font ([^>]*)size="(\d+)"([^>]*)>(.*)</font>$#siU','[font ${1}${3} size="${2}of"]${4}[/font]');
	$array_html_preg_replace[]=array('#^<font([^>]*)>(.*)</font>$#siU','[font${1}]${2}[/font]');
	$semihtml=array_html_preg_replace('font',$array_html_preg_replace,$semihtml);
	$semihtml=preg_replace_callback('#(\[font [^\]]*color=")rgb\((\s*\d+\s*),(\s*\d+\s*),(\s*\d+\s*)\)("[^\]]*\])#','_css_color_fixup',$semihtml);
	$semihtml=preg_replace_callback('#<a ([^>]*)href="([^"]*)"([^>]*)>#','_a_tag_link_fixup',$semihtml);
	$array_html_preg_replace=array();
	require_code('obfuscate');
	$array_html_preg_replace[]=array('#^<a ([^>]*)href="mailto:(?-U) ?(?U)([^"]+)"([^>]*)>(.*)</a>$#siU','[email="${2}"]${4}[/email]');
	$array_html_preg_replace[]=array('#^<a ([^>]*)href="'.preg_quote(mailto_obfuscated(),'#').'([^"]+)"([^>]*)>(.*)</a>$#siU','[email="${4}"]${2}[/email]');
	$array_html_preg_replace[]=array('#^<a ([^>]*)href="([^"]+)"([^>]*) rel="([^"]*)" target="([^"]*)"([^>]*)>(.*)</a>$#siU','[url="${2}" rel="${4}" target="${5}"]${7}[/url]');
	$array_html_preg_replace[]=array('#^<a ([^>]*)href="([^"]+)"([^>]*) target="([^"]*)"([^>]*)>(.*)</a>$#siU','[url="${2}" target="${4}"]${6}[/url]');
	$array_html_preg_replace[]=array('#^<a ([^>]*)href="([^"]+)"([^>]*) rel="([^"]*)"([^>]*)>(.*)</a>$#siU','[url="${2}" rel="${4}"]${6}[/url]');
	$array_html_preg_replace[]=array('#^<a ([^>]*)href="([^"]+)"([^>]*)>(.*)</a>$#siU','[url="${2}"]${4}[/url]');
	$semihtml=array_html_preg_replace('a',$array_html_preg_replace,$semihtml);
	$array_html_preg_replace=array();
	$array_html_preg_replace[]=array('#^<p class="msoNormal">\s*(.*)\s*</p>$#siU','${1}<br />');
	$array_html_preg_replace[]=array('#^<p align="(\w+)" class="msoNormal">\s*(.*)\s*</p>$#siU','[align="${1}"]${2}[/align]');
	$array_html_preg_replace[]=array('#^<p class="msoNormal" style="margin: \d+pt 0[\w;]*">\s*(.*)\s*</p>$#siU','<br />${1}<br />'); // Cleanup from Word
	$array_html_preg_replace[]=array('#^<p class="msoNormal" style="margin: 0[\w;]* 0[\w;]* 0[\w;]*">\s*(.*)\s*</p>$#siU','${1}<br />'); // Cleanup from Word
	$array_html_preg_replace[]=array('#^<p style="margin: \d+pt 0[\w;]*">\s*(.*)\s*</p>$#siU','<br />${1}<br />'); // Cleanup from Word
	$array_html_preg_replace[]=array('#^<p style="margin: 0[\w;]* 0[\w;]* 0[\w;]*">\s*(.*)\s*</p>$#siU','${1}<br />'); // Cleanup from Word
	$array_html_preg_replace[]=array('#^<p class="Mso\w*" style="[^"]*">\s*(.*)\s*</p>$#siU','<br />${1}<br />'); // Aggressive cleanup from Word (it's here last because we want the nicer matches to get a chance to work instead. It's a shame we need to do this, as we are throwing away potentially important styling (although actually the spans etc far above will have got most of this - we only match p level styling here)- but Word throws so much into a mix it's impossible to "remove the wheat from the chaff". People will need to put it back in using the WYSIWYG editor directly.
	$array_html_preg_replace[]=array('#^<p>\s*(.*)\s*</p>$#siU','${1}<br /><br />');
	$array_html_preg_replace[]=array('#^<p align="(\w+)">\s*(.*)\s*</p>$#siU','[align="${1}"]${2}[/align]');
	$semihtml=array_html_preg_replace('p',$array_html_preg_replace,$semihtml);
	$array_html_preg_replace=array();
	$array_html_preg_replace[]=array('#^<div align="justify">(.*)</div>$#siU','[align="justify"]${1}[/align]');
	$array_html_preg_replace[]=array('#^<div style="text-align:\s*?justify;?">(.*)</div>$#siU','[align="justify"]${1}[/align]');
	$complex_equivs=array('<div align="right">(.*)</div>'=>'right','<div align="left">(.*)</div>'=>'left','<div align="center">(.*)</div>'=>'center','<div style="text-align:\s*?right;?">(.*)</div>'=>'right','<div style="text-align:\s*?left;?">(.*)</div>'=>'left','<div style="text-align:\s*?center;*">(.*)</div>'=>'center');
	foreach ($complex_equivs as $from=>$to)
	{
		$array_html_preg_replace[]=array('#^'.$from.'$#siU','['.$to.']${1}[/'.$to.']');
	}
	$array_html_preg_replace[]=array('#^<div style="margin-left:\s*?(\d+)px;?">(.*)</div>$#siU','[indent="${1}"]${2}[/indent]');
	$array_html_preg_replace[]=array('#^<div class="([^"]+)">(.*)</div>$#siU','[surround="${1}"]${2}[/surround]');
	$array_html_preg_replace[]=array('#^<div>(.*)</div>$#siU','${1}<br />');
	$semihtml=array_html_preg_replace('div',$array_html_preg_replace,$semihtml);
	$_array_html_preg_replace=array();
	foreach ($array_html_preg_replace as $i=>$x)
	{
		$_array_html_preg_replace[$i]=array();
		$_array_html_preg_replace[$i][0]=str_replace('div','span',$x[0]);
		$_array_html_preg_replace[$i][1]=$x[1];
	}
	$semihtml=array_html_preg_replace('span',$_array_html_preg_replace,$semihtml);
	$_array_html_preg_replace=array();
	foreach ($array_html_preg_replace as $i=>$x)
	{
		$_array_html_preg_replace[$i]=array();
		$_array_html_preg_replace[$i][0]=str_replace('div','p',$x[0]);
		$_array_html_preg_replace[$i][1]=str_replace('<br />','<br /><br />',$x[1]);
	}
	$semihtml=array_html_preg_replace('p',$_array_html_preg_replace,$semihtml);
	$array_html_preg_replace=array();
	$array_html_preg_replace[]=array('#^<kbd>(.*)</kbd>$#siU',"[tt]\${1}[/tt]");
	$semihtml=array_html_preg_replace('kbd',$array_html_preg_replace,$semihtml);
	$array_html_preg_replace=array();
	$array_html_preg_replace[]=array('#^<ul dir="ltr">(.*)</ul>$#siU','[list]'.'${1}[/list]');
	$array_html_preg_replace[]=array('#^<ul>(.*)</ul>$#siU','[list]'.'${1}[/list]');
	$semihtml=array_html_preg_replace('ul',$array_html_preg_replace,$semihtml);
	$array_html_preg_replace=array();
	$array_html_preg_replace[]=array('#^<ol>(.*)</ol>$#siU','[list="1"]'.'${1}[/list]');
	$array_html_preg_replace[]=array('#^<ol style="list-style-type:\s*?([^";]*);?">(.*)(</ol>|<ol />)$#siU','[list="${1}"]'.'${2}[/list]');
	$array_html_preg_replace[]=array('#^<ol type="([^"]*)">(.*)</ol>$#siU','[list="${1}"]'.'${2}[/list]');
	$semihtml=array_html_preg_replace('ol',$array_html_preg_replace,$semihtml);
	$array_html_preg_replace=array();
	if (strpos($semihtml,'[list')!==false) // Because not all HTML list tags will convert, e.g. if has CSS class on it
	{
		$array_html_preg_replace[]=array('#^<li>(.*)</li>$#siU','[*]${1}[/*]'."\n");
		$semihtml=array_html_preg_replace('li',$array_html_preg_replace,$semihtml);
	}
	$semihtml=str_replace('<strong class="comcode_bold">','<strong>',$semihtml);
	$semihtml=str_replace('<em class="comcode_italic">','<em>',$semihtml);
	$equivs=array('blockquote'=>'indent','code'=>'code','tt'=>'tt','sub'=>'sub','sup'=>'sup','center'=>'center','!abbr'=>'abbr','!acronym'=>'acronym','address'=>'address','dfn'=>'dfn','cite'=>'cite','strong'=>'b','b'=>'b','em'=>'i','i'=>'i','u'=>'u','strike'=>'s','del'=>'del','ins'=>'ins');
	foreach ($equivs as $from=>$to)
	{
		$array_html_preg_replace=array();
		if ($from[0]=='!')
		{
			$from=substr($from,1);
			$array_html_preg_replace[]=array('#^<'.$from.'([^>]*)>(.*)</'.$from.'>$#siU','['.$to.'${1}]${2}[/'.$to.']');
		} else
		{
			$array_html_preg_replace[]=array('#^<'.$from.'>(.*)</'.$from.'>$#siU','['.$to.']${1}[/'.$to.']');
		}
		$semihtml=array_html_preg_replace($from,$array_html_preg_replace,$semihtml);
	}

	// Fonts that set nothing
	$test=preg_replace('#\[font param="verdana,arial,helvetica,sans-serif"#','',$semihtml);
	$test=preg_replace('#\[font="verdana,arial,helvetica,sans-serif"#','',$test);

	if ((strpos($test,'[font=')===false) && (strpos($test,'[font param=')===false))
	{
		$semihtml=comcode_preg_replace('font','#^\[font( param)?="verdana,arial,helvetica,sans-serif"](.*)\[/font\]$#si','${2}',$semihtml);
		$semihtml=str_replace(' param="verdana,arial,helvetica,sans-serif"','',$semihtml);
		$semihtml=str_replace('="verdana,arial,helvetica,sans-serif"','',$semihtml);
	}

	// Our cleanup loop. These optimisations trickle-through, as they depend on each other. We keep looping until we've done all we can.
	$old_semihtml='';
	$text_formatting_tags=array('b','i','u','tt','font','title','center','left','right','color');
	do
	{
		$old_semihtml=$semihtml;

		// Empty tags
		$semihtml=preg_replace('#\<(\w+)\>\</\1\>#','',$semihtml);
		$semihtml=preg_replace('#\[font[^\]]*\]\[/font\]#','',$semihtml);
		$semihtml=preg_replace('#\[b[^\]]*\]\[/b\]#','',$semihtml);
		$semihtml=preg_replace('#\[i[^\]]*\]\[/i\]#','',$semihtml);

		// Canonical order to make sure we can find pointless nestings. Unfortunately we can only bubble out one level due to constraints in our regexp checking (we need to make sure we don't cross-tags, but we can't in a regexp unless we make sure we have no nesting at all)
		foreach ($text_formatting_tags as $i=>$tag)
		{
			foreach ($text_formatting_tags as $j=>$tag_2)
			{
				if ($i<$j)
				{
					$semihtml=comcode_preg_replace($tag_2,'#^(\['.$tag_2.'( [^\]]*)?\])(\['.$tag.'( [^\]]*\])?)([^\[\]]*)(\[/'.$tag.'[^\]]*\])(\[/'.$tag_2.'[^\]]*\])$#si','${3}${1}${5}${7}${6}',$semihtml);
				}
			}
		}

		// Cleanup nested fonts
		$semihtml=preg_replace('#<span[^<>]*></span>#siU','',$semihtml);
		$semihtml=comcode_preg_replace('font','#^\[font([^\]]*)\](\s*)\[font([^\]]*)\](.*)\[/font\](\s*)\[/font\]$#si','[font${1}${3}]${2}${4}${5}[/font]',$semihtml);
		$semihtml=preg_replace('#\[font ([^\]]*)face="([^"]*)"([^\]]*)face="([^"]*)"([^\]]*)\]#si','[font ${1}${3}${5} face="${4}"]',$semihtml);
		$semihtml=preg_replace('#\[font ([^\]]*)size="([^"]*)"([^\]]*)size="([^"]*)"([^\]]*)\]#si','[font ${1}${3}${5} size="${4}"]',$semihtml); // This is imperfect (due to relative font sizes), but at least it encourages cleanup
		$semihtml=preg_replace('#\[font ([^\]]*)color="([^"]*)"([^\]]*)color="([^"]*)"([^\]]*)\]#si','[font ${1}${3}${5} color="${4}"]',$semihtml);
		$semihtml=preg_replace('#\[font ([^\]]*)param="([^"]*)"([^\]]*)param="([^"]*)"([^\]]*)\]#si','[font ${1}${3}${5} param="${4}"]',$semihtml);
		$semihtml=preg_replace('#(\[font.*)(?-U)\s+(?U)(.*\])#U','${1} ${2}',$semihtml); // safe because no whitespace runs can be expected within a font tag

		// Cleanup other nestings / close then reopen patterns
		foreach (array('b','i','u','tt','font size="[^"]*"') as $tag)
		{
			$tagx=(strpos($tag,' ')!==false)?substr($tag,0,strpos($tag,' ')):$tag;

			$semihtml=comcode_preg_replace($tagx,'#^(\['.$tag.'\])(.*)\\1(.*)\[/'.$tagx.'\](.*)\[/'.$tagx.'\]$#si','${1}${2}${3}${4}[/'.$tagx.']',$semihtml);

			$semihtml=preg_replace('#(\['.$tag.'\])([^\[\]]*)\[/'.$tagx.'\]((&nbsp;|</CDATA\_\_space>|\s)*)\\1#si','${1}${2}${3}',$semihtml); // Only works in simple case, not when there are tags nested within first tag. Can't use comcode_preg_replace as we are joining two tags (i.e. not operating over single bind)
		}

		// Cleanup lines filled with spaces/font-junk
		foreach ($text_formatting_tags as $tag)
		{
			$semihtml=preg_replace('#(\['.$tag.'[^\]]*\])((&nbsp;|</CDATA\_\_space>|\s|<br\s*/>|\n)*)#i','${2}${1}',$semihtml); // Tag starting unnecessarily early -> Move it back
			$semihtml=preg_replace('#((&nbsp;|</CDATA\_\_space>|\s|<br\s*/>|\n)*)(\[/'.$tag.'\])#i','${3}${1}',$semihtml); // Tag ending unnecessarily late -> Move it back
			$semihtml=preg_replace('#\['.$tag.'[^\]]*\]((&nbsp;|</CDATA\_\_space>|\s|<br\s*/>|\n)*)\[/'.$tag.'\]#i','${1}',$semihtml); // Tag wrapping whitespace -> White space
		}
		$semihtml=preg_replace('#(&nbsp;|</CDATA\_\_space>|\s)*<br\s*/>#i','<br />',$semihtml); // Spaces on end of line -> (Remove)
	}
	while ($semihtml!=$old_semihtml);

	// Undone center tagging
	$semihtml=comcode_preg_replace('left','#^\[left\]\[center\](.*)\[/center\]\[/left\]$#si','[left]${1}[/left]',$semihtml);
	$semihtml=comcode_preg_replace('right','#^\[right\]\[center\](.*)\[/center\]\[/right\]$#si','[right]${1}[/right]',$semihtml);
	$semihtml=comcode_preg_replace('center','#^\[center\]\[left\](.*)\[/left\]\[/center\]$#si','[center]${1}[/center]',$semihtml);
	$semihtml=comcode_preg_replace('center','#^\[center\]\[right\](.*)\[/right\]\[/center\]$#si','[center]${1}[/center]',$semihtml);

	// Cleanup list Comcode (nice and pretty)
	$semihtml=preg_replace('#(&nbsp;|</CDATA\_\_space>|\s|<br\s*/>|\n)*\[/\*\](&nbsp;|</CDATA\_\_space>|\s|<br\s*/>|\n)*#','[/*]',$semihtml);
	$semihtml=preg_replace('#(&nbsp;|</CDATA\_\_space>|\s|<br\s*/>|\n)*\[\*\](&nbsp;|</CDATA\_\_space>|\s|<br\s*/>|\n)*#','[*]',$semihtml);
	$semihtml=preg_replace('#\[/\*\]([^\s])#','[/*]<ocpbr />${1}',$semihtml);
	$semihtml=preg_replace('#\[list\]([^\s])#','[list]<ocpbr />${1}',$semihtml);

	// Cleanup various blocks where we can afford a blank line
	global $BLOCK_TAGS;
	foreach (array_keys($BLOCK_TAGS) as $tag)
	{
		if (strpos($semihtml,'['.$tag)!==false)
		{
			$semihtml=preg_replace('#( |</CDATA\_\_space>)*(\['.$tag.'[\] ])#','${2}',$semihtml);
			$semihtml=preg_replace('#\[/'.$tag.'\](?!\[/)(?!<br)#','[/'.$tag.']'.(($tag=='title')?'<ocpbr /><ocpbr />':'<ocpbr />'),$semihtml);
		}
	}

	// Remove our CDATA protections
	$semihtml=str_replace('</CDATA__space>',' ',$semihtml);
	$semihtml=str_replace('</CDATA__tab>',"\t",$semihtml);
	$semihtml=str_replace('</CDATA__nl>',"\n",$semihtml);
	$semihtml=str_replace('</CDATA__lf>',"\r",$semihtml);
	$semihtml=str_replace('</CDATA__amp>','&',$semihtml);

	// Tempcode escaping
	/*$semihtml=str_replace('{+','\{+',$semihtml);	No - people should be able to type this if they want
	$semihtml=str_replace('{$','\{$',$semihtml);
	$semihtml=str_replace('{!','\{!',$semihtml);*/

	$semihtml=str_replace('[ html','[html',$semihtml);
	$semihtml=str_replace('[ semihtml','[semihtml',$semihtml);
	$semihtml=str_replace('[ / html','[/html',$semihtml);
	$semihtml=str_replace('[ / semihtml','[/semihtml',$semihtml);

	// People without comcode_dangerous have further cleanups, that might lose some quality...
	if ((!has_privilege(get_member(),'allow_html')) || ($force))
	{
		$semihtml2=$semihtml;

		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<table summary="([^"]*)"([^>]*)>(.*)</table>$#siU',"\n{| \${2}\${3}\n|}\n");
		$array_html_preg_replace[]=array('#^<table([^>]*)>(.*)</table>$#siU',"\n{|\n\${2}\n|}\n");
		$semihtml2=array_html_preg_replace('table',$array_html_preg_replace,$semihtml2);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<thead([^>]*)>(.*)</thead>$#siU','');
		$semihtml2=array_html_preg_replace('thead',$array_html_preg_replace,$semihtml2);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<tbody([^>]*)>(.*)</tbody>$#siU','${2}');
		$semihtml2=array_html_preg_replace('tbody',$array_html_preg_replace,$semihtml2);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<tfoot([^>]*)>(.*)</tfoot>$#siU','');
		$semihtml2=array_html_preg_replace('tfoot',$array_html_preg_replace,$semihtml2);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<tr([^>]*)>(.*)</tr>$#siU',"\n|-\n\${2}");
		$semihtml2=array_html_preg_replace('tr',$array_html_preg_replace,$semihtml2);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<th([^>]*)>(.*)</th>$#siU',"\n\n! \${2}");
		$semihtml2=array_html_preg_replace('th',$array_html_preg_replace,$semihtml2);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<td([^>]*)>(.*)</td>$#siU',"\n| \${2}");
		$semihtml2=array_html_preg_replace('td',$array_html_preg_replace,$semihtml2);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<span style="font-family: monospace;  font-size: 1.2em;">(.*)</span>$#siU',"[tt]\${1}[/tt]");
		$semihtml2=array_html_preg_replace('span',$array_html_preg_replace,$semihtml2);
		if (strpos($semihtml,'[code')===false)
		{
			$array_html_preg_replace=array();
			$array_html_preg_replace[]=array('#^<pre>(.*)</pre>$#siU',"[code]\${1}[/code]");
			$semihtml2=array_html_preg_replace('pre',$array_html_preg_replace,$semihtml2);
		}
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<table([^>]*)>(.*)</table>$#siU',"<table class=\"bordered_table\">\${2}</table>");
		$semihtml=array_html_preg_replace('table',$array_html_preg_replace,$semihtml);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<tr([^>]*)>(.*)</tr>$#siU',"<tr>\${2}</tr>");
		$semihtml=array_html_preg_replace('tr',$array_html_preg_replace,$semihtml);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<th([^>]*)>(.*)</th>$#siU',"<th>\${2}</th>");
		$semihtml=array_html_preg_replace('th',$array_html_preg_replace,$semihtml);
		$array_html_preg_replace=array();
		$array_html_preg_replace[]=array('#^<td([^>]*)>(.*)</td>$#siU',"<td>\${2}</td>");
		$semihtml=array_html_preg_replace('td',$array_html_preg_replace,$semihtml);
	} else $semihtml2=$semihtml;

	// Cleanup impossible stuff in code tags
	foreach (array_keys($CODE_TAGS) as $tag)
	{
		$semihtml2=comcode_preg_replace($tag,'#^(\['.$tag.'\])([.\n]*)(\[/'.$tag.'\])$#i',array('semihtml_to_comcode_wrap'),$semihtml2);
	}

	// These can only be used outside semihtml - so we do them in a copy of our output, and only use that copy if we find we are able to do a 100% Comcode conversion
	$semihtml2=str_replace('<ocpbr />',"\n",$semihtml2);
	$semihtml2=str_replace('<br />',"\n",$semihtml2);
	$semihtml2=str_replace('<br  />',"\n",$semihtml2);
	$semihtml2=str_replace('<br>',"\n",$semihtml2);
	$semihtml2=str_replace('<hr width="100%" size="2" />','<hr />',$semihtml2);
	$semihtml2=str_replace('<hr size="2" width="100%" />','<hr />',$semihtml2);
	$semihtml2=str_replace('<hr width="100%" />','<hr />',$semihtml2);
	$semihtml2=str_replace("\n".'<hr />',"\n---------------\n",$semihtml2);
	$semihtml2=str_replace("\n".'<hr>',"\n---------------\n",$semihtml2);
	$semihtml2=preg_replace('#<hr\s*/>#',"\n---------------\n",$semihtml2);
	$semihtml2=str_replace('<hr>',"\n---------------\n",$semihtml2);

	// We transform any HTML in there to Comcode if we can
	$smilies=$GLOBALS['FORUM_DRIVER']->find_emoticons();
	foreach ($smilies as $code=>$imgcode)
	{
		if ($imgcode[0]=='EMOTICON_IMG_CODE_THEMED')
		{
			$imgcode[1]=find_theme_image($imgcode[1],true);
			if ($imgcode[1]=='') continue; // Theme image gone missing
		}
		$imgcode[1]=str_replace(get_base_url(),'',$imgcode[1]);

		$semihtml2=preg_replace('#<img [^>]*src="[^"]*'.preg_quote(escape_html($imgcode[1]),'#').'"[^>]*>\s*#si',$code,$semihtml2);
	}

	$semihtml2=preg_replace_callback('#<img([^>]*) src="([^"]*)"([^>]*) />#siU','_img_tag_fixup',$semihtml2);
	$semihtml2=preg_replace_callback('#<img([^>]*) src="([^"]*)"([^>]*)>#siU','_img_tag_fixup',$semihtml2);

	// Then, if there is no HTML left, we can avoid the 'semihtml' tag
	if (strpos($semihtml2,'<')===false)
	{
//		$semihtml2=str_replace(array('&lt;','&gt;','&amp;'),array('___lt___','___gt___','___amp___'),$semihtml2);
		$semihtml2=@html_entity_decode($semihtml2,ENT_QUOTES,get_charset());
//		$semihtml2=str_replace(array('___lt___','___gt___','___amp___'),array('&lt;','&gt;','&amp;'),$semihtml2);
		return $semihtml2;
	}

	// Oh well, we couldn't do a perfect conversion, so we'll have to use semihtml.

	$semihtml=preg_replace_callback('#<img([^>]*) src="([^"]*)"([^>]*) />#siU','_img_tag_fixup',$semihtml);
	$semihtml=preg_replace_callback('#<img([^>]*) src="([^"]*)"([^>]*)>#siU','_img_tag_fixup',$semihtml);

	$semihtml=str_replace('<ocpbr />',"\n",$semihtml);

	// Make it look slightly reasonable first (to the reader of the Comcode)
	$semihtml=str_replace('<br  />','<br />',$semihtml);
	$semihtml=str_replace('<br />','<br />'."\n",$semihtml);
	$semihtml=str_replace('</p>','</p>'."\n",$semihtml);
	$semihtml=str_replace('[/align]','[/align]'."\n",$semihtml);

	return '[semihtml]'./*apply_emoticons can cause problems inside Comcode tags*/($semihtml).'[/semihtml]';
}

/**
 * preg_replace callback to strip HTML tags from inside a Comcode tag, except formatting ones that we'll convert to white-space.
 *
 * @param  array			Matches
 * @return string			Result
 */
function comcode_strip_html_tags($matches)
{
	return $matches[1].strip_tags($matches[2],'<p><br><div><CDATA__space><CDATA__tab><CDATA__nl><CDATA__lf><CDATA__amp>').$matches[3];
}

/**
 * Do a regular expression match, locked correctly to single Comcode elements. This is necessary to make sure nesting is handled correctly, which regular expressions cannot do on their own.
 * This is a good test case:
 * exit(comcode_preg_replace('test','#\[test\](.*)\[/test\]#','>${1}<','[test]x[test a]y[/test]z[/test]'));
 *
 * @param  string			The element name to replace over
 * @param  string			Pattern
 * @param  mixed			Replacement (string or single element array specifying a function name)
 * @param  string			Haystack
 * @return string			Result
 */
function comcode_preg_replace($element,$pattern,$replacement,$semihtml)
{
	$old_semihtml='';
	do
	{
		$old_semihtml=$semihtml;

		$matches=array();
		$count=preg_match_all('#\['.$element.'[\s\]]#',$semihtml,$matches,PREG_OFFSET_CAPTURE);
		$starts=array();
		for ($i=0;$i<$count;$i++)
		{
			$starts[]=$matches[0][$i][1];
		}
		$count=preg_match_all('#\[/'.$element.'[\s\]]#',$semihtml,$matches,PREG_OFFSET_CAPTURE);
		$ends=array();
		$lengths=array();
		for ($i=0;$i<$count;$i++)
		{
			$ends[]=$matches[0][$i][1];
			$lengths[]=strlen($matches[0][$i][0]);
		}
		foreach ($starts as $start)
		{
			foreach ($ends as $i=>$end)
			{
				if ($end<$start) continue;
				$segment=substr($semihtml,$start,$end+$lengths[$i]-$start);
				if (substr_count($segment,'['.$element.' ')+substr_count($segment,'['.$element.']')==substr_count($segment,'[/'.$element.']'))
				{
					$before=substr($semihtml,0,$start);
					$after=substr($semihtml,$end+$lengths[$i]);
					if (is_array($replacement))
					{
						$subbed=preg_replace_callback($pattern,$replacement[0],$segment);
					} else
					{
						$subbed=preg_replace($pattern,$replacement,$segment);
					}
					$semihtml=$before.$subbed.$after;

					if ($semihtml!=$old_semihtml) break 2;
					break; // Ok, well at least we know we found our tag bound, so no more need to search
				}
			}
		}
	}
	while ($semihtml!=$old_semihtml);

	return $semihtml;
}

/**
 * Do some regular expression matches, locked correctly to single HTML elements. This is necessary to make sure nesting is handled correctly, which regular expressions cannot do on their own.
 *
 * @param  string			The element name to replace over
 * @param  array			A list of pairs: Pattern, Replacement
 * @param  string			Haystack
 * @return string			Result
 */
function array_html_preg_replace($element,$array,$semihtml)
{
	$old_semihtml='';
	do
	{
		$old_semihtml=$semihtml;

		$matches=array();
		$count=preg_match_all('#<'.$element.'[\s>]#',$semihtml,$matches,PREG_OFFSET_CAPTURE);
		$starts=array();
		for ($i=0;$i<$count;$i++)
		{
			$starts[]=$matches[0][$i][1];
		}
		$count=preg_match_all('#</'.$element.'[\s>]#',$semihtml,$matches,PREG_OFFSET_CAPTURE);
		$ends=array();
		$lengths=array();
		for ($i=0;$i<$count;$i++)
		{
			$ends[]=$matches[0][$i][1];
			$lengths[]=strlen($matches[0][$i][0]);
		}
		$s_opens=array();
		$s_closes=array();
		foreach ($array as $index=>$temp)
		{
			list($pattern,$replacement)=$temp;
			foreach ($starts as $start)
			{
				foreach ($ends as $i=>$end)
				{
					if ($end<$start) continue;
					$opens=@$s_opens[$start][$end];
					$closes=@$s_closes[$start][$end];
					if (is_null($opens))
					{
						$segment=substr($semihtml,$start,$end+$lengths[$i]-$start);
						$opens=substr_count($segment,'<'.$element.' ')+substr_count($segment,'<'.$element.'>');
						$closes=substr_count($segment,'</'.$element.'>');
						$s_opens[$start][$end]=$opens;
						$s_closes[$start][$end]=$closes;
					} else $segment=NULL;
					if ($opens==$closes)
					{
						if (is_null($segment))
						{
							$segment=substr($semihtml,$start,$end+$lengths[$i]-$start);
						}
						$before=substr($semihtml,0,$start);
						$after=substr($semihtml,$end+$lengths[$i]);
						$subbed=preg_replace($pattern.'A',$replacement,$segment);
						$semihtml=$before.$subbed.$after;
						if ($semihtml!=$old_semihtml) break 3;
						break; // Ok, well at least we know we found our tag bound, so no more need to search
					}
				}
			}
			unset($array[$index]); // If we are going to recurse, we don't want extra work -- let's record that this one completed
		}
	}
	while ($semihtml!=$old_semihtml);

	return $semihtml;
}

