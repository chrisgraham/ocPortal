<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2012

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core
 */

class filecache
{
	/**
	 * (Plug-in replacement for memcache API) Get data from the persistant cache.
	 *
	 * @param  mixed			Key
	 * @param  ?TIME			Minimum timestamp that entries from the cache may hold (NULL: don't care)
	 * @return ?mixed			The data (NULL: not found / NULL entry)
	 */
	function get($key,$min_cache_date=NULL)
	{
		$myfile=@fopen(get_custom_file_base().'/persistant_cache/'.md5($key).'.gcd','rb');
		if ($myfile===false) return NULL;
		if (!is_null($min_cache_date)) // Code runs here as we know file exists at this point
		{
			if (filemtime(get_custom_file_base().'/persistant_cache/'.md5($key).'.gcd')<$min_cache_date)
			{
				fclose($myfile);
				return NULL;
			}
		}
		if (function_exists('usleep'))
		{
			$its=0; // if we can't get after 10 iterations then we have to assume the OS does not support locks :(
			if (!defined('PHALANGER'))
			{
				while ((!@flock($myfile,LOCK_SH)) && ($its!=10))
				{
					usleep(mt_rand(0,100)*1000); // Won't work on Windows for PHP4, but we wouldn't use this on that anyway
					$its++;
				}
			}
		}
		$contents='';
		while (!feof($myfile)) $contents.=fread($myfile,1024);

		$ret=@unserialize($contents);
		if (function_exists('usleep'))
		{
			if (($ret===false) || ($contents=='')) // Hmm, maybe still some kind of locking problem, so delay and try again
			{
				rewind($myfile);
				usleep(500*1000); // Won't work on Windows for PHP4, but we wouldn't use this on that anyway
				$contents='';
				while (!feof($myfile)) $contents.=fread($myfile,1024);
			}
		}

		fclose($myfile);

		return $ret;
	}

	/**
	 * (Plug-in replacement for memcache API) Put data into the persistant cache.
	 *
	 * @param  mixed			Key
	 * @param  mixed			The data
	 * @param  integer		Various flags (parameter not used)
	 * @param  integer		The expiration time in seconds.
	 */
	function set($key,$data,$flags,$expire_secs)
	{
		unset($flags);
		unset($expire_secs);

		$path=get_custom_file_base().'/persistant_cache/'.md5($key).'.gcd';
		$myfile=@fopen($path,'ab');
		if ($myfile===false) return; // Failure

		$to_write=serialize($data);

		$its=0; // if we can't get after 10 iterations then we have to assume the OS does not support locks :(
		if (!defined('PHALANGER'))
		{
			while ((!@flock($myfile,LOCK_EX)) && ($its!=10))
			{
				sleep(mt_rand(0,100));
				$its++;
			}
		}
		ftruncate($myfile,0);
		if (fwrite($myfile,$to_write)!==false)
		{
			// Success
			fclose($myfile);
			fix_permissions($path);
		} else
		{
			// Failure
			fclose($myfile);
			unlink($path);
		}
	}

	/**
	 * (Plug-in replacement for memcache API) Delete data from the persistant cache.
	 *
	 * @param  mixed			Key name
	 */
	function delete($key)
	{
		// Ideally we'd lock whilst we delete, but it's not stable (and the workaround would be too slow for our efficiency context). So some people reading may get errors whilst we're clearing the cache. Fortunately this is a rare op to perform.
		@unlink(get_custom_file_base().'/persistant_cache/'.md5($key).'.gcd');
	}

	/**
	 * (Plug-in replacement for memcache API) Remove all data from the persistant cache.
	 */
	function flush()
	{
		$d=opendir(get_custom_file_base().'/persistant_cache');
		while (($e=readdir($d))!==false)
		{
			if (substr($e,-4)=='.gcd')
			{
				// Ideally we'd lock whilst we delete, but it's not stable (and the workaround would be too slow for our efficiency context). So some people reading may get errors whilst we're clearing the cache. Fortunately this is a rare op to perform.
				@unlink(get_custom_file_base().'/persistant_cache/'.$e);
			}
		}
		closedir($d);
	}
}
