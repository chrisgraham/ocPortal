<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2012

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		devguide
 */

/*

This file should never be included.
It serves to *specify* the subset of PHP that ocPortal is written to. We define a limited subset so we can verify we write to multiple versions of PHP.
The code quality checker automatically parses and uses this file, to build up the validity API.

*/

/**
 * Generate a stack trace.
 *
 * @return array	Stack trace.
 */
function debug_backtrace()
{
	return array();
}

/**
 * Absolute value.
 *
 * @param  mixed	The number to get the absolute value of.
 * @return mixed	The absolute value of number.
 */
function abs($number)
{
	return 0;
}

/**
 * Counts all the values of an array.
 *
 * @param  array	Input array.
 * @return array	An array using the values of the input array as keys and their frequency in input as values.
 */
function array_count_values($input)
{
	return array();
}

/**
 * Calculate the difference between arrays.
 *
 * @param  array	First array.
 * @param  array	Second array.
 * @param  ?array	Third array (NULL: only 2).
 * @return array	The difference.
 */
function array_diff($array1,$array2,$array3=NULL)
{
	return array();
}

/**
 * Exchanges all keys with their associated values in an array.
 *
 * @param  array	Array to flip.
 * @return array	An array in flip order.
 */
function array_flip($trans)
{
	return array();
}

/**
 * Checks if the given key or index exists in the array.
 *
 * @param  mixed		Key.
 * @param  array		Search array.
 * @return boolean	Whether the key is set in the search array.
 */
function array_key_exists($key,$search)
{
	return false;
}

/**
 * Return all the keys of an array.
 *
 * @param  array	Input array.
 * @param  ?mixed	Only find keys with this value (NULL: no such filter).
 * @return array	The keys of the array.
 */
function array_keys($input,$search_value=NULL)
{
	return array();
}

/**
 * Calculate the intersection between arrays.
 *
 * @param  array	First array.
 * @param  array	Second array.
 * @param  ?array	Third array (NULL: only 2).
 * @return array	The intersection.
 */
function array_intersect($array1,$array2,$array3=NULL)
{
	return array();
}

/**
 * Merge two or more arrays.
 *
 * @param  array	First array.
 * @param  array	Second array.
 * @param  ?array	Third array (NULL: only 2).
 * @param  ?array	Fourth array to merge (NULL: not this one).
 * @param  ?array	Fifth array to merge (NULL: not this one).
 * @return array	Merged array.
 */
function array_merge($array1,$array2,$array3=NULL,$array4=NULL,$array5=NULL)
{
	return array();
}

/**
 * Pop the element off the end of array.
 *
 * @param  array	The array.
 * @return ?mixed	The value (NULL: no value).
 */
function array_pop(&$array)
{
	return 0;
}

/**
 * Push one or more elements onto the end of array.
 *
 * @param  array		The array.
 * @param  mixed		The value.
 * @return integer	The new number of elements in the array.
 */
function array_push(&$array,$var)
{
	return 0;
}

/**
 * Return an array with elements in reverse order.
 *
 * @param  array		The array to reverse.
 * @param  boolean	Whether to preserve keys.
 * @return array		The reversed array.
 */
function array_reverse($array,$preserve_keys=false)
{
	return array();
}

/**
 * Searches the array for a given value and returns the corresponding key if successful.
 *
 * @param  mixed	Needle.
 * @param  array	Haystack.
 * @return mixed	The key (false: not found).
 */
function array_search($needle,$haystack)
{
	return 0;
}

/**
 * Shift an element off the beginning of array.
 *
 * @param  array	The array.
 * @return ?mixed	Shifted element (NULL: empty array given).
 */
function array_shift(&$array)
{
	return '';
}

/**
 * Extract a slice of the array.
 *
 * @param  array		The array.
 * @param  integer	The offset.
 * @param  ?integer  The length (NULL: up to the end of the array).
 * @return array		The slice.
 */
function array_slice($array,$offset,$length=NULL)
{
	return array();
}

/**
 * Remove a portion of the array and replace it with something else.
 *
 * @param  array		The array.
 * @param  integer	The offset.
 * @param  ?integer  The length (NULL: up to the end of the array).
 * @param  ?array		The replacement (NULL: nothing put in, just bit taken out).
 * @return array		The spliced result.
 */
function array_splice($input,$offset,$length=NULL,$replacement=NULL)
{
	return array();
}

/**
 * Removes duplicate values from an array. Equivalence determined by string comparison.
 *
 * @param  array	Input array.
 * @return array	Output array.
 */
function array_unique($array)
{
	return array();
}

/**
 * Return all the values of an array.
 *
 * @param  array	Input array.
 * @return array	Output array.
 */
function array_values($array)
{
	return array();
}

/**
 * Sort an array in reverse order and maintain index association.
 *
 * @param  array		Array.
 * @param  integer	Sort flags.
 */
function arsort(&$array,$sort_flags=0)
{
}

/**
 * Sort an array and maintain index association.
 *
 * @param  array		Array.
 * @param  integer	Sort flags.
 */
function asort(&$array,$sort_flags=0)
{
}

/**
 * Decodes data encoded with MIME base64.
 *
 * @param  string		Encoded data.
 * @return ~string	Decoded data (false: error).
 */
function base64_decode($encoded_data)
{
	return '';
}

/**
 * Encodes data with MIME base64.
 *
 * @param  string	Data.
 * @return string	Encoded data.
 */
function base64_encode($data)
{
	return '';
}

/**
 * Call a user function given by the first parameter.
 *
 * @param  mixed	Function callback.
 * @param  ?mixed	Optional parameter (NULL: none).
 * @param  ?mixed	Optional parameter (NULL: none).
 * @param  ?mixed	Optional parameter (NULL: none).
 * @param  ?mixed	Optional parameter (NULL: none).
 * @return mixed	Whatever the function returns.
 */
function call_user_func($function,$param_a=NULL,$param_b=NULL,$param_c=NULL,$param_d=NULL)
{
	return 0;
}

/**
 * Round fractions up.
 *
 * @param  float	Value to round up.
 * @return float	Rounded value.
 */
function ceil($function)
{
	return 0.0;
}

/**
 * Change directory.
 *
 * @param  PATH		Path to change to.
 * @return boolean	Success status.
 */
function chdir($directory)
{
	return false;
}

/**
 * Validate a gregorian date.
 *
 * @param  integer	The month.
 * @param  integer	The day.
 * @param  integer	The year.
 * @return boolean	Whether the date is valid.
 */
function checkdate($month,$day,$year)
{
	return false;
}

/**
 * Changes file mode.
 *
 * @param  PATH		The file to change the mode of.
 * @param  integer	The mode (e.g. 0777).
 * @return boolean	Success status.
 */
function chmod($filename,$mode)
{
	return false;
}

/**
 * Return a specific character.
 *
 * @param  integer	The ASCII code for the character required.
 * @return string		A string of length 1, where the first character is as requested.
 */
function chr($ascii)
{
	return '';
}

/**
 * Split a string into smaller chunks. Can be used to split a string into smaller chunks which is useful for e.g. converting base64_encode output to match RFC 2045 semantics. It inserts end (defaults to "\r\n") every chunklen characters.
 *
 * @param  string		The input string.
 * @param  integer	The maximum chunking length.
 * @param  string		Split character.
 * @return string		The chunked version of the input string.
 */
function chunk_split($body,$chunklen=76,$splitter="\r\n")
{
	return '';
}

/**
 * Checks if the class has been defined.
 *
 * @param  string		The class identifier.
 * @return boolean	Whether the class has been defined.
 */
function class_exists($class_name)
{
	return false;
}

/**
 * Clears file status cache.
 */
function clearstatcache()
{
}

/**
 * Close directory handle.
 *
 * @param  resource  The directory handle to close.
 */
function closedir($handle)
{
}

/**
 * Returns the value of a constant.
 *
 * @param  string	The name of the constant.
 * @return mixed	The value of the constant.
 */
function constant($name)
{
	return '';
}

/**
 * Copies a file. {{creates-file}}
 *
 * @param  PATH		The source path.
 * @param  PATH		The destination path.
 * @return boolean	Success status.
 */
function copy($source,$dest)
{
	return false;
}

/**
 * Calculate the cosine of an angle.
 *
 * @param  float	The angle in radians.
 * @return float	The cosine.
 */
function cos($angle)
{
	return 0.0;
}

/**
 * Count elements in a variable.
 *
 * @param  array		Variable to count elements of.
 * @return integer	The count.
 */
function count($var)
{
	return 0;
}

/**
 * One-way string hashing (not encryption, as not reversible).
 *
 * @param  string		The string to hash.
 * @param  ?string	The salt (NULL: generate a random salt).
 * @return string		The hash. The start of the hash determines parameters (encoding, salt).
 */
function crypt($string,$salt=NULL)
{
	return '';
}

/**
 * Return the current element in an array.
 *
 * @param  array	The array.
 * @return mixed	The current element.
 */
function current($array)
{
	return 0;
}

/**
 * Format a local time/date.
 *
 * @param  string	The format string.
 * @param  ?TIME	The timestamp (NULL: current time).
 * @return string	The string representation of the local time/date.
 */
function date($format,$timestamp=NULL)
{
	return '';
}

/**
 * Open a connection to a database Server.
 *
 * @param  string			Database type.
 * @param  string			The server hostname/IP.
 * @param  string			Database name.
 * @param  string			The username to connect with.
 * @param  string			The password to connect with.
 * @param  BINARY			Whether to use a persitent connection.
 * @return ~object	 	The connection (false: error)
 */
function dbx_connect($module,$server,$database,$username,$password,$persistent=0)
{
	return false;
}

/**
 * Escapes a string for use in a dbx_query.
 *
 * @param  object	The connection we're escaping for.
 * @param  string	Unescaped string.
 * @return string	Escaped string.
 */
function dbx_escape_string($connection,$unescaped_string)
{
	return '';
}

/**
 * Send a database query.
 *
 * @param  object		The connection we're querying over.
 * @param  string		The query.
 * @param  integer	OR'd Flags (DBX_RESULT_INDEX, DBX_RESULT_INFO, DBX_RESULT_ASSOC).
 * @return ~resource The result identifier (false: error).
 */
function dbx_query($connection,$query,$flags=0)
{
	return array();
}

/**
 * Integer to string representation of hexadecimal.
 *
 * @param  integer	The integer ('decimal' form, although truly stored in binary).
 * @return string		The string representation.
 */
function dechex($number)
{
	return '';
}

/**
 * Integer to string representation of octal.
 *
 * @param  integer	The integer ('decimal' form, although truly stored in binary).
 * @return string		The string representation.
 */
function decoct($number)
{
	return '';
}

/**
 * Defines a named constant.
 *
 * @param  string		Identifier.
 * @param  mixed		Value.
 * @return boolean	Success status.
 */
function define($name,$value)
{
	return false;
}

/**
 * Checks whether a given named constant exists.
 *
 * @param  string		The identifier of a constant.
 * @return boolean	Whether the constant exists.
 */
function defined($name)
{
	return false;
}

/**
 * Returns directory name component of path.
 *
 * @param  PATH		The path.
 * @return PATH		The directory name component.
 */
function dirname($name)
{
	return '';
}

/**
 * Returns the amount of free space under a directory in a unix-style mount/quota-supporting filesystem.
 *
 * @param  PATH		The path.
 * @return ~integer  The amount of space (technically a float, but integer is more conveniant). (false: error)
 */
function disk_free_space($directory)
{
	return 0;
}

/**
 * Converts the number in degrees to the radian equivalent.
 *
 * @param  float	Angle in degrees.
 * @return float	Angle in radians.
 */
function deg2rad($number)
{
	return 0.0;
}

/**
 * Send an error message somewhere.
 *
 * @param  string		The message to log.
 * @param  integer	The message type (0 is normal PHP logging system, 1 is e-mail address [non-Roadsend], 2 is debugger connection, 3 is file)
 * @set    0 1 2 3
 * @param  string		The parameter that defines details of the message type (for type 0, meaningless).
 * @return boolean	Success status.
 */
function error_log($message,$message_type=0,$destination='')
{
	return true;
}

/**
 * Sets which PHP errors are reported.
 *
 * @param  ?integer  OR'd combination of error type constants. (E_ERROR, E_WARNING,  E_PARSE, E_NOTICE, E_CORE_ERROR, E_CORE_WARNING, E_COMPILE_ERROR, E_COMPILE_WARNING, E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE, E_ALL) (NULL: find current level)
 * @return integer	Current error reporting level
 */
function error_reporting($level=NULL)
{
	return 0;
}

/**
 * Output a message and terminate the current script.
 *
 * @param  string	The message.
 */
function exit($message='')
{
}

/**
 * Split a string by string.
 *
 * @param  string		The separator.
 * @param  string		The string to split.
 * @param  ?integer  The maximum number of splits (the last element containing the remainder) (NULL: no limit).
 * @return array		The split list.
 */
function explode($separator,$string,$limit=NULL)
{
	return array();
}

/**
 * Closes an open file pointer.
 *
 * @param  resource  The file pointer.
 * @return boolean	Success status.
 */
function fclose($handle)
{
	return false;
}

/**
 * Tests for end-of-file on a file pointer.
 *
 * @param  resource  The file pointer.
 * @return boolean	Whether the end of the file has been reached.
 */
function feof($handle)
{
	return false;
}

/**
 * Gets line from file pointer.
 *
 * @param  resource  The file pointer.
 * @param  integer	The maximum length of the line.
 * @return string		The string read.
 */
function fgets($handle,$length)
{
	return '';
}

/**
 * Reads entire file into an array.
 *
 * @param  PATH	The file name.
 * @return ~array	The array (each line being an entry in the array, and newlines still attached). (false: error)
 */
function file($filename)
{
	return array();
}

/**
 * Checks whether a file or directory exists.
 *
 * @param  PATH		The path.
 * @return boolean	Whether it exists.
 */
function file_exists($filename)
{
	return false;
}

/**
 * Gets inode change time of file.
 *
 * @param  PATH		The filename.
 * @return ~TIME		Timestamp of creation (negativity is blasphemy) (false: error).
 */
function filectime($filename)
{
	return 0;
}

/**
 * Gets file group.
 *
 * @param  PATH		The filename.
 * @return ~integer  The posix group ID (false: error).
 */
function filegroup($filename)
{
	return 0;
}

/**
 * Gets file modification time.
 *
 * @param  PATH		The filename.
 * @return ~TIME		Timestamp of modification (false: error).
 */
function filemtime($filename)
{
	return 0;
}

/**
 * Gets file owner.
 *
 * @param  PATH		The filename.
 * @return ~integer  The posix user ID (false: error).
 */
function fileowner($filename)
{
	return 0;
}

/**
 * Gets file permissions.
 *
 * @param  PATH		The filename.
 * @return ~integer  The permissions (e.g. 0777) (false: error).
 */
function fileperms($filename)
{
	return 0;
}

/**
 * Gets file size.
 *
 * @param  PATH		The filename.
 * @return ~integer  The file size (false: error).
 */
function filesize($filename)
{
	return 0;
}

/**
 * Get float value of a variable.
 *
 * @param  mixed	The input.
 * @return float	The float value.
 */
function floatval($var)
{
	return 0.0;
}

/**
 * Round fractions down.
 *
 * @param  float	The input.
 * @return float	The rounded value.
 */
function floor($value)
{
	return 0.0;
}

/**
 * Get an array of all defined variables.
 *
 * @return array	All defined variables.
 */
function get_defined_vars()
{
	return array();
}

/**
 * Get an array of all declared classes.
 *
 * @return array	All declared classes.
 */
function get_declared_classes()
{
	return array();
}

/**
 * Get an array of all defined functions.
 *
 * @return array	All defined functions.
 */
function get_defined_functions()
{
	return array();
}

/**
 * Opens file or URL. {{creates-file}}
 *
 * @param  PATH		Filename.
 * @param  string		Mode (e.g. at).
 * @return ~resource The file handle (false: could not be opened).
 */
function fopen($filename,$mode)
{
	return array();
}

/**
 * Output all remaining data on a file pointer.
 *
 * @param  resource  The file handle.
 * @return ~integer  The number of characters that got read (false: error).
 */
function fpassthru($handle)
{
	return 0;
}

/**
 * Binary-safe file read.
 *
 * @param  resource  The file handle.
 * @param  integer	Maximum length to read.
 * @return string		The read data.
 */
function fread($handle,$length)
{
	return '';
}

/**
 * Seeks on a file pointer.
 *
 * @param  resource  The file handle.
 * @param  integer	The offset (meaning depends on whence).
 * @param  integer	SEEK_SET, SEEK_CUR or SEEK_END.
 * @return integer	Success status (-1 means error).
 */
function fseek($handle,$offset,$whence=SEEK_SET)
{
	return 0;
}

/**
 * Open Internet or Unix domain socket connection.
 *
 * @param  string		The target domain/IP to open.
 * @param  integer	The target port to open.
 * @param  integer	Where any error number will be put.
 * @param  string		Whether any error string will be put.
 * @param  ?float		How long to wait until timeout (NULL: no timeout).
 * @return ~resource The handle (false: error).
 */
function fsockopen($target,$port,&$errno,&$errstr,$timeout=NULL)
{
	return array();
}

/**
 * Gets file pointer read/write position.
 *
 * @param  resource  The file handle.
 * @return ~integer  The offset (false: error)
 */
function ftell($handle)
{
	return 0;
}

/**
 * Changes directories on a FTP server.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		The directory to change to.
 * @return boolean	Success status.
 */
function ftp_chdir($ftp_stream,$dir)
{
	return false;
}

/**
 * Close an FTP connection.
 *
 * @param  resource  The FTP connection.
 * @return boolean	Success status.
 */
function ftp_close($ftp_stream)
{
	return false;
}

/**
 * Make an FTP connection.
 *
 * @param  string		The FTP server to connect to.
 * @param  integer	The port on the FTP server that holds the FTP server application.
 * @param  integer	The timeout after which we give up with an error.
 * @return ~resource The FTP connection (false: error).
 */
function ftp_connect($host,$port=21,$timeout=90)
{
	return array();
}

/**
 * Deletes a file on the FTP server.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		The filename.
 * @return boolean	Success status.
 */
function ftp_delete($ftp_stream,$filename)
{
	return false;
}

/**
 * Uploads from an open file to the FTP server.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		The remote filename.
 * @param  resource  The open file handle.
 * @param  integer	The file mode for the remote file (e.g. 0777).
 * @return boolean	Success status.
 */
function ftp_fput($ftp_stream,$remote_file,$handle,$mode)
{
	return false;
}

/**
 * Logs in to an FTP connection.
 *
 * @param  resource  The FTP connection.
 * @param  string		The username.
 * @param  string		The password.
 * @return boolean	Success status.
 */
function ftp_login($ftp_stream,$username,$password)
{
	return false;
}

/**
 * Creates a directory.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		The directory to create.
 * @return ~string	The directory name (false: error).
 */
function ftp_mkdir($ftp_stream,$directory)
{
	return '';
}

/**
 * Returns a list of files in the given directory.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		The directory.
 * @return ~array	 	The list of files (false: error).
 */
function ftp_nlist($ftp_stream,$directory)
{
	return array();
}

/**
 * Uploads a file to the FTP server.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		The remote filename.
 * @param  PATH		The local filename.
 * @param  integer	The file mode for the remote file (e.g. 0777).
 * @return boolean	Success status.
 */
function ftp_put($ftp_stream,$remote_file,$local_file,$mode)
{
	return false;
}

/**
 * Renames a file on the FTP server.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		Original path.
 * @param  PATH		New path.
 * @return boolean	Success status.
 */
function ftp_rename($ftp_stream,$from,$to)
{
	return false;
}

/**
 * Removes a directory on the FTP server.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		The directory to remove.
 * @return boolean	Success status.
 */
function ftp_rmdir($ftp_stream,$directory)
{
	return false;
}

/**
 * Sends a SITE command to the FTP server.
 *
 * @param  resource  The FTP connection.
 * @param  string		The SITE command.
 * @return boolean	Success status.
 */
function ftp_site($ftp_stream,$cmd)
{
	return false;
}

/**
 * Find the file size of a file on the FTP server.
 *
 * @param  resource  The FTP connection.
 * @param  PATH		The file's path.
 * @return ~integer  The file size (false: error).
 */
function ftp_size($ftp_stream,$cmd)
{
	return 0;
}

/**
 * Find whether the function of the given function name has been defined.
 *
 * @param  string		The name of the function.
 * @return boolean	Whether it is defined.
 */
function function_exists($function_name)
{
	return false;
}

/**
 * Binary-safe file write.
 *
 * @param  resource  The file handle.
 * @param  string		The string to write to the file.
 * @param  ?integer  The length of data to write (NULL: all of $string).
 * @return ~integer  The number of bytes written (false: error).
 */
function fwrite($handle,$string,$length=NULL)
{
	return 0;
}

/**
 * Retrieve information about the currently installed GD library.
 *
 * @return array	Array of information.
 */
function gd_info()
{
	return array();
}

/**
 * Returns the name of the class of an object.
 *
 * @param  object	The object.
 * @return string	The class name.
 */
function get_class($obj)
{
	return '';
}

/**
 * Returns the translation table used by htmlspecialchars and htmlentities.
 *
 * @param  integer	The table to select (HTML_ENTITIES or HTML_SPECIALCHARS).
 * @param  integer	The quote style (ENT_QUOTES or ENT_NOQUOTES or ENT_COMPAT).
 * @return array		The translation table.
 */
function get_html_translation_table($table,$quote_style=ENT_COMPAT)
{
	return array();
}

/**
 * Gets the current active configuration setting of magic quotes gpc. (Note: it actually returns a BINARY, but lets make it cleaner, it won't hurt)
 *
 * @return boolean	Whether magic quotes gpc is on.
 */
function get_magic_quotes_gpc()
{
	return false;
}

/**
 * Gets the current working directory.
 *
 * @return PATH		The cwd.
 */
function getcwd()
{
	return '';
}

/**
 * Get date/time information.
 *
 * @param  ?TIME	Timestamp to get information for (NULL: now).
 * @return array	The information.
 */
function getdate($timestamp=NULL)
{
	return array();
}

/**
 * Gets the value of an environment variable.
 *
 * @param  string		The environment name to get (e.g. PATH).
 * @return ~string	The value (false: error).
 */
function getenv($string)
{
	return '';
}

/**
 * Format a GMT/UTC date/time (uses different format to 'date' function).
 *
 * @param  string	The 'gm' format string.
 * @param  ?TIME	Timestamp to use (NULL: now).
 * @return string	The formatted string.
 */
function gmdate($format,$timestamp=NULL)
{
	return '';
}

/**
 * Close an open gz-file pointer.
 *
 * @param  resource  The handle.
 * @return boolean	Success status.
 */
function gzclose($handle)
{
	return false;
}

/**
 * Open gz-file. {{creates-file}}
 *
 * @param  PATH		The filename.
 * @param  string		The mode (e.g. b).
 * @return ~resource The handle (false: error).
 */
function gzopen($filename,$mode)
{
	return array();
}

/**
 * Binary-safe gz-file write.
 *
 * @param  resource  The file handle.
 * @param  string		The string to write to the file.
 * @param  ?integer  The length of data to write (NULL: full length of input string).
 * @return ~integer  The number of bytes written (false: error).
 */
function gzwrite($handle,$string,$length=NULL)
{
	return 0;
}

/**
 * Send a raw HTTP header.
 *
 * @param  string		The header to send.
 * @param  boolean	Whether to replace a previous call to set the same header (if you choose to not replace, it will send two different values for the same header).
 */
function header($string,$replace_last=true)
{
}

/**
 * Checks if or where headers have been sent.
 *
 * @return boolean	The answer.
 */
function headers_sent()
{
	return false;
}

/**
 * String representation of hexadecimal to decimal.
 *
 * @param  string		The string representation.
 * @return integer	The integer ('decimal' form, although truly stored in binary).
 */
function hexdec($hex_string)
{
	return 0;
}

/*!ROADSEND*
 * Syntax highlighting of a string (output directly).
 *
 * @param  string	The string to highlight.
 */
/*function highlight_string($str)
{
}*/

/**
 * Convert all applicable characters to HTML entities.
 *
 * @param  string		The string to encode.
 * @param  integer	The quote style (ENT_COMPAT, ENT_QUOTES, ENT_NOQUOTES).
 * @param  string		The character set to use.
 * @return string		The encoded string.
 */
function htmlentities($string,$quote_style=ENT_COMPAT,$charset='')
{
	return '';
}

/**
 * Set the blending mode for an image.
 *
 * @param  resource  The image handle.
 * @param  boolean	Whether to alpha blend.
 * @return boolean	Success status.
 */
function imagealphablending($image,$blendmode)
{
	return true;
}

/**
 * Allocate a color for an image.
 *
 * @param  resource  The image handle.
 * @param  integer	Red component (0-255).
 * @param  integer	Green component (0-255).
 * @param  integer	Blue component (0-255).
 * @return integer	Combined colour identifier.
 */
function imagecolorallocate($image,$red,$green,$blue)
{
	return 0;
}

/**
 * Define a color as transparent.
 *
 * @param  resource  The image handle.
 * @param  ?integer  Transparency colour identifier (NULL: get it, don't set it).
 * @return integer	Transparency colour identifier.
 */
function imagecolortransparent($image,$color=NULL)
{
	return 0;
}

/**
 * Copy part of an image.
 *
 * @param  resource  Destination image handle.
 * @param  resource  Source image handle.
 * @param  integer	Destination X-ordinate.
 * @param  integer	Destination Y-ordinate.
 * @param  integer	Source X-ordinate.
 * @param  integer	Source Y-ordinate.
 * @param  integer	Width to copy.
 * @param  integer	Height to copy.
 */
function imagecopy($dst_im,$src_im,$dst_x,$dst_y,$src_x,$src_y,$src_w,$src_h)
{
}

/**
 * Copy and resize part of an image with resampling.
 *
 * @param  resource  Destination image handle.
 * @param  resource  Source image handle.
 * @param  integer	Destination X-ordinate.
 * @param  integer	Destination Y-ordinate.
 * @param  integer	Source X-ordinate.
 * @param  integer	Source Y-ordinate.
 * @param  integer	Destination width.
 * @param  integer	Destination height.
 * @param  integer	Source width.
 * @param  integer	Source height.
 * @return boolean	Success status.
 */
function imagecopyresampled($dst_im,$src_im,$dst_x,$dst_y,$src_x,$src_y,$dst_w,$dst_h,$src_w,$src_h)
{
	return true;
}

/**
 * Copy and resize part of an image.
 *
 * @param  resource  Destination image handle.
 * @param  resource  Source image handle.
 * @param  integer	Destination X-ordinate.
 * @param  integer	Destination Y-ordinate.
 * @param  integer	Source X-ordinate.
 * @param  integer	Source Y-ordinate.
 * @param  integer	Destination width.
 * @param  integer	Destination height.
 * @param  integer	Source width.
 * @param  integer	Source height.
 */
function imagecopyresized($dst_im,$src_im,$dst_x,$dst_y,$src_x,$src_y,$dst_w,$dst_h,$src_w,$src_h)
{
}

/**
 * Create a new palette based image.
 *
 * @param  integer	Width.
 * @param  integer	Height.
 * @return resource  The image handle.
 */
function imagecreate($width,$height)
{
	return array();
}

/**
 * Create a new image from the image stream in the string.
 *
 * @param  string		The image.
 * @return ~resource The image handle (false: error).
 */
function imagecreatefromstring($image)
{
	return array();
}

/**
 * Create a new image from a PNG file on disk.
 *
 * @param  PATH		The PNG file.
 * @return ~resource The image handle (false: error).
 */
function imagecreatefrompng($path)
{
	return array();
}

/**
 * Create a new image from a JPEG file on disk.
 *
 * @param  PATH		The JPEG file.
 * @return ~resource The image handle (false: error).
 */
function imagecreatefromjpeg($path)
{
	return array();
}

/**
 * Create a new true color image.
 *
 * @param  integer	Width.
 * @param  integer	Height.
 * @return resource  The image handle.
 */
function imagecreatetruecolor($x,$y)
{
	return array();
}

/**
 * Get the index of the color of a pixel.
 *
 * @param  resource  The image handle.
 * @param  integer	X ordinate.
 * @param  integer	Y ordinate.
 * @return integer	The colour.
 */
function imagecolorat($image,$x,$y)
{
	return 0;
}

/**
 * Get the colors for an index.
 *
 * @param  resource  The image handle.
 * @param  integer	The colour.
 * @return array		Map of components.
 */
function imagecolorsforindex($image,$color)
{
	return array();
}

/**
 * Destroy an image resource.
 *
 * @param  resource  The image handle.
 */
function imagedestroy($image)
{
}

/**
 * Flood fill.
 *
 * @param  resource  The image handle.
 * @param  integer	Start from X.
 * @param  integer	Start from Y.
 * @param  integer	The colour code to use.
 */
function imagefill($image,$x,$y,$colour)
{
}

/**
 * Get font height.
 *
 * @param  integer	Font code.
 * @return integer	Height.
 */
function imagefontheight($font)
{
	return 0;
}

/**
 * Get font width.
 *
 * @param  integer	Font code.
 * @return integer	Width.
 */
function imagefontwidth($font)
{
	return 0;
}

/**
 * Output image to browser or file as JPEG.
 *
 * @param  resource  The image handle.
 * @param  ?string	The filename (NULL: output to browser).
 * @param  ?integer  Quality level (NULL: default).
 * @return boolean	Success status.
 */
function imagejpeg($image,$filename=NULL,$quality=NULL)
{
	return true;
}

/**
 * Output image to browser or file as PNG.
 *
 * @param  resource  The image handle.
 * @param  ?string	The filename (NULL: output to browser).
 * @return boolean	Success status.
 */
function imagepng($image,$filename=NULL)
{
	return true;
}

/**
 * Set the flag to save full alpha channel information (as opposed to single-color transparency) when saving PNG images.
 *
 * @param  resource  The image handle.
 * @param  boolean	Whether to save alpha channel information.
 */
function imagesavealpha($image,$saveflag)
{
}

/**
 * Set a single pixel.
 *
 * @param  resource  The image handle.
 * @param  integer	X-ordinate.
 * @param  integer	Y-ordinate.
 * @param  integer	Colour code.
 */
function imagesetpixel($image,$x,$y,$color)
{
}

/**
 * Draw a string horizontally.
 *
 * @param  resource  The image handle.
 * @param  integer	Font code.
 * @param  integer	X-ordinate.
 * @param  integer	Y-ordinate.
 * @param  string		Text to draw.
 * @param  integer	Colour code.
 */
function imagestring($image,$font,$x,$y,$s,$col)
{
}

/**
 * Get image width.
 *
 * @param  resource  The image handle.
 * @return integer	The image width.
 */
function imagesx($image)
{
	return 0;
}

/**
 * Get image height.
 *
 * @param  resource  The image handle.
 * @return integer	The image height.
 */
function imagesy($image)
{
	return 0;
}

/**
 * Give the bounding box of a text using TrueType fonts.
 *
 * @param  resource  The image handle.
 * @param  integer	The loaded font.
 * @param  integer	X-ordinate.
 * @param  integer	Y-ordinate.
 * @param  string		Text to draw.
 * @param  integer	Colour code.
 */
function imagestringup($image,$font,$x,$y,$s,$col)
{
}

/**
 * Give the bounding box of a text using TrueType fonts.
 *
 * @param  float		The font size in pixels.
 * @param  float		Angle in degrees in which text will be measured.
 * @param  string		The name of the TrueType font file.
 * @param  string		The string to be measured.
 * @return ~array 	Tuple: lower-left-X, lower-left-Y, lower-right-X, lower-right-Y, upper-right-X, upper-right-Y, upper-left-X, upper-left-Y. (false: error)
 */
function imagettfbbox($size,$angle,$fontfile,$text)
{
	return array();
}

/**
 * Give the bounding box of a text using TrueType fonts.
 *
 * @param  resource  The image handle.
 * @param  float		The font size in pixels.
 * @param  float		Angle in degrees in which text will be measured.
 * @param  integer	X-ordinate.
 * @param  integer	Y-ordinate.
 * @param  integer	Colour code.
 * @param  string		The name of the TrueType font file.
 * @param  string		Text to draw.
 * @return ~array 	Tuple: lower-left-X, lower-left-Y, lower-right-X, lower-right-Y, upper-right-X, upper-right-Y, upper-left-X, upper-left-Y. (false: error)
 */
function imagettftext($handle,$size,$angle,$x,$y,$colour,$fontfile,$text)
{
	return array();
}

/**
 * Return the image types supported by this execution environment.
 *
 * @return integer	Bit field of constants: IMG_GIF | IMG_JPG | IMG_PNG | IMG_WBMP.
 */
function imagetypes()
{
	return 0;
}

/**
 * Draw a partial ellipse.
 *
 * @param  resource  The image involved.
 * @param  integer	X@top-left.
 * @param  integer	Y@top-left.
 * @param  integer	width.
 * @param  integer	height.
 * @param  integer	start degrees (0 degrees=3 o clock).
 * @param  integer	end degrees (0 degrees=3 o clock).
 * @param  integer	Colour code.
 * @return boolean	Success status.
 */
function imagearc($image,$cx,$cy,$w,$h,$s,$e,$color)
{
	return true;
}

/**
 * Draw a partial ellipse and fill it.
 *
 * @param  resource  The image involved.
 * @param  integer	X@top-left.
 * @param  integer	Y@top-left.
 * @param  integer	width.
 * @param  integer	height.
 * @param  integer	start degrees (0 degrees=3 o clock).
 * @param  integer	end degrees (0 degrees=3 o clock).
 * @param  integer	Style, bitwise of IMG_ARC_PIE, IMG_ARC_CHORD, IMG_ARC_NOFILL, IMG_ARC_EDGED.
 * @param  integer	Colour code.
 * @return boolean	Success status.
 */
function imagefilledarc($image,$cx,$cy,$w,$h,$s,$e,$color,$style)
{
	return true;
}

/**
 * Copy and merge part of an image with gray scale.
 *
 * @param  resource  Destination image handle.
 * @param  resource  Source image handle.
 * @param  integer	Destination X-ordinate.
 * @param  integer	Destination Y-ordinate.
 * @param  integer	Source X-ordinate.
 * @param  integer	Source Y-ordinate.
 * @param  integer	Width to copy.
 * @param  integer	Height to copy.
 * @param  integer	Opacity value.
 */
function imagecopymergegray($dst_im,$src_im,$dst_x,$dst_y,$src_x,$src_y,$src_w,$src_h,$pct)
{
}

/**
 * Draw a line.
 *
 * @param  resource  The image involved.
 * @param  integer	Start-X.
 * @param  integer	Start-Y.
 * @param  integer	End-X.
 * @param  integer	End-Y.
 * @param  integer	The colour.
 */
function imageline($image,$x1,$y1,$x2,$y2,$color)
{
}

/**
 * Draw an ellipse.
 *
 * @param  resource  The image involved.
 * @param  integer	Centre-X.
 * @param  integer	Centre-Y.
 * @param  integer	Width.
 * @param  integer	Height.
 * @param  integer	Colour.
 * @return boolean	Success status.
 */
function imageellipse($image,$cx,$cy,$w,$h,$color)
{
	return true;
}

/**
 * Draw a filled ellipse.
 *
 * @param  resource  The image involved.
 * @param  integer	Centre-X.
 * @param  integer	Centre-Y.
 * @param  integer	Width.
 * @param  integer	Height.
 * @param  integer	Colour.
 * @return boolean	Success status.
 */
function imagefilledellipse($image,$cx,$cy,$w,$h,$color)
{
	return true;
}

/**
 * Draw a character horizontally.
 *
 * @param  resource  The image involved.
 * @param  integer	Font number.
 * @param  integer	X.
 * @param  integer	Y.
 * @param  string		What to write.
 * @param  integer	Colour number.
 */
function imagechar($image,$font,$x,$y,$c,$color)
{
}

/**
 * Draw a filled polygon.
 *
 * @param  resource  The image involved.
 * @param  array		Array of pairs.
 * @param  integer	Number of points in array.
 * @param  integer	Colour number.
 */
function imagefilledpolygon($image,$points,$num_points,$colour)
{
}

/**
 * Draw a polygon.
 *
 * @param  resource  The image involved.
 * @param  array		Array of pairs.
 * @param  integer	Number of points in array.
 * @param  integer	Colour number.
 */
function imagepolygon($image,$points,$num_points,$colour)
{
}

/**
 * Draw a filled rectangle.
 *
 * @param  resource  The image involved.
 * @param  integer	First-X.
 * @param  integer	First-Y.
 * @param  integer	Second-X.
 * @param  integer	Second-Y.
 * @param  integer	Colour number.
 */
function imagefilledrectangle($image,$x1,$y1,$x2,$y2,$col)
{
}

/**
 * Draw a rectangle.
 *
 * @param  resource  The image involved.
 * @param  integer	First-X.
 * @param  integer	First-Y.
 * @param  integer	Second-X.
 * @param  integer	Second-Y.
 * @param  integer	Colour number.
 */
function imagerectangle($image,$x1,$y1,$x2,$y2,$col)
{
}

/**
 * Flood fill to specific color.
 *
 * @param  resource  The image involved.
 * @param  integer	Origin X.
 * @param  integer	Origin Y.
 * @param  integer	Border colour number.
 * @param  integer	Fill colour number.
 */
function imagefilltoborder($image,$x,$y,$border,$color)
{
}

/**
 * Apply a gamma correction to a GD image.
 *
 * @param  resource  The image involved.
 * @param  float		Input gamma.
 * @param  float		Output gamma.
 */
function imagegammacorrect($image,$in,$out)
{
}

/**
 * Enable or disable interlace / progressive-save.
 *
 * @param  resource  The image involved.
 * @param  BINARY		On/Off.
 * @return boolean	Whether interlace is set.
 */
function imageinterlace($image,$interlace)
{
	return true;
}

/**
 * Load a new font.
 *
 * @param  PATH		File.
 * @return ~integer  Font code (false: error).
 */
function imageloadfont($file)
{
	return 0;
}

/**
 * Copy the palette from one image to another.
 *
 * @param  resource  The image the palette is from.
 * @param  resource  The image the palette is to.
 */
function imagepalettecopy($destination,$source)
{
}

/**
 * Set the brush image for line drawing.
 *
 * @param  resource  The image involved.
 * @param  resource  The brush image.
 * @return boolean	Success status.
 */
function imagesetbrush($image,$brush)
{
	return true;
}

/**
 * Set the style for line drawing.
 *
 * @param  resource  The image involved.
 * @param  integer	Style number (IMG_COLOR_STYLED or IMG_COLOR_STYLEDBRUSHED).
 */
function imagesetstyle($image,$style)
{
}

/**
 * Set the thickness for line drawing.
 *
 * @param  resource  The image involved.
 * @param  integer	Thickness in pixels.
 * @return boolean	Success status.
 */
function imagesetthickness($image,$thickness)
{
	return true;
}

/**
 * Set the tile image for filling.
 *
 * @param  resource  The image involved.
 * @param  resource  The tile image.
 * @return boolean	Success status.
 */
function imagesettile($image,$tile)
{
	return true;
}

/**
 * Convert a true color image to a palette image.
 *
 * @param  resource  The image involved.
 * @param  boolean	Whether to use dithering.
 * @param  integer	The maximum number of colors that should be retained in the palette.
 */
function imagetruecolortopalette($image,$dither,$ncolors)
{
}

/**
 * Draw a character vertically.
 *
 * @param  resource  The image involved.
 * @param  integer	Font number.
 * @param  integer	X.
 * @param  integer	Y.
 * @param  string		What to write.
 * @param  integer	Colour number.
 */
function imagecharup($image,$font,$x,$y,$c,$color)
{
}

/**
 * Get the index of the closest color to the specified color.
 *
 * @param  resource  The image involved.
 * @param  integer	Red.
 * @param  integer	Green.
 * @param  integer	Blue.
 * @return integer	Colour number.
 */
function imagecolorclosest($image,$red,$green,$blue)
{
	return 0;
}

/**
 * Get the index of the closest color to the specified color + alpha.
 *
 * @param  resource  The image involved.
 * @param  integer	Red.
 * @param  integer	Green.
 * @param  integer	Blue.
 * @param  integer	Alpha.
 * @return integer	Colour number.
 */
function imagecolorclosestalpha($image,$red,$green,$blue,$alpha)
{
	return 0;
}

/**
 * Get the index of the color which has the hue, white and blackness nearest to the given color .
 *
 * @param  resource  The image involved.
 * @param  integer	Red.
 * @param  integer	Green.
 * @param  integer	Blue.
 * @return integer	Colour number.
 */
function imagecolorclosesthwb($image,$red,$green,$blue)
{
	return 0;
}

/**
 * De-allocate a color for an image.
 *
 * @param  resource  The image involved.
 * @param  integer	Colour number.
 * @return boolean	Success status.
 */
function imagecolordeallocate($image,$colour)
{
	return true;
}

/**
 * Get the index of the specified color.
 *
 * @param  resource  The image involved.
 * @param  integer	Red.
 * @param  integer	Green.
 * @param  integer	Blue.
 * @return integer	Colour number.
 */
function imagecolorexact($image,$red,$green,$blue)
{
	return 0;
}

/**
 * Get the index of the specified color + alpha.
 *
 * @param  resource  The image involved.
 * @param  integer	Red.
 * @param  integer	Green.
 * @param  integer	Blue.
 * @param  integer	Alpha.
 * @return ~integer  Colour number (false: error).
 */
function imagecolorexactalpha($image,$red,$green,$blue,$alpha)
{
	return 0;
}

/**
 * Get the index of the specified color or its closest possible alternative.
 *
 * @param  resource  The image involved.
 * @param  integer	Red.
 * @param  integer	Green.
 * @param  integer	Blue.
 * @return integer	Colour number.
 */
function imagecolorresolve($image,$red,$green,$blue)
{
	return 0;
}

/**
 * Get the index of the specified color + alpha or its closest possible alternative.
 *
 * @param  resource  The image involved.
 * @param  integer	Red.
 * @param  integer	Green.
 * @param  integer	Blue.
 * @param  integer	Alpha.
 * @return ~integer  Colour number (false: error).
 */
function imagecolorresolvealpha($image,$red,$green,$blue,$alpha)
{
	return 0;
}

/**
 * Set the color for the specified palette index.
 *
 * @param  resource  The image involved.
 * @param  integer	Red.
 * @param  integer	Green.
 * @param  integer	Blue.
 */
function imagecolorset($image,$red,$green,$blue)
{
}

/**
 * Find out the number of colors in an image's palette.
 *
 * @param  resource  The image involved.
 * @return integer	Total number of colours.
 */
function imagecolorstotal($image)
{
	return 0;
}

/**
 * Copy and merge part of an image.
 *
 * @param  resource  Destination image handle.
 * @param  resource  Source image handle.
 * @param  integer	Destination X-ordinate.
 * @param  integer	Destination Y-ordinate.
 * @param  integer	Source X-ordinate.
 * @param  integer	Source Y-ordinate.
 * @param  integer	Width to copy.
 * @param  integer	Height to copy.
 * @param  integer	Opacity value.
 */
function imagecopymerge($dst_im,$src_im,$dst_x,$dst_y,$src_x,$src_y,$src_w,$src_h,$pct)
{
}

/**
 * Join array elements with a string.
 *
 * @param  string	The glue component (becomes a deliminator).
 * @param  array	The pieces to join.
 * @return string	The joined string.
 */
function implode($glue,$pieces)
{
	return '';
}

/**
 * Checks if a value exists in an array.
 *
 * @param  mixed		Needle.
 * @param  array		Haystack.
 * @return boolean	Whether the value exists in the array.
 */
function in_array($needle,$haystack)
{
	return false;
}

/**
 * Include and evaluate the specified file.
 *
 * @param  PATH		The filename of the file to include.
 * @return mixed		Success status or returned value.
 */
function include($filename)
{
	return false;
}

/**
 * Include and evaluate the specified file, but only if it has not already been included.
 *
 * @param  PATH		The filename of the file to include.
 * @return mixed		Success status or returned value.
 */
function include_once($filename)
{
	return false;
}

/**
 * Gets the value of a configuration option. Note: On Phalanger any unknown config options will produce a warning if fetched.
 *
 * @param  string	Config option.
 * @return mixed	Value of option. (empty: no such config option, or an empty value) (false: ditto)
 */
function ini_get($varname)
{
	return '';
}

/**
 * Sets the value of a configuration option.
 *
 * @param  string		Config option.
 * @param  string		New value of option.
 * @return ~string	Old value of option (false: error).
 */
function ini_set($var,$value)
{
	return '';
}

/**
 * Get integer value of a variable.
 *
 * @param  mixed		Integer, but in some other form (usually string).
 * @param  integer	The base.
 * @return integer	The integer, extracted.
 */
function intval($var,$base=10)
{
	return 0;
}

/**
 * Whether the object is of this class or has this class as one of its parents.
 *
 * @param  object		The object.
 * @param  string		The class name.
 * @return boolean	Whether it is.
 */
function is_a($object,$class_name)
{
	return false;
}

/**
 * Finds whether a variable is an array.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_array($var)
{
	return false;
}

/**
 * Finds whether a variable is a boolean.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_bool($var)
{
	return false;
}

/**
 * Finds whether a path is to a directory.
 *
 * @param  PATH		The path to check.
 * @return boolean	Whether it is.
 */
function is_dir($path)
{
	return false;
}

/**
 * Finds whether a path is to a file.
 *
 * @param  PATH		The path to check.
 * @return boolean	Whether it is.
 */
function is_file($path)
{
	return false;
}

/**
 * Finds whether a path is to a symbolic link.
 *
 * @param  PATH		The path to check.
 * @return boolean	Whether it is.
 */
function is_link($path)
{
	return false;
}

/**
 * Finds whether a variable is a float.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_float($var)
{
	return false;
}

/**
 * Finds whether a variable is an integer.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_integer($var)
{
	return false;
}

/**
 * Finds whether a variable holds a callable function reference.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it does.
 */
function is_callable($var)
{
	return false;
}

/**
 * Finds whether a variable is null.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_null($var)
{
	return false;
}

/**
 * Finds whether a variable is numeric (e.g. a numeric string, or a pure integer).
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_numeric($var)
{
	return false;
}

/**
 * Finds whether a variable is an object.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_object($var)
{
	return false;
}

/**
 * Finds whether a path is to an actual readable file.
 *
 * @param  PATH		The path to check.
 * @return boolean	Whether it is.
 */
function is_readable($path)
{
	return false;
}

/**
 * Finds whether a variable is a resource.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_resource($var)
{
	return false;
}

/**
 * Finds whether a variable is a string.
 *
 * @param  mixed		What to check.
 * @return boolean	Whether it is.
 */
function is_string($var)
{
	return false;
}

/**
 * Finds whether a path is to an actual uploaded file.
 *
 * @param  PATH		The path to check.
 * @return boolean	Whether it is.
 */
function is_uploaded_file($path)
{
	return false;
}

/**
 * Finds whether a path is to an actual writeable file.
 *
 * @param  PATH		The path to check.
 * @return boolean	Whether it is.
 */
function is_writable($path)
{
	return false;
}

/**
 * Finds whether a variable exists / is not null / is an actually derefereable array element. Do not use this for the null case, and otherwise ONLY when for efficiency reasons.
 *
 * @param  mixed		The variable.
 * @return boolean	Whether it is set.
 */
function isset(&$path)
{
	return false;
}

/**
 * Sort an array by key in reverse order.
 *
 * @param  array	The array to sort.
 */
function krsort(&$array)
{
}

/**
 * Sort an array by key.
 *
 * @param  array	The array to sort.
 */
function ksort(&$array)
{
}

/*!ROADSEND*
 * Get numeric formatting information.
 *
 * @return array	Array of formatting information.
 */
/*function localeconv()
{
	return array();
}*/

/**
 * Strip whitespace from the beginning of a string.
 *
 * @param  string	The string to trim from.
 * @param  string	Characters to trim.
 * @return string	The trimmed string.
 */
function ltrim($string,$characters=" \t\n\r\0\x0B")
{
	return '';
}

/**
 * Send an e-mail.
 *
 * @param  string		The TO address.
 * @param  string		The subject.
 * @param  string		The message.
 * @param  string		Additional headers.
 * @param  string		Additional stuff to send to sendmail executable (if appropriate, only works when safe mode is off).
 * @return boolean	Success status.
 */
function mail($to,$subject,$message,$additional_headers='',$additional_flags='')
{
	return false;
}

/**
 * Find highest value between arguments.
 *
 * @param  mixed	First argument (if array, then each treated as a separate parameter).
 * @param  ?mixed	Second argument (NULL: no second argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Third argument (NULL: no third argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Fourth argument (NULL: no fourth argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Fifth argument (NULL: no fith argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Sixth argument (NULL: no sixth argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Seventh argument (NULL: no seventh argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Eighth argument (NULL: no eighth argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Ninth argument (NULL: no ninth argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Tenth argument (NULL: no tenth argument) (if array, then each treated as a separate parameter).
 * @return mixed	The highest valued argument.
 */
function max($arg1,$arg2=NULL,$arg3=NULL,$arg4=NULL,$arg5=NULL,$arg6=NULL,$arg7=NULL,$arg8=NULL,$arg9=NULL,$arg10=NULL)
{
	return 0;
}

/**
 * Calculate the md5 hash of a string.
 *
 * @param  string	String to hash.
 * @return string	Hashed result.
 */
function md5($str)
{
	return '';
}

/**
 * Checks if the class method exists.
 *
 * @param  object		Object of the class we want to check.
 * @param  string		The method name.
 * @return boolean	Whether the class method exists.
 */
function method_exists($object,$method_name)
{
	return false;
}

/**
 * Return current UNIX timestamp with microseconds.
 *
 * @param  boolean	Whether to return a float result. ALWAYS PASS THIS IN AS *FALSE* - FOR COMPATIBILITY WITH OLD VERSIONS OF PHP THAT DO NOT HAVE IT, WHILST PHP 6 DEFAULTS IT TO TRUE.
 * @return string		Micro-time.
 */
function microtime($as_float)
{
	unset($as_float);
	return '';
}

/**
 * Find lowest value between arguments.
 *
 * @param  mixed	First argument (if array, then each treated as a separate parameter).
 * @param  ?mixed	Second argument (NULL: no second argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Third argument (NULL: no third argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Fourth argument (NULL: no fourth argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Fifth argument (NULL: no fith argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Sixth argument (NULL: no sixth argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Seventh argument (NULL: no seventh argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Eighth argument (NULL: no eighth argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Ninth argument (NULL: no ninth argument) (if array, then each treated as a separate parameter).
 * @param  ?mixed	Tenth argument (NULL: no tenth argument) (if array, then each treated as a separate parameter).
 * @return mixed	The lowest valued argument.
 */
function min($arg1,$arg2=NULL,$arg3=NULL,$arg4=NULL,$arg5=NULL,$arg6=NULL,$arg7=NULL,$arg8=NULL,$arg9=NULL,$arg10=NULL)
{
	return 0;
}

/**
 * Makes a directory. {{creates-file}}
 *
 * @param  PATH		The path to the directory to make.
 * @param  integer	The mode (e.g. 0777).
 * @return boolean	Success status.
 */
function mkdir($path,$mode)
{
	return false;
}

/**
 * Get UNIX timestamp for a componentialised date.
 *
 * @param  integer	The hour.
 * @param  integer	The minute.
 * @param  integer	The second.
 * @param  ?integer	The month (NULL: now).
 * @param  ?integer	The day (NULL: now).
 * @param  ?integer	The year (NULL: now).
 * @param  integer	Whether date is in DST (-1 meaning unknown/guess, 0 meaning no, 1 meaning yes).
 * @return TIME		The timestamp.
 */
function mktime($hour,$minute,$second,$month=NULL,$day=NULL,$year=NULL,$is_dst=-1)
{
	return 0;
}

/**
 * Moves an uploaded file to a new location. {{creates-file}}
 *
 * @param  PATH		Filename to move (taken from tmpname element of $_FILES list entry).
 * @param  PATH		Path to move file to (preferably containing filename component).
 * @return boolean	The success status.
 */
function move_uploaded_file($filename,$destination)
{
	return false;
}

/**
 * Get largest possible random value.
 *
 * @return integer	The value.
 */
function mt_getrandmax()
{
	return 0;
}

/**
 * Generate a better random value.
 *
 * @param  integer	Minimum value.
 * @param  integer	Maximum value.
 * @return integer	Random value.
 */
function mt_rand($min,$max)
{
	return 0;
}

/**
 * Seed the better random number generator.
 *
 * @param  integer	The seed.
 */
function mt_srand($seed)
{
}

/**
 * Format a number with grouped thousands.
 *
 * @param  mixed		The number to format [integer or float] (technically always float because it could be larger than an integer, but that's ugly).
 * @param  integer	The number of decimal fraction digits to show.
 * @param  string		The string to use as a decimal point.
 * @param  string		The string to separate groups of 1000's with.
 * @return string		The string formatted number.
 */
function number_format($number,$decimals=0,$dec_point='.',$thousands_sep=',')
{
	return '';
}

/**
 * Clean (erase) the output buffer and turn off output buffering.
 *
 * @return boolean	Success status (could fail if there is no buffer).
 */
function ob_end_clean()
{
	return false;
}

/**
 * Flush (output and erase) the output buffer and turn off output buffering.
 *
 * @return boolean	Success status (could fail if there is no buffer).
 */
function ob_end_flush()
{
	return false;
}

/**
 * Return the contents of the output buffer .
 *
 * @return ~string	The buffer contents (false: no buffer).
 */
function ob_get_contents()
{
	return '';
}

/**
 * Return the contents of the output buffer and empty it. Not available on all PHP versions, do a version check before calling it.
 *
 * @return ~string	The buffer contents (false: no buffer).
 */
function ob_get_clean()
{
	return '';
}

/**
 * Turn on output buffering.
 *
 * @return boolean	Success status.
 */
function ob_start()
{
	return false;
}

/**
 * Output something.
 *
 * @param  string		The string to output.
 * @return integer	The number '1', always
 */
function print($octal_string)
{
	return 1;
}

/**
 * String representation of octal to decimal.
 *
 * @param  string		The string representation.
 * @return integer	The integer ('decimal' form, although truly stored in binary).
 */
function octdec($octal_string)
{
	return 0;
}

/**
 * Open a directory for analysis.
 *
 * @param  PATH		The path to the directory to open.
 * @return ~resource The directory handle (false: error).
 */
function opendir($path)
{
	return array();
}

/**
 * Return ASCII value of character.
 *
 * @param  string		String of length 1, containing character to find ASCII value of.
 * @return integer	The ASCII value.
 */
function ord($string)
{
	return 0;
}

/**
 * Pack data into binary string.
 *
 * @param  string	The formatting string.
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @param  ?mixed	Argument that binds to the formatting string (NULL: none).
 * @return string	The binary string.
 */
function pack($format,$arg1=NULL,$arg2=NULL,$arg3=NULL,$arg4=NULL,$arg5=NULL,$arg6=NULL,$arg7=NULL,$arg8=NULL,$arg9=NULL,$arg10=NULL,$arg11=NULL,$arg12=NULL,$arg13=NULL,$arg14=NULL,$arg15=NULL,$arg16=NULL,$arg17=NULL,$arg18=NULL,$arg19=NULL,$arg20=NULL,$arg21=NULL,$arg22=NULL,$arg23=NULL,$arg24=NULL,$arg25=NULL,$arg26=NULL,$arg27=NULL,$arg28=NULL,$arg29=NULL,$arg30=NULL)
{
	return '';
}

/**
 * Parse a URL and return its components.
 *
 * @param  string		The URL to parse.
 * @return ~array		A map of details about the URL (false: URL cannot be parsed).
 */
function parse_url($url)
{
	return array();
}

/**
 * Returns information about a file path.
 *
 * @param  PATH		The path to parse.
 * @return ~array		A map of details about the path. (false: error)
 */
function pathinfo($path)
{
	return array();
}

/**
 * Outputs lots of PHP information.
 */
function phpinfo()
{
}

/**
 * Gets the current PHP version.
 *
 * @return string	The PHP version.
 */
function phpversion()
{
	return '';
}

/**
 * Return info about a user by user id. Does not exist on Windows.
 *
 * @param  integer	The user ID.
 * @return ~array		A map of details of the user. (false: failure)
 */
function posix_getpwuid($uid)
{
	return array();
}

/**
 * Return the real user ID of the current process. Does not exist on Windows.
 *
 * @return integer	User ID.
 */
function posix_getuid()
{
	return 0;
}

/**
 * Perform a regular expression match.
 *
 * @param  string		The pattern.
 * @param  string		The subject string.
 * @param  ?array		Where matches will be put (note that it is a list of maps, except the arrays are turned inside out). (NULL: do not store matches). Note that this is actually passed by reference, but is also optional.
 * @param  integer	Either 0, or PREG_OFFSET_CAPTURE.
 * @return ~integer  The number of matches (false: error).
 */
function preg_match($pattern,$subject,$matches=NULL,$flags=0)
{
	return 0;
}

/**
 * Array entries that match the pattern.
 *
 * @param  string		The pattern.
 * @param  array		The subject strings.
 * @param  integer	Either 0, or PREG_GREP_INVERT.
 * @return array		Matches
 */
function preg_grep($pattern,$subject,$flags=0)
{
	return array();
}

/**
 * Perform a global regular expression match.
 *
 * @param  string		The pattern.
 * @param  string		The subject string.
 * @param  array		Where matches will be put (note that it is a list of maps, except the arrays are turned inside out). Note that this is actually passed by reference, but is also optional.
 * @param  integer	Either 0, or PREG_OFFSET_CAPTURE.
 * @return ~integer  The number of matches (false: error).
 */
function preg_match_all($pattern,$subject,&$matches,$flags=0)
{
	return 0;
}

/**
 * Perform a regular expression search and replace.
 *
 * @param  mixed		The pattern (string or array).
 * @param  mixed		The replacement string (string or array).
 * @param  string		The subject string.
 * @param  ?integer  The limit of replacements (NULL: no limit).
 * @return ~string	The string with replacements made (false: error).
 */
function preg_replace($pattern,$replacement,$subject,$limit=NULL)
{
	return '';
}

/**
 * Perform a regular expression search and replace using a callback.
 *
 * @param  string		The pattern.
 * @param  mixed		The callback.
 * @param  string		The subject string.
 * @param  ?integer  The limit of replacements (NULL: no limit).
 * @return ~string	The string with replacements made (false: error).
 */
function preg_replace_callback($pattern,$callback,$subject,$limit=NULL)
{
	return '';
}

/**
 * Split string by a regular expression.
 *
 * @param  string		The pattern.
 * @param  string		The subject.
 * @param  ?integer  The maximum number of splits to make (NULL: no limit).
 * @param  ?integer  The special mode (NULL: none).
 * @return array		The array due to splitting.
 */
function preg_split($pattern,$subject,$max_splits=NULL,$mode=NULL)
{
	return array();
}

/**
 * Prints human-readable information about a variable.
 *
 * @param  mixed	The variable.
 */
function print_r($data)
{
}

/**
 * Sets the value of an environment variable.
 *
 * @param  string		The string to send over (e.g. PATH=foo).
 * @return boolean	Success status.
 */
function putenv($string)
{
	return true;
}

/**
 * Decode URL-encoded strings.
 *
 * @param  string	The string to decode.
 * @return string	Decoded string.
 */
function rawurldecode($str)
{
	return '';
}

/**
 * Encode URL-encoded strings.
 *
 * @param  string	The string to encode.
 * @return string	Encoded string.
 */
function rawurlencode($str)
{
	return '';
}

/**
 * Read entry from directory handle.
 *
 * @param  resource  Handle.
 * @return ~string	Next filename (false: reached end already).
 */
function readdir($dir_handle)
{
	return '';
}

/**
 * Returns canonicalized absolute pathname.
 *
 * @param  PATH		(Possibly) perceived path.
 * @return PATH		Actual path.
 */
function realpath($path)
{
	return '';
}

/**
 * Register a function for execution on shutdown.
 *
 * @param  mixed	Callback.
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 * @param  ?mixed	Parameter (NULL: not used).
 */
function register_shutdown_function($callback,$parama=NULL,$paramb=NULL,$paramc=NULL,$paramd=NULL,$parame=NULL,$paramf=NULL,$paramg=NULL,$paramh=NULL,$parami=NULL,$paramj=NULL,$paramk=NULL,$paraml=NULL,$paramm=NULL,$paramn=NULL,$paramo=NULL,$paramp=NULL,$paramq=NULL)
{
}

/**
 * Renames a file.
 *
 * @param  PATH		Old name.
 * @param  PATH		New name.
 * @return boolean	Success status.
 */
function rename($oldname,$newname)
{
	return false;
}

/**
 * Require and evaluate the specified file (dies with error if it can not).
 *
 * @param  PATH		The filename of the file to require.
 * @return mixed		Success status or returned value.
 */
function require($filename)
{
	return false;
}

/**
 * Require and evaluate the specified file (dies with error if it can not), but only if it has not been loaded already.
 *
 * @param  PATH		The filename of the file to require.
 * @return mixed		Success status or returned value.
 */
function require_once($filename)
{
	return false;
}

/**
 * Set the internal pointer of an array to its first element.
 *
 * @param  array	The array.
 * @return mixed	The value of the first element.
 */
function reset($array)
{
	return 0;
}

/**
 * Removes directory.
 *
 * @param  PATH		Directory path.
 * @return boolean	Success status.
 */
function rmdir($dirname)
{
	return false;
}

/**
 * Rounds a float.
 *
 * @param  float		Value to round.
 * @param  integer	Number of decimal points of precision required (-ve allowed).
 * @return float		Rounded value.
 */
function round($val,$precision=0)
{
	return 0.0;
}

/**
 * Sort an array in reverse order.
 *
 * @param  array	The array to sort.
 */
function rsort(&$array)
{
}

/**
 * Strip whitespace from the end of a string.
 *
 * @param  string	String to trim from.
 * @param  string	Characters to trim.
 * @return string	Trimmed string.
 */
function rtrim($str,$characters=" \t\n\r\0\x0B")
{
	return '';
}

/**
 * Generates a storable representation of a value.
 *
 * @param  mixed	Whatever is to be serialised .
 * @return string	The serialisation.
 */
function serialize($value)
{
	return '';
}

/**
 * Sets a user-defined error handler function.
 *
 * @param  mixed	The call back.
 * @return mixed	The previously defined error handler.
 */
function set_error_handler($error_handler)
{
	return '';
}

/*!ROADSEND*
 * Limits the maximum execution time.
 *
 * @param  integer	The number of a seconds the application is allowed to run.
 */
/*function set_time_limit($seconds)
{
}*/

/**
 * Send a cookie.
 *
 * @param  string		The name.
 * @param  ?string	The value (NULL: unset existing cookie).
 * @param  ?integer  Expiration timestamp (NULL: session cookie).
 * @param  ?string	Path (NULL: current URL path).
 * @param  ?string	Domain (NULL: current URL domain).
 * @param  BINARY		Whether the cookie is only for HTTPS.
 * @return boolean	Success status (fails if output already started).
 */
function setcookie($name,$value=NULL,$expire=NULL,$path=NULL,$domain=NULL,$secure=0)
{
	return false;
}

/*!ROADSEND*
 * Set locale information.
 *
 * @param  integer	The locale category (LC_ALL, LC_COLLATE, LC_CTYPE, LC_MONETARY, LC_NUMERIC, LC_TIME)
 * @param  mixed		The locale (Some PHP versions require an array, and some a string with multiple calls).
 * @return ~string	The set locale (false: error).
 */
/*function setlocale($category,$locale)
{
	return '';
}*/

/*!ROADSEND*
 * Calculate the sha1 hash of a string.
 *
 * @param  string	The string to hash.
 * @return string	The hash of the string.
 */
/*function sha1($str)
{
	return '';
}*/

/*!SPECIAL*
 * Get data from the persistent cache.
 *
 * @param  mixed			Key
 * @return ?mixed			The data (NULL: not found / NULL entry)
 */
/*function eaccelerator_get($id)
{
	return array();
}*/

/*!SPECIAL*
 * Put data into the persistent cache.
 *
 * @param  mixed			Key
 * @param  mixed			The data
 * @param  integer		Various flags (parameter not used)
 */
/*function eaccelerator_put($id,$value,$timeout)
{
}*/

/*!SPECIAL*
 * Delete data from the persistent cache.
 *
 * @param  mixed			Key name
 */
/*function eaccelerator_rm($id)
{
}*/

/*!SPECIAL*
 * Get data from the persistent cache.
 *
 * @param  mixed			Key
 * @return ?mixed			The data (NULL: not found / NULL entry)
 */
/*function mmcache_get($id)
{
	return array();
}*/

/*!SPECIAL*
 * Put data into the persistent cache.
 *
 * @param  mixed			Key
 * @param  mixed			The data
 * @param  integer		Various flags (parameter not used)
 */
/*function mmcache_put($id,$value,$flags)
{
}*/

/*!SPECIAL*
 * Delete data from the persistent cache.
 *
 * @param  mixed			Key name
 */
/*function mmcache_rm($id)
{
}*/

/**
 * Prepare a command path for a shell call to it.
 *
 * @param  string		The command.
 * @return string		Escaped.
 */
function escapeshellcmd($arg)
{
	return '';
}

/**
 * Prepare an argument for use literally in a command.
 *
 * @param  string		The argument.
 * @return string		Escaped.
 */
function escapeshellarg($arg)
{
	return '';
}

/**
 * Calculate the sine of an angle.
 *
 * @param  float	The angle.
 * @return float	The sine of the angle.
 */
function sin($arg)
{
	return 0.0;
}

/**
 * Sort an array.
 *
 * @param  array	The array.
 */
function sort(&$array)
{
}

/**
 * Return a formatted string.
 *
 * @param  string	Formatting string.
 * @param  ?mixed	Argument for the formatting string (NULL: none required).
 * @param  ?mixed	Argument for the formatting string (NULL: none required).
 * @param  ?mixed	Argument for the formatting string (NULL: none required).
 * @param  ?mixed	Argument for the formatting string (NULL: none required).
 * @param  ?mixed	Argument for the formatting string (NULL: none required).
 * @param  ?mixed	Argument for the formatting string (NULL: none required).
 * @param  ?mixed	Argument for the formatting string (NULL: none required).
 * @param  ?mixed	Argument for the formatting string (NULL: none required).
 * @return string	Formatted string.
 */
function sprintf($format,$arg1=NULL,$arg2=NULL,$arg3=NULL,$arg4=NULL,$arg5=NULL,$arg6=NULL,$arg7=NULL,$arg8=NULL)
{
	return '';
}

/**
 * Seed the random number generator.
 *
 * @param  integer	The seed.
 */
function srand($seed)
{
}

/**
 * Pad a string to a certain length with another string.
 *
 * @param  string		The subject.
 * @param  integer	The length to pad up to.
 * @param  string		What we are padding with.
 * @param  integer	The padding type (STR_PAD_RIGHT, STR_PAD_LEFT, STR_PAD_BOTH).
 * @return string		The result.
 */
function str_pad($input,$pad_length,$pad_string=' ',$pad_type=STR_PAD_RIGHT)
{
	return '';
}

/**
 * Repeat a string.
 *
 * @param  string		The string to repeat.
 * @param  integer	How many times to repeat the string.
 * @return string		The result.
 */
function str_repeat($input,$multiplier)
{
	return '';
}

/**
 * Replace all occurrences of the search string with the replacement string.
 *
 * @param  mixed	What's being replaced (string or array).
 * @param  mixed	What's being replaced with (string or array).
 * @param  mixed	Subject (string or array).
 * @return mixed	Result (string or array).
 */
function str_replace($search,$replace,$subject)
{
	return '';
}

/**
 * Binary safe string comparison.
 *
 * @param  string		The first string.
 * @param  string		The second string.
 * @return integer	<0 if s1<s2, 0 if s1=s2, >1 if s1>s2.
 */
function strcmp($str1,$str2)
{
	return 0;
}

/**
 * Format a local time/date according to locale settings (uses alternative formatting to 'date' function).
 *
 * @param  string	The formatting string.
 * @param  ?TIME	The timestamp (NULL: now).
 * @return string	The formatted string.
 */
function strftime($format,$timestamp=NULL)
{
	return '';
}

/**
 * Strip HTML and PHP tags from a string.
 *
 * @param  string	Subject.
 * @param  string	Comma-separated list of allowable tags.
 * @return string	Result.
 */
function strip_tags($str,$allowable_tags='')
{
	return '';
}

/**
 * Quote string for encapsulation in a written string data type.
 *
 * @param  string	Unslashed string.
 * @return string	Slashed string.
 */
function addslashes($str)
{
	return '';
}

/**
 * Un-quote string slashed with addslashes.
 *
 * @param  string	Slashed string.
 * @return string	Unslashed string.
 */
function stripslashes($str)
{
	return '';
}

/**
 * Get string length.
 *
 * @param  string		The string to get the length of.
 * @return integer	The string length.
 */
function strlen($str)
{
	return 0;
}

// FUDGEFUDGE: strpos can give "Offset not contained in string" error. We'd ideally have it in our catch errors list (code_quality.php) but it's unrealistic to catch all strpos errors.

/**
 * Find position of first occurrence of a string.
 *
 * @param  string		Haystack.
 * @param  string		Needle.
 * @param  integer	Offset to search from.
 * @return ~integer  The offset it is found at (false: not found).
 */
function strpos($haystack,$needle,$offset=0)
{
	return 0;
}

/**
 * Find position of last occurrence of a char in a string.
 *
 * @param  string		Haystack.
 * @param  string		Needle.
 * @return ~integer  The offset it is found at (false: not found).
 */
function strrpos($haystack,$needle)
{
	return 0;
}

/**
 * Find first occurrence of a string.
 *
 * @param  string		Haystack.
 * @param  string		Needle.
 * @return ~string	The answer (false: does not occur).
 */
function strstr($haystack,$needle)
{
	return '';
}

/**
 * Tokenize string.
 *
 * @param  string		String to tokenise. EXCEPT if $deliminators=NULL, then this has actual deliminators.
 * @param  ?string	Deliminators (NULL: continue with previous tokenisation).
 * @return ~string	Next token (false: could not return a token, no more tokens to return).
 */
function strtok($subject,$deliminators=NULL)
{
	return '';
}

/**
 * Make a string lowercase.
 *
 * @param  string	Subject.
 * @return string	Result.
 */
function strtolower($str)
{
	return '';
}

/**
 * Parse about any English textual datetime description into a UNIX timestamp.
 *
 * @param  string		The subject.
 * @param  ?TIME		The timestamp to find times relative to (NULL: now).
 * @return TIME		The timetamp (-1: failed).
 */
function strtotime($time,$now=NULL)
{
	return 0;
}

/**
 * Make a string uppercase.
 *
 * @param  string	Subject.
 * @return string	Result.
 */
function strtoupper($str)
{
	return '';
}

/**
 * Translate certain characters.
 *
 * @param  string	Subject.
 * @param  mixed	Map of translations to do OR from string.
 * @param  ?mixed	To string (NULL: previous parameter was a map).
 * @return string	Result.
 */
function strtr($string,$replace_pairs,$to=NULL)
{
	return '';
}

/**
 * Get string value of a variable.
 *
 * @param  mixed	The variable.
 * @return string	String value of the variable.
 */
function strval($var)
{
	return '';
}

/**
 * Return part of a string.
 *
 * @param  string		The subject.
 * @param  integer	The start position.
 * @param  ?integer  The length to extract (NULL: all remaining).
 * @return ~string	String part (false: $start was over the end of the string).
 */
function substr($string,$start,$length=NULL)
{
	return '';
}

/**
 * Count the number of substring occurrences.
 *
 * @param  string		The subject.
 * @param  string		The substring to search for in the subject.
 * @return integer	The number of times substring occurs in the subject.
 */
function substr_count($haystack,$needle)
{
	return 0;
}

/**
 * Create file with unique file name. {{creates-file}}
 *
 * @param  PATH		The directory to create in (empty for temp directory).
 * @param  string		The prefix of the temporary file name.
 * @return ~string	The name of the temporary file (false: error).
 */
function tempnam($dir,$prefix)
{
	return '';
}

/**
 * Return current UNIX timestamp.
 *
 * @return TIME		The timestamp.
 */
function time()
{
	return 0;
}

/**
 * Strip whitespace from both ends of a string.
 *
 * @param  string	String to trim from.
 * @param  string	Characters to trim.
 * @return string	Trimmed string.
 */
function trim($str,$characters=" \t\n\r\0\x0B")
{
	return '';
}

/**
 * Generates a user-level error/warning/notice message.
 *
 * @param  string		The error message.
 * @param  integer	The PHP error type constant.
 */
function trigger_error($error_msg,$error_type)
{
}

/**
 * Sort an array with a user-defined comparison function and maintain index association.
 *
 * @param  array	The array.
 * @param  mixed	Comparison function.
 */
function uasort(&$array,$cmp_function)
{
}

/**
 * Make a string's first character uppercase.
 *
 * @param  string	Subject.
 * @return string	Result.
 */
function ucfirst($str)
{
	return '';
}

/**
 * Uppercase the first character of each word in a string.
 *
 * @param  string	Subject.
 * @return string	Result.
 */
function ucwords($str)
{
	return '';
}

/**
 * Sort an array by keys using a user-defined comparison function.
 *
 * @param  array	The array.
 * @param  mixed	Comparison function.
 */
function uksort(&$array,$cmp_function)
{
}

/**
 * Generate a unique ID.
 *
 * @param  string		Prefix for unique ID.
 * @param  boolean	Whether to add additional "combined LCG" entropy at the end of the return value.
 * @return string		Unique ID.
 */
function uniqid($prefix,$lcg=false)
{
	return '';
}

/**
 * Deletes a file.
 *
 * @param  PATH		The filename.
 * @return boolean	Success status.
 */
function unlink($filename)
{
	return false;
}

/**
 * Creates a PHP value from a stored representation.
 *
 * @param  string		Serialized string.
 * @return ~mixed		What was originally serialised (false: bad data given, or actually false was serialized).
 */
function unserialize($str)
{
	return 0;
}

/**
 * Unset a given variable.
 *
 * @param  mixed	Unset this.
 */
function unset(&$var)
{
}

/**
 * Decodes URL-encoded string.
 *
 * @param  string	URL encoded string.
 * @return string	Pure string.
 */
function urldecode($str)
{
	return '';
}

/**
 * URL-encodes string.
 *
 * @param  string	The pure string to URL encode.
 * @return string	URL encoded string.
 */
function urlencode($str)
{
	return '';
}

/**
 * Sort an array by values using a user-defined comparison function.
 *
 * @param  array	The array.
 * @param  mixed	Comparison function.
 */
function usort(&$array,$cmp_function)
{
}

/**
 * Converts a string with ISO-8859-1 characters encoded with UTF-8 to single-byte ISO-8859-1.
 *
 * @param  string	Subject.
 * @return string	Result.
 */
function utf8_decode($data)
{
	return '';
}

/**
 * Encodes an ISO-8859-1 string to UTF-8.
 *
 * @param  string	Subject.
 * @return string	Result.
 */
function utf8_encode($data)
{
	return '';
}

/**
 * Wraps a string to a given number of characters using a string break character.
 *
 * @param  string		Subject.
 * @param  integer	The word wrap position.
 * @param  string		The string to put at wrap points.
 * @param  boolean	Whether to cut up words.
 * @return string		Word-wrapped string.
 */
function wordwrap($string,$width=75,$break="\n",$cut=false)
{
	return '';
}

/**
 * Xdebug: dump profiling information.
 *
 * @param  integer	The dump mode
 */
function xdebug_dump_function_profile($type)
{
}

/**
 * Xdebug: start profiling.
 */
function xdebug_start_profiling()
{
}

/**
 * Get XML parser error string for a certain error code.
 *
 * @param  integer	Error code.
 * @return string		The string representation of the error code given.
 */
function xml_error_string($code)
{
	return '';
}

/**
 * Get current byte index for an XML parser.
 *
 * @param  resource  XML parser.
 * @return ~integer  Byte index (false: invalid parser given).
 */
function xml_get_current_byte_index($parser)
{
	return 0;
}

/**
 * Get current line number for an XML parser.
 *
 * @param  resource  XML parser.
 * @return ~integer  Line number (false: invalid parser given).
 */
function xml_get_current_line_number($parser)
{
	return 0;
}

/**
 * Get XML parser error code for last error the occurred.
 *
 * @param  resource  XML parser.
 * @return integer	The error code.
 */
function xml_get_error_code($parser)
{
	return 0;
}

/**
 * Start parsing an XML document.
 *
 * @param  resource  XML parser.
 * @param  string		The data to parse.
 * @param  boolean	Finish parsing process with this piece of data (otherwise parsing is open to re-enter with more data).
 * @return BINARY		Success status.
 */
function xml_parse($parser,$data,$is_final=false)
{
	return 0;
}

/*!ROADSEND*
 * Create an XML parser with namespace support.
 *
 * @param  ?string	Encoding (NULL: PHP4: as-for-input/PHP5: autodetect).
 * @return ~resource XML parser (false: could not create, happens on default PHP5 on Windows).
 */
/*function xml_parser_create_ns($encoding=NULL)
{
	return array();
}*/

/**
 * Free an XML parser.
 *
 * @param  resource  XML parser.
 * @return boolean	Success status.
 */
function xml_parser_free($parser)
{
	return false;
}

/**
 * Set options in an XML parser.
 *
 * @param  resource  XML parser.
 * @param  integer	The option to set (XML_OPTION_CASE_FOLDING [integer], XML_OPTION_TARGET_ENCODING [string]).
 * @param  mixed		The value (BINARY or string).
 * @return boolean	Success status.
 */
function xml_parser_set_option($parser,$option,$value)
{
	return false;
}

/**
 * Set up character data handler.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback.
 * @return boolean	Success status.
 */
function xml_set_character_data_handler($parser,$handler)
{
	return false;
}

/**
 * Set up start and end element handlers.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback for start of element.
 * @param  mixed		The callback for end of element.
 * @return boolean	Success status.
 */
function xml_set_element_handler($parser,$start_handler,$end_handler)
{
	return false;
}

/*!ROADSEND*
 * Set up namespace-end decl handler.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback.
 * @return boolean	Success status.
 */
/*function xml_set_end_namespace_decl_handler($parser,$handler)
{
	return false;
}*/

/**
 * Use XML Parser within an object.
 *
 * @param  resource  XML parser.
 * @param  object		The object.
 */
function xml_set_object($parser,$object)
{
}

/*!ROADSEND*
 * Set up namespace-start decl handler.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback.
 * @return boolean	Success status.
 */
/*function xml_set_start_namespace_decl_handler($parser,$handler)
{
	return false;
}*/

/**
 * Generates XML for a method request.
 *
 * @param  string	The method to call.
 * @param  array	The parameters to use.
 * @return string	The XML.
 */
function xmlrpc_encode_request($method,$params)
{
	return '';
}

/**
 * Arc cosine.
 *
 * @param  float	Argument.
 * @return float	Angle.
 */
function acos($arg)
{
	return 0.0;
}

/**
 * Pick one or more random entries out of an array.
 *
 * @param  array		Array to choose from.
 * @param  integer	Number of entries required.
 * @return mixed		Random entry, or array of random entries if $num_req!=1.
 */
function array_rand($input,$num_req=1)
{
	return 0;
}

/**
 * Prepend one or more elements to the beginning of array.
 *
 * @param  array	Array to prepend to.
 * @param  mixed	Element to prepend.
 */
function array_unshift(&$array,$var)
{
}

/**
 * Arc sine.
 *
 * @param  float	Argument.
 * @return float	Angle.
 */
function asin($arg)
{
	return 0.0;
}

/*!ROADSEND*
 * Checks if assertion is FALSE.
 *
 * @param  string	The expression to assert on.
 */
/*function assert($assertion)
{
}*/

/*!ROADSEND*
 * Set/get the various assert flags (and sometimes, options for them).
 *
 * @param  integer	The option (ASSERT_ACTIVE, ASSERT_WARNING, ASSERT_BAIL, ASSERT_QUIET_EVAL, ASSERT_CALLBACK).
 * @param  ?mixed		The value for flag (NULL: N/A).
 * @return ~mixed	 	Old value (false: error).
 */
/*function assert_options($option,$value=NULL)
{
	return 0;
}*/

/**
 * Arc tan.
 *
 * @param  float	Argument.
 * @return float	Angle.
 */
function atan($num)
{
	return 0.0;
}

/**
 * Convert a number between arbitrary bases (string representations).
 *
 * @param  string		The string representation number to convert.
 * @param  integer	From base.
 * @param  integer	To base.
 * @return string		New base representation.
 */
function base_convert($number,$frombase,$tobase)
{
	return '';
}

/**
 * Returns filename component of path.
 *
 * @param  PATH		Path.
 * @param  string		File extension to cut off (blank: none).
 * @return string		File name component.
 */
function basename($path,$ext='')
{
	return '';
}

/*!ROADSEND*
 * Convert binary data (in string form) into hexadecimal representation.
 *
 * @param  string	Binary string.
 * @return string	Hex string.
 */
/*function bin2hex($str)
{
	return '';
}*/

/**
 * Binary (string representation) to decimal (integer).
 *
 * @param  string		Binary in string form.
 * @return integer	Number.
 */
function bindec($binary_string)
{
	return 0;
}

/**
 * Call a user function given with an array of parameters.
 *
 * @param  mixed	Callback.
 * @param  array	Parameters.
 * @return mixed	Whatever the function returned.
 */
function call_user_func_array($callback,$parameters)
{
	return 0;
}

/*!ROADSEND*
 * Whether the client has disconnected.
 *
 * @return boolean	Whether the client has disconnected.
 */
/*function connection_aborted()
{
	return false;
}*/

/*!ROADSEND*
 * Returns connection status bitfield.
 *
 * @return integer	Connection status bitfield.
 */
/*function connection_status()
{
	return 0;
}*/

/**
 * Calculates the crc32 polynomial of a string.
 *
 * @param  string		The string to get the CRC32 of.
 * @return integer	The CRC32.
 */
function crc32($str)
{
	return 0;
}

/**
 * Decimal (integer) to binary (string representation).
 *
 * @param  integer	Decimal.
 * @return string		String representation of binary number.
 */
function decbin($number)
{
	return '';
}

/**
 * Return the current key and value pair from an array and advance the array cursor.
 *
 * @param  array	Array we're progressing through.
 * @return array	(key, value) pair.
 */
function each($array)
{
	return array();
}

/**
 * Determine whether a variable is empty (empty being defined differently for different types).
 *
 * @param  mixed		Input.
 * @return boolean	Whether it is CONSIDERED empty.
 */
function empty($var)
{
	return false;
}

/**
 * Set the internal pointer of an array to its last element.
 *
 * @param  array	The array.
 * @return mixed	Value of the last element.
 */
function end($array)
{
	return 0;
}

/**
 * Flushes the output to a file.
 *
 * @param  resource  The file handle to flush.
 * @return boolean	Success status.
 */
function fflush($handle)
{
	return false;
}

/**
 * Gets last access time of file.
 *
 * @param  PATH		The filename.
 * @return ~TIME		Timestamp of last access (false: error).
 */
function fileatime($filename)
{
	return 0;
}

/**
 * Portable advisory file locking.
 *
 * @param  resource  File handle.
 * @param  integer	Operation (LOCK_SH, LOCK_EX, LOCK_UN).
 * @return boolean	Success status.
 */
function flock($handle,$operation)
{
	return false;
}

/**
 * Flush the output buffer.
 */
function flush()
{
}

/**
 * Gets the name of the owner of the current PHP script.
 *
 * @return string	Name.
 */
function get_current_user()
{
	return '';
}

/**
 * Get the Internet host name corresponding to a given IP address.
 *
 * @param  string	IP address.
 * @return string	Host name OR IP address if failed to look up.
 */
function gethostbyaddr($ip_address)
{
	return '';
}

/**
 * Get the IP address corresponding to a given Internet host name.
 *
 * @param  string	Host name.
 * @return string	IP address OR host name if failed to look up.
 */
function gethostbyname($hostname)
{
	return '';
}

/**
 * Get largest possible random value.
 *
 * @return integer	Largest possible random value.
 */
function getrandmax()
{
	return 0;
}

/**
 * Get UNIX timestamp for a GMT date.
 *
 * @param  integer	The hour.
 * @param  integer	The minute.
 * @param  integer	The second.
 * @param  integer	The month.
 * @param  integer	The day.
 * @param  integer	The year.
 * @param  integer	Whether date is in DST (-1 meaning unknown/guess, 0 meaning no, 1 meaning yes).
 * @return integer	The timestamp.
 */
function gmmktime($hour,$minute,$second,$month,$day,$year,$is_dst=-1)
{
	return 0;
}

/**
 * Format a GMT/UTC time/date according to locale settings.
 *
 * @param  string	The formatting string.
 * @param  ?TIME	The timestamp (NULL: now).
 * @return string	The formatted string.
 */
function gmstrftime($format,$timestamp=NULL)
{
	return '';
}

/**
 * Converts a string containing an (IPv4) Internet Protocol dotted address into a proper address.
 *
 * @param  string		The IP address.
 * @return ~integer  The long form (false: cannot perform conversion).
 */
function ip2long($ip_address)
{
	return 0;
}

/**
 * Fetch a key from an associative array.
 *
 * @param  array	The array.
 * @return mixed	The index element of the current array position.
 */
function key($array)
{
	return 0;
}

/*!ROADSEND*  --> Use similar_text
 * Calculate Levenshtein distance between two strings.
 *
 * @param  string		First string.
 * @param  string		Second string.
 * @return integer	Distance.
 */
/*function levenshtein($str1,$str2)
{
	return 0;
}*/

/**
 * Natural logarithm.
 *
 * @param  float	Number to find log of.
 * @return float	Log of given number.
 */
function log($arg)
{
	return 0.0;
}

/**
 * Base-10 logarithm.
 *
 * @param  float	Number to find log of.
 * @return float	Log of given number.
 */
function log10($arg)
{
	return 0.0;
}

/**
 * Converts an (IPv4) Internet network address into a string in Internet standard dotted format.
 *
 * @param  string		The IP address.
 * @return integer	The long form.
 */
function long2ip($proper_address)
{
	return 0;
}

/*!ROADSEND*
 * Calculates the md5 hash of the file identified by the given filename.
 *
 * @param  PATH		File name.
 * @return ~string	The hash of the file. (false: error)
 */
/*function md5_file($filename)
{
	return '';
}*/

/*!ROADSEND*
 * Formats a number as a currency string.
 *
 * @param  string	The formatting string.
 * @param  float	The number to format as currency.
 * @return string	The final currency string.
 */
/*function money_format($format,$number)
{
	return '';
}*/

/**
 * Advance the internal array pointer of an array.
 *
 * @param  array	The array.
 * @return mixed	The array value we're now pointing at.
 */
function next($array)
{
	return 0;
}

/**
 * Get value of PI.
 *
 * @return float	PI.
 */
function pi()
{
	return 0.0;
}

/**
 * Exponential expression.
 *
 * @param  float	Base.
 * @param  float	Exponent.
 * @return float	Result.
 */
function pow($base,$exp)
{
	return 0.0;
}

/**
 * Quote regular expression characters.
 *
 * @param  string	The string to escape.
 * @param  string	Extra character to escape, was used in regular expression to surround it.
 * @return string	The escape string.
 */
function preg_quote($str,$surround_char='/')
{
	return '';
}

/**
 * Rewind the internal array pointer.
 *
 * @param  array	The array.
 * @return mixed	The array value we're now pointing at.
 */
function prev($array)
{
	return 0;
}

/**
 * Converts the radian number to the equivalent number in degrees.
 *
 * @param  float	The angle in radians.
 * @return float	The angle in degrees.
 */
function rad2deg($number)
{
	return 0.0;
}

/**
 * Create a sequence in an array.
 *
 * @param  mixed		From (integer or character string).
 * @param  mixed		To (integer or character string).
 * @param  integer	Step.
 * @return array		The sequence.
 */
function range($from,$to,$step=1)
{
	return array();
}

/**
 * Outputs a file.
 *
 * @param  PATH		The filename.
 * @return ~integer  The number of bytes read (false: error).
 */
function readfile($filename)
{
	return 0;
}

/**
 * Shuffle an array.
 *
 * @param  array	The array to shuffle.
 */
function shuffle($array)
{
}

/**
 * Calculate the similarity between two strings.
 *
 * @param  string		First string.
 * @param  string		Second string.
 * @param  ?float		Returns the percentage of similarity (NULL: do not get).
 * @return integer	The number of matching characters.
 */
function similar_text($first,$second,/*&*/$percent=NULL)
{
	return 0;
}

/**
 * Square root.
 *
 * @param  float	Number.
 * @return float	return 0.0;
 */
function sqrt($arg)
{
	return 0.0;
}

/**
 * Binary safe case-insensitive string comparison.
 *
 * @param  string		The first string.
 * @param  string		The second string.
 * @return integer	<0 if s1<s2, 0 if s1=s2, >1 if s1>s2.
 */
function strcasecmp($str1,$str2)
{
	return 0;
}

/**
 * Locale based string comparison.
 *
 * @param  string		The first string.
 * @param  string		The second string.
 * @return integer	<0 if s1<s2, 0 if s1=s2, >1 if s1>s2.
 */
function strcoll($str1,$str2)
{
	return 0;
}

/**
 * Find length of initial segment not matching mask.
 *
 * @param  string		The subject string.
 * @param  string		The string of stop characters.
 * @return integer	The length.
 */
function strcspn($str1,$str2)
{
	return 0;
}

/**
 * Case-insensitive strstr.
 *
 * @param  string	Haystack.
 * @param  string	Needle.
 * @return string	All of haystack from the first occurrence of needle to the end.
 */
function stristr($haystack,$needle)
{
	return '';
}

/**
 * Case insensitive string comparisons using a "natural order" algorithm.
 *
 * @param  string		The first string.
 * @param  string		The second string.
 * @return integer	<0 if s1<s2, 0 if s1=s2, >1 if s1>s2.
 */
function strnatcasecmp($str1,$str2)
{
	return 0;
}

/**
 * String comparisons using a "natural order" algorithm.
 *
 * @param  string		The first string.
 * @param  string		The second string.
 * @return integer	<0 if s1<s2, 0 if s1=s2, >1 if s1>s2.
 */
function strnatcmp($str1,$str2)
{
	return 0;
}

/**
 * Binary safe case-insensitive string comparison of the first n characters.
 *
 * @param  string		The first string.
 * @param  string		The second string.
 * @param  integer	Up to this length (n).
 * @return integer	<0 if s1<s2, 0 if s1=s2, >1 if s1>s2.
 */
function strncasecmp($str1,$str2,$len)
{
	return 0;
}

/**
 * Binary safe string comparison of the first n characters.
 *
 * @param  string		The first string.
 * @param  string		The second string.
 * @param  integer	Up to this length (n).
 * @return integer	<0 if s1<s2, 0 if s1=s2, >1 if s1>s2.
 */
function strncmp($str1,$str2,$len)
{
	return 0;
}

/**
 * Find the last occurrence of a character in a string.
 *
 * @param  string	Haystack.
 * @param  string	Needle (string of length 1).
 * @length 1
 * @return string	The portion of haystack which starts at the last occurrence of needle and goes until the end of haystack.
 */
function strrchr($haystack,$needle)
{
	return '';
}

/**
 * Reverse a string.
 *
 * @param  string	String to reverse.
 * @return string	Reversed string.
 */
function strrev($string)
{
	return '';
}

/**
 * Find length of initial segment matching mask.
 *
 * @param  string	String to work upon.
 * @param  string	String consisting of alternative characters to require along our run.
 * @return string	The length of the initial segment of string which consists entirely of characters in mask.
 */
function strspn($string,$mask)
{
	return '';
}

/**
 * Replace text within a portion of a string.
 *
 * @param  string		The subject string.
 * @param  string		The replacement string.
 * @param  integer	The start position of what's being replaced.
 * @param  ?integer  The run-length of what is being replaced (NULL: go to end of string).
 * @return string		A copy of string delimited by the start and (optionally) length parameters with the string given in replacement.
 */
function substr_replace($string,$replacement,$start,$length=NULL)
{
	return '';
}

/**
 * Calculate the tangent of an angle.
 *
 * @param  float	The angle in radians.
 * @return float	The tangent.
 */
function tan($arg)
{
	return 0.0;
}

/**
 * Unpack data from binary string.
 *
 * @param  string	The formatting string for unpacking.
 * @param  string	The data to unpack.
 * @return ~array	The unpacked data. (false: error)
 */
function unpack($format,$data)
{
	return array();
}

/**
 * Compares two "PHP-standardized" version number strings.
 *
 * @param  string		First version number.
 * @param  string		Second version number.
 * @param  ?string	The operator to compare with (NULL: unified).
 * @return mixed		For unified: -1 if v1<v2, 0 if v1=v2, 1 if v1>v2. Else BINARY or boolean.
 */
function version_compare($version1,$version2,$compare_symbol=NULL)
{
	return 0;
}

/**
 * Get the type of a variable.
 *
 * @param  mixed	The variable.
 * @return string	The type.
 */
function gettype($var)
{
	return '';
}

/**
 * Gets the version of the current Zend engine.
 *
 * @return string	The version of the currently running Zend Engine.
 */
function zend_version()
{
	return '';
}

/*!ROADSEND*
 * Gets the Zend guid.
 *
 * @return string	The ID which can be used to display the Zend logo using the built-in image.
 */
/*function zend_logo_guid()
{
}*/

/**
 * Get current column number for an XML parser.
 *
 * @param  resource  A reference to the XML parser to get column number from.
 * @return ~integer  Which column on the current line the parser is currently at. (false: error)
 */
function xml_get_current_column_number($parser)
{
	return 0;
}

/**
 * Create an XML parser.
 *
 * @param  ?string	Encoding (NULL: PHP4: as-for-input/PHP5: autodetect).
 * @return ~resource XML parser (false: could not create, happens on default PHP5 on Windows). (false: error)
 */
function xml_parser_create($encoding=NULL)
{
	return array();
}

/**
 * Get options from an XML parser.
 *
 * @param  resource  Parser.
 * @param  integer	Option.
 * @return mixed		Value.
 */
function xml_parser_get_option($parser,$option)
{
	return 0;
}

/**
 * Parse XML data into an array structure.
 *
 * @param  resource  The parser.
 * @param  string		The XML.
 * @param  array		Where to put the values.
 * @param  ?array		Where to put the indices into the XML for where the values are at (NULL: don't collect). Note that this is actually passed by reference, but is also optional.
 * @return BINARY		0 is failure, 1=pass.
 */
function xml_parse_into_struct($parser,$data,&$values,$index=NULL)
{
	return 1;
}

/**
 * Set up default handler.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback.
 * @return boolean	Success status.
 */
function xml_set_default_handler($parser,$callback)
{
	return true;
}

/**
 * Set up external entity reference handler.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback.
 * @return boolean	Success status.
 */
function xml_set_external_entity_ref_handler($parser,$callback)
{
	return true;
}

/**
 * Set up notation declaration handler.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback.
 * @return boolean	Success status.
 */
function xml_set_notation_decl_handler($parser,$callback)
{
	return true;
}

/**
 * Set up processing instruction (PI) handler.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback.
 * @return boolean	Success status.
 */
function xml_set_processing_instruction_handler($parser,$callback)
{
	return true;
}

/**
 * Set up unparsed entity declaration handler.
 *
 * @param  resource  XML parser.
 * @param  mixed		The callback.
 * @return boolean	Success status.
 */
function xml_set_unparsed_entity_decl_handler($parser,$callback)
{
	return true;
}

/**
 * Dumps information about a variable.
 *
 * @param  mixed	Data.
 */
function var_dump($expression)
{
}

/**
 * Output a formatted string.
 *
 * @param  string		Formatting string.
 * @param  array		Arguments.
 * @return integer	Length of outputed string.
 */
function vprintf($format,$args)
{
	return 0;
}

/**
 * Return a formatted string.
 *
 * @param  string	Formatting string.
 * @param  array	Arguments.
 * @return string	Fixed string.
 */
function vsprintf($format,$args)
{
	return '';
}

/**
 * Sets access and modification time of file.
 *
 * @param  PATH		File to touch.
 * @param  ?TIME		New modification time (NULL: do not change).
 * @param  ?TIME		New access time (NULL: do not change).
 * @return boolean	Success status.
 */
function touch($filename,$time=NULL,$atime=NULL)
{
	return true;
}

/**
 * Hyperbolic tangent.
 *
 * @param  float	In.
 * @return float	Out.
 */
function tanh($in)
{
	return 0.0;
}

/**
 * Hyperbolic sine.
 *
 * @param  float	In.
 * @return float	Out.
 */
function sinh($in)
{
	return 0.0;
}

/**
 * Delay execution.
 *
 * @param  integer	Time in seconds.
 */
function sleep($sec)
{
}

/**
 * Calculate the soundex key of a string.
 *
 * @param  string	Input.
 * @return string	Soundex.
 */
function soundex($input)
{
	return '';
}

/*!ROADSEND*
 * Parses input from a string according to a format.
 *
 * @param  string	Input string.
 * @param  string	Formatting string.
 * @return array	The values.
 */
/*function sscanf($string,$format)
{
	return array();
}*/

/**
 * Un-quote string quoted with addcslashes.
 *
 * @param  string	In.
 * @return string	Out.
 */
function stripcslashes($in)
{
	return '';
}

/**
 * Execute an external program and display the output.
 *
 * @param  string		Command to execute.
 * @param  ?integer  Place to put return value (NULL: not collected). Note that this is actually passed by reference, but is also optional.
 * @return ~string	Output (false: error).
 */
function system($commend,$ret_var=NULL)
{
	return '';
}

/**
 * Output a gz-file.
 *
 * @param  PATH		Path to read from.
 * @return ~integer  Number of uncompressed bytes handled. (false: error)
 */
function readgzfile($filename)
{
	return 0;
}

/**
 * Restores the previous error handler function.
 */
function restore_error_handler()
{
}

/**
 * Rewind the position of a file pointer.
 *
 * @param  resource  File handle.
 * @return boolean	Success status.
 */
function rewind($handle)
{
	return true;
}

/**
 * Rewind directory handle.
 *
 * @param  resource  Directory handle.
 */
function rewinddir($handle)
{
}

/**
 * Convert a quoted-printable string to an 8 bit string.
 *
 * @param  string	In.
 * @return string	Out.
 */
function quoted_printable_decode($in)
{
	return '';
}

/**
 * Quote meta characters. Returns a version of str with a backslash character (\) before every character that is among these: . \ + * ? [ ^ ] ( $ ).
 *
 * @param  string	In.
 * @return string	Out.
 */
function quotemeta($in)
{
	return '';
}

/**
 * Calculates the exponent of e.
 *
 * @param  float	Arg.
 * @return float	Result.
 */
function exp($arg)
{
	return 0.0;
}

/*!ROADSEND*
 * Calculate the hash value needed by EZMLM mailing lists in a MySQL database.
 *
 * @param  string		The email address that's being hashed.
 * @return integer	Hash.
 */
/*function ezmlm_hash($addr)
{
	return 0;
}*/

/**
 * Combined linear congruential generator.
 *
 * @return float	Random number.
 */
function lcg_value()
{
	return 0.0;
}

/**
 * Get the local time.
 *
 * @param  ?TIME		Timestamp (NULL: now).
 * @param  boolean	If set to FALSE or not supplied than the array is returned as a regular, numerically indexed array. If the argument is set to TRUE then localtime() is an associative array containing all the different elements of the structure returned by the C function call to localtime.
 * @return array		Components.
 */
function localtime($timestamp,$associative=false)
{
	return array();
}

/**
 * Quote string with slashes in a C style.
 *
 * @param  string	Input string.
 * @param  string	Chars to convert.
 * @return string	Result.
 */
function addcslashes($str,$charlist)
{
	return '';
}

/**
 * Filters elements of an array using a callback function.
 *
 * @param  array	In.
 * @param  ?mixed	The filter function callback (NULL: filter out false's).
 * @return array	Out.
 */
function array_filter($input,$callback=NULL)
{
	return array();
}

/**
 * Applies the callback to the elements of the given array.
 *
 * @param  mixed	Callback map function.
 * @param  array	In.
 * @return array	Out.
 */
function array_map($callback,$array)
{
	return array();
}

/**
 * Add all the elements of an array.
 *
 * @param  array	In.
 * @return mixed	The sum (float or integer).
 */
function array_sum($array)
{
	return array();
}

/**
 * Merges the elements of one or more arrays together so that the values of one are appended to the end of the previous one. It returns the resulting array.
 * If the input arrays have the same string keys, then the values for these keys are merged together into an array, and this is done recursively, so that if one of the values is an array itself, the function will merge it with a corresponding entry in another array too. If, however, the arrays have the same numeric key, the later value will not overwrite the original value, but will be appended.
 *
 * @param  array	First array to merge.
 * @param  array	Second array to merge.
 * @param  ?array	Third array to merge (NULL: not this one).
 * @param  ?array	Fourth array to merge (NULL: not this one).
 * @param  ?array	Fifth array to merge (NULL: not this one).
 * @return array	Result.
 */
function array_merge_recursive($array1,$array2,$array3=NULL,$array4=NULL,$array5=NULL)
{
	return array();
}

/*!ROADSEND*
 * Sort multiple or multi-dimensional array.
 *
 * @param  array		Array to sort.
 * @param  ?integer  Argument code (NULL: none given).
 * @return array		Result.
 */
/*function array_multisort($array,$args=NULL)
{
	return array();
}*/

/**
 * Pad array to the specified length with a value.
 *
 * @param  array		Input.
 * @param  integer	Pad size.
 * @param  mixed		Pad value.
 * @return array		Output.
 */
function array_pad($input,$pad_size,$pad_value)
{
	return array();
}

/**
 * Iteratively reduce the array to a single value using a callback function.
 *
 * @param  array		Input.
 * @param  mixed		Process function.
 * @param  ?integer  Initial value (NULL: no initial).
 * @return ?integer  Result (NULL: no initial given, and empty array given).
 */
function array_reduce($input,$callback,$initial=NULL)
{
	return 0;
}

/**
 * Apply a user function to every member of an array .
 *
 * @param  array		Data.
 * @return boolean	Success status.
 */
function array_walk(&$array)
{
	return true;
}

/**
 * Arc tangent of two variables.
 *
 * @param  float	First.
 * @param  float	Second.
 * @return float	Result.
 */
function atan2($x,$y)
{
	return 0.0;
}

/**
 * Gets character from file pointer.
 *
 * @param  resource  Handle.
 * @return ~string	Character. (false: error)
 */
function fgetc($handle)
{
	return '';
}

/**
 * Gets line from file pointer and parse for CSV fields.
 *
 * @param  resource  File handle.
 * @param  integer	Maximum length of line.
 * @param  string		Delimiter.
 * @return ~array		Line. (false: error)
 */
function fgetcsv($handle,$length,$delimiter=',')
{
	return array();
}

/**
 * Gets line from file pointer and strip HTML tags.
 *
 * @param  resource  File handle.
 * @param  integer	Maximum length of line.
 * @param  string		Allowable HTML tags separated by spaces.
 * @return ~string	Line. (false: error)
 */
function fgetss($handle,$length,$allowable_tags='')
{
	return '';
}

/**
 * Gets file type.
 *
 * @param  PATH		Filename.
 * @return ~string	Result (fifo, char, dir, block, link, file, and unknown). (false: error)
 */
function filetype($file)
{
	return '';
}

/**
 * Parses input from a file according to a format.
 *
 * @param  resource  File handle.
 * @param  string		Formatting string.
 * @return array		Data.
 */
function fscanf($handle,$format)
{
	return array();
}

/**
 * Gets information about a file using an open file pointer.
 *
 * @param  resource  File handle.
 * @return array		Map of status information.
 */
function fstat($handle)
{
	return array();
}

/**
 * Changes to the parent directory.
 *
 * @param  resource  FTP handle.
 * @return boolean	Success status.
 */
function ftp_cdup($ftp_stream)
{
	return true;
}

/**
 * Downloads a file from the FTP server and saves to an open file.
 *
 * @param  resource  FTP handle.
 * @param  resource  File handle.
 * @param  PATH		Remote file.
 * @param  integer	Transfer mode (FTP_ASCII or FTP_BINARY).
 * @return boolean	Success status.
 */
function ftp_fget($ftp_stream,$file_handle,$remote_file,$mode)
{
	return true;
}

/**
 * Downloads a file from the FTP server.
 *
 * @param  resource  FTP handle.
 * @param  PATH		Local file.
 * @param  PATH		Remote file.
 * @param  integer	Transfer mode (FTP_ASCII or FTP_BINARY).
 * @return boolean	Success status.
 */
function ftp_get($ftp_stream,$local_file,$remote_file,$mode)
{
	return true;
}

/**
 * Turns passive mode on or off.
 *
 * @param  resource  The link identifier of the FTP connection.
 * @param  boolean	If TRUE, the passive mode is turned on, else it's turned off.
 * @return boolean	Success status.
 */
function ftp_pasv($ftp_stream,$pasv)
{
	return true;
}

/**
 * Returns the current directory name.
 *
 * @param  resource  The link identifier of the FTP connection.
 * @return ~string	Current directory name. (false: error)
 */
function ftp_pwd($ftp_stream)
{
	return '';
}

/**
 * Returns a detailed list of files in the given directory.
 *
 * @param  resource  The link identifier of the FTP connection.
 * @param  PATH		The directory path.
 * @return ~array	 	Each element corresponds to one line of text. (false: error)
 */
function ftp_rawlist($ftp_stream,$directory)
{
	return array();
}

/**
 * Returns the system type identifier of the remote FTP server.
 *
 * @param  resource  The link identifier of the FTP connection.
 * @return ~string	System type. (false: error)
 */
function ftp_systype($ftp_stream)
{
	return '';
}

/**
 * Truncates a file to a given length.
 *
 * @param  resource  File handle.
 * @param  integer	Cut off size.
 * @return boolean	Success status (< PHP4.3, this is a BINARY).
 */
function ftruncate($file,$size)
{
	return true;
}

/**
 * Return an item from the argument list.
 *
 * @param  integer	Argument number.
 * @return mixed		Argument.
 */
function func_get_arg($arg_num)
{
	return '';
}

/**
 * Returns an array comprising a function's argument list.
 *
 * @return array	List of arguments.
 */
function func_get_args()
{
	return array();
}

/**
 * Returns the number of arguments passed to the function.
 *
 * @return integer	Number of arguments.
 */
function func_num_args()
{
	return 0;
}

/**
 * Parse a configuration file.
 *
 * @param  PATH		The file path.
 * @param  boolean	Whether to process sections.
 * @return ~array	 	Map of Ini file data (2d if processed sections). (false: error)
 */
function parse_ini_file($filename,$process_sections=false)
{
	return array();
}

/**
 * Parses the string into variables.
 *
 * @param  string	Query string to parse.
 * @param  array	Target for variable mappings.
 */
function parse_str($str,&$arr)
{
}

/**
 * Execute an external program and display raw output.
 *
 * @param  PATH		The command that will be executed.
 * @param  ?integer  Command success status (NULL: don't collect). Note that this is actually passed by reference, but is also optional.
 */
function passthru($command,$return_var=NULL)
{
}

/**
 * Closes process file pointer.
 *
 * @param  resource  Process handle.
 * @return integer	Termination status.
 */
function pclose($handle)
{
	return 0;
}

/*!ROADSEND*
 * Open persistent Internet or Unix domain socket connection.
 *
 *
 * @param  string		The target domain/IP to open.
 * @param  integer	The target port to open.
 * @param  integer	Where any error number will be put.
 * @param  string		Whether any error string will be put.
 * @param  ?float		How long to wait until timeout (NULL: no timeout).
 * @return ~resource The handle (false: error). (false: error)
 */
/*function pfsockopen($target,$port,&$errno,&$errstr,$timeout=NULL)
{
	return array();
}*/

/**
 * Tells whether the filename is executable.
 *
 * @param  PATH		Filename.
 * @return boolean	Whether it is.
 */
function is_executable($filename)
{
	return true;
}

/**
 * Finds whether a variable is a scalar (integer, float, string or boolean).
 *
 * @param  mixed		Variable.
 * @return boolean	Whether it is.
 */
function is_scalar($var)
{
	return true;
}

/**
 * Find whether the object has this class as one of its parents.
 *
 * @param  mixed		Object to check whether is an instance.
 * @param  string		Class name to check against.
 * @return boolean	Whether it is.
 */
function is_subclass_of($object,$class_name)
{
	return true;
}

/*!ROADSEND*
 * Calculate the metaphone key of a string.
 *
 * @param  string		String to do.
 * @param  integer	Phones value.
 * @return string		Metaphone key.
 */
/*function metaphone($string,$value)
{
	return '';
}*/

/**
 * Sort an array using a case insensitive "natural order" algorithm .
 *
 * @param  array		Array to sort.
 * @return boolean	Success status.
 */
function natcasesort(&$array)
{
	return true;
}

/**
 * Sort an array using a "natural order" algorithm.
 *
 * @param  array		Array to sort.
 * @return boolean	Success status.
 */
function natsort(&$array)
{
	return true;
}

/**
 * Inserts HTML line breaks before all newlines in a string.
 *
 * @param  string	In.
 * @return string	Out.
 */
function nl2br($in)
{
	return '';
}

/**
 * Return the length of the output buffer.
 *
 * @return ~integer  Output buffer length. (false: error)
 */
function ob_get_length()
{
	return 0;
}

/**
 * ob_start callback function to gzip output buffer.
 *
 * @param  string		Input string.
 * @param  integer	Irrelevant (we don't use this function directly anyway).
 * @return string		Filtered version.
 */
function ob_gzhandler($buffer,$mode)
{
	return '';
}

/**
 * Convert character encoding as output buffer handler.
 *
 * @param  string		Input string.
 * @param  integer	Irrelevant (we don't use this function directly anyway).
 * @return string		Filtered version.
 */
function ob_iconv_handler($buffer,$mode)
{
	return '';
}

/**
 * Turn implicit flush on/off .
 *
 * @param  integer	Flag (1 for on, 0 for off).
 */
function ob_implicit_flush($flag)
{
}

/**
 * Returns the type of interface between web server and PHP.
 *
 * @return string	SAPI name.
 */
function php_sapi_name()
{
	return '';
}

/*!ROADSEND*
 * Returns information about the operating system PHP is running on.
 *
 * @param  string	Type of info to get.
 * @set    a s n r v m
 * @return string	The info.
 */
/*function php_uname($mode='a')
{
	return '';
}*/

/**
 * Opens process file pointer.
 *
 * @param  string		Command to execute.
 * @param  string		Access mode.
 * @set    r r+ w w+ a a+
 * @return ~resource Socket (false: error).
 */
function popen($command,$mode)
{
	return array();
}

/**
 * Output a formatted string.
 *
 * @param  string	Formatting string.
 * @param  ?mixed	Argument (NULL: not given).
 * @param  ?mixed	Argument (NULL: not given).
 * @param  ?mixed	Argument (NULL: not given).
 * @param  ?mixed	Argument (NULL: not given).
 * @param  ?mixed	Argument (NULL: not given).
 * @return string	Assembled string.
 */
function printf($format,$arg1=NULL,$arg2=NULL,$arg3=NULL,$arg4=NULL,$arg5=NULL)
{
	return '';
}

/*!ROADSEND*
 * Convert from one Cyrillic character set to another.
 *
 * @param  string	Input.
 * @param  string	From.
 * @param  string	To.
 * @return string	Output.
 */
/*function convert_cyr_string($in,$from,$to)
{
	return '';
}*/

/**
 * Hyperbolic cosine.
 *
 * @param  float	Argument.
 * @return float	Result.
 */
function cosh($arg)
{
	return 0.0;
}

/**
 * Return information about characters used in a string.
 *
 * @param  string		The string which to work within.
 * @param  integer	Operation mode.
 * @set    0 1 2 3 4
 * @return mixed		Result, depending on mode used.
 */
function count_chars($string,$mode=0)
{
	return '';
}

/**
 * Returns the total size of a directory.
 *
 * @param  PATH		Where to look.
 * @return ~integer  The size (false: error). (actually, a float)
 */
function disk_total_space($directory)
{
	return 0;
}

/**
 * Run some code. Do not use unless absolutely needed.
 *
 * @param  string		Code to run.
 * @return mixed  	Result
 */
function eval($code)
{
	return 0;
}

/**
 * Get float value of a variable.
 *
 * @param  mixed	Probably a string value.
 * @return float	Float value.
 */
function doubleval($var)
{
	return 0.0;
}

/**
 * Get a list of IP addresses corresponding to a given Internet host name.
 *
 * @param  string		Hostname.
 * @return ~array		List of IP addresses (false: could not resolve).
 */
function gethostbynamel($hostname)
{
	return array();
}

/**
 * Get the size of an image.
 *
 * @param  PATH		Filename.
 * @param  ?array		Extra details will be put here (NULL: return-only). Note that this is actually passed by reference, but is also optional.
 * @return ~array	 	List of details: $width, $height, $type, $attr. (false: error)
 */
function getimagesize($filename,$image_info=NULL)
{
	return array();
}

/*!ROADSEND*
 * Gets time of last page modification.
 *
 * @return TIME		Last modification time.
 */
/*function getlastmod()
{
	return 0;
}*/

/**
 * Gets PHP's process ID.
 *
 * @return ~integer  Process ID. (false: error)
 */
function getmypid()
{
	return 0;
}

/**
 * Gets PHP's user ID.
 *
 * @return ~integer  User ID. (false: error)
 */
function getmyuid()
{
	return 0;
}

/**
 * Get current time.
 *
 * @return array	Map of time details.
 */
function gettimeofday()
{
	return array();
}

/*!ROADSEND*
 * Gets the value of a PHP configuration option.
 *
 * @param  string		Value name to get.
 * @return ~string	Value. (false: error)
 */
/*function get_cfg_var($varname)
{
	return '';
}*/

/**
 * Gets the current active configuration setting of magic_quotes_runtime.
 *
 * @return boolean	Current value (Actually BINARY, but boolean will work).
 */
function get_magic_quotes_runtime()
{
	return true;
}

/*!ROADSEND*
 * Extracts all meta tag content attributes from a file and returns an array.
 *
 * @param  PATH		Filename.
 * @return ~array	 	Map of meta information. (false: error)
 */
/*function get_meta_tags($filename)
{
	return array();
}*/

/**
 * Retrieves the parent class name for object or class.
 *
 * @param  object	Object to check.
 * @return string	Classname.
 */
function get_parent_class($object)
{
	return '';
}

/**
 * Returns an array with the names of included or required files.
 *
 * @return array	Included files.
 */
function get_included_files()
{
	return array();
}

/**
 * Returns the resource type.
 *
 * @param  resource  Resource to check.
 * @return string		The resource type.
 */
function get_resource_type($handle)
{
	return '';
}

/**
 * Compress a string.
 *
 * @param  string		Data to compress.
 * @param  integer	Compression level.
 * @return string		Compressed data.
 */
function gzcompress($data,$level)
{
	return '';
}

/**
 * Deflate a string.
 *
 * @param  string		Compressed data.
 * @param  integer	Compression level.
 * @return ~string	Uncompressed data. (false: error)
 */
function gzdeflate($data,$level)
{
	return '';
}

/**
 * Create a gzip compressed string.
 *
 * @param  string		In.
 * @param  integer	How much compression.
 * @range  1 9
 * @return string		Out.
 */
function gzencode($data,$level)
{
	return '';
}

/**
 * Read entire gz-file into an array.
 *
 * @param  PATH		The filename.
 * @return ~array	 	An array containing the file, one line per cell. (false: error)
 */
function gzfile($filename)
{
	return array();
}

/**
 * Inflate a deflated string.
 *
 * @param  string		The data compressed by gzdeflate().
 * @param  integer	Maximum length to read in.
 * @return string		Inflated (uncompressed) data.
 */
function gzinflate($data,$length)
{
	return '';
}

/**
 * Uncompress a compressed string.
 *
 * @param  string		The data compressed by gzcompress().
 * @param  integer	Maximum length to read in.
 * @return string		Uncompressed data.
 */
function gzuncompress($data,$length)
{
	return '';
}

/*!ROADSEND*
 * Convert logical Hebrew text to visual text.
 *
 * @param  string		In.
 * @param  ?integer  Maximum number of characters per line (NULL: no limit).
 * @return string		Out.
 */
/*function hebrev($hebrew_text,$max_chars_per_line=NULL)
{
	return '';
}*/

/*!ROADSEND*
 * Convert logical Hebrew text to visual text with newline conversion.
 *
 * @param  string		In.
 * @param  ?integer  Maximum number of characters per line (NULL: no limit).
 * @return string		Out.
 */
/*function hebrevc($hebrew_text,$max_chars_per_line=NULL)
{
	return '';
}*/

/*!ROADSEND*
 * Syntax highlighting of a file.
 *
 * @param  PATH		File to highlight.
 */
/*function highlight_file($file)
{
}*/

/**
 * Calculate the length of the hypotenuse of a right-angle triangle.
 *
 * @param  float	X.
 * @param  float	Y.
 * @return float	Result.
 */
function hypot($x,$y)
{
	return 0.0;
}

/**
 * Set whether a client disconnect should abort script execution.
 *
 * @param  boolean	Setting.
 * @return boolean	Previous setting.
 */
function ignore_user_abort($setting)
{
	return true;
}

/**
 * Get and/or set the current cache limiter.
 *
 * @param  ?string	New Setting (NULL: don't change).
 * @return string		Current setting.
 */
function session_cache_limiter($cache_limiter=NULL)
{
	return '';
}

/**
 * Decodes session data from a string.
 *
 * @param  string		Data to decode.
 * @return boolean	Success status.
 */
function session_decode($data)
{
	return true;
}

/**
 * Destroys all data registered to a session.
 */
function session_destroy()
{
}

/**
 * Encodes the current session data as a string.
 *
 * @return string	Session data.
 */
function session_encode()
{
	return '';
}

/**
 * Get the session cookie parameters.
 *
 * @return array	Data.
 */
function session_get_cookie_params()
{
	return array();
}

/**
 * Get and/or set the current session id.
 *
 * @param  ?string	New setting (NULL: don't change).
 * @return string		Current setting.
 */
function session_id($id=NULL)
{
	return '';
}

/**
 * Get and/or set the current session module.
 *
 * @param  ?string	New session module name (NULL: don't change).
 * @return string		Current session module name.
 */
function session_module_name($name=NULL)
{
	return '';
}

/**
 * Get and/or set the current session name.
 *
 * @param  ?string	New session name (NULL: don't change).
 * @return string		Current session name.
 */
function session_name($name=NULL)
{
	return '';
}

/**
 * Get and/or set the current session save path.
 *
 * @param  ?PATH	New session save path (NULL: don't change).
 * @return string	Current session save path.
 */
function session_save_path($path=NULL)
{
	return '';
}

/**
 * Set the session cookie parameters.
 *
 * @param  integer	Lifetime.
 * @param  ?string	Cookie path (NULL: no path limitation).
 * @param  ?string	Cookie domain (NULL: autodetect).
 */
function session_set_cookie_params($lifetime,$path=NULL,$domain=NULL)
{
}

/**
 * Sets user-level session storage functions.
 *
 * @param  mixed		Callback (open).
 * @param  mixed		Callback (close).
 * @param  mixed		Callback (read).
 * @param  mixed		Callback (write).
 * @param  mixed		Callback (destroy).
 * @param  mixed		Callback (garbage collection).
 * @return boolean	Success status.
 */
function session_set_save_handler($open,$close,$read,$write,$destroy,$gc)
{
	return true;
}

/**
 * Initialize session data.
 *
 * @return boolean	Success status.
 */
function session_start()
{
	return true;
}

/**
 * Set whether a client disconnect should abort script execution.
 *
 * @param  boolean	Setting.
 * @return boolean	Previous setting.
 */
function session_unset($foo)
{
	return true;
}

/**
 * Write session data and end session.
 */
function session_write_close()
{
}

/**
 * XSS detection helper function.
 *
 * @param  string		String to mark as escaped.
 */
function ocp_mark_as_escaped(&$var)
{
}

/**
 * XSS detection helper function.
 *
 * @param  string		String to test for being escaped.
 * @return boolean	Whether string is escaped.
 */
function ocp_is_escaped($var)
{
	return true;
}


