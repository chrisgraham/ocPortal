<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2012

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		core_rich_media
 */

/**
 * Standard code module initialisation function.
 */
function init__comcode_conversion()
{
	global $PREG_MATCH_OFFSET;
	$PREG_MATCH_OFFSET=(version_compare(phpversion(),'4.3.3')!=-1);

	if (!defined('SYMBOL_PARSE_NAME'))
	{
		define('SYMBOL_PARSE_NAME',0);
		define('SYMBOL_PARSE_PARAM',1);
	}
}

/**
 * Convert Comcode-Text to Comcode-XML.
 *
 * @param  LONG_TEXT		The comcode to convert
 * @param  boolean		Whether to not include a wrapper element (<comcode>)
 * @return LONG_TEXT		The converted comcode
 */
function comcode_text__to__comcode_xml($comcode,$skip_wrapper=false)
{
	require_code('comcode_xml');
	require_code('comcode_text');
	require_code('comcode_renderer');

	if (substr($comcode,0,8)=='<comcode')
	{
		if ($skip_wrapper) return str_replace('<comcode>','',str_replace('</comcode>','',$comcode));
		return $comcode;
	}

	$xml='';

	global $ALLOWED_ENTITIES,$CODE_TAGS,$DANGEROUS_TAGS,$VALID_COMCODE_TAGS,$BLOCK_TAGS,$POTENTIAL_JS_NAUGHTY_ARRAY,$TEXTUAL_TAGS,$LEET_FILTER,$IMPORTED_CUSTOM_COMCODE,$REPLACE_TARGETS;

	$len=strlen($comcode);

	require_lang('comcode');
	require_code('type_validation');

	if ((function_exists('set_time_limit')) && (ini_get('max_execution_time')!='0')) @set_time_limit(300);

	$comcode_dangerous=true;
	$comcode_dangerous_html=true;

	// Tag level
	$current_tag='';
	$attribute_map=array();
	$continuation='';
	$close=mixed();

	// Properties that come from our tag
	$white_space_area=true;
	$textual_area=true;
	$formatting_allowed=true;
	$in_html=false;
	$in_semihtml=false;
	$in_separate_parse_section=false; // Not escaped because it has to be passed to a secondary filter
	$in_code_tag=false;
	$lax=false;

	// Our state
	$status=CCP_NO_MANS_LAND;
	$tag_stack=array();
	$pos=0;
	$line_starting=true;
	$just_ended=false;
	$none_wrap_length=0;
	$just_new_line=true; // So we can detect lists starting right away
	$just_title=false;
	global $NUM_LINES;
	$NUM_LINES=0;
	$wrap_pos=60;
	$preparse_mode=false;
	$is_all_semihtml=false;

	$smilies=$GLOBALS['FORUM_DRIVER']->find_emoticons(); // We'll be needing the smiley array
	$shortcuts=array('(c)'=>'&copy;','(r)'=>'&reg;','--'=>'&ndash;','---'=>'&mdash;');

	// Text syntax possibilities, that get maintained as our cursor moves through the text block
	$list_indent=0;
	$list_type='ul';

	while ($pos<$len)
	{
		$next=$comcode[$pos];
		++$pos;

		// State machine
		switch ($status)
		{
			case CCP_NO_MANS_LAND:
				if ($next=='[')
				{
					// Look ahead to make sure it's a valid tag. If it's not then it's considered normal user input, not a tag at all
					$dif=(($pos<$len) && ($comcode[$pos]=='/'))?1:0;
					$ahead=substr($comcode,$pos+$dif,19);
					$equal_pos=strpos($ahead,'=');
					$space_pos=strpos($ahead,' ');
					$end_pos=strpos($ahead,']');
					$cl_pos=strpos($ahead,chr(10));
					if ($equal_pos===false) $equal_pos=22;
					if ($space_pos===false) $space_pos=22;
					if ($end_pos===false) $end_pos=22;
					if ($cl_pos===false) $cl_pos=22;
					$use_pos=min($equal_pos,$space_pos,$end_pos,$cl_pos);

					$potential_tag=strtolower(substr($ahead,0,$use_pos));
					if (($use_pos!=22) && ((!$in_html) || ($potential_tag=='html') || ($potential_tag=='semihtml')) && ((!$in_code_tag) || (isset($CODE_TAGS[$potential_tag]))))
					{
						if (!isset($VALID_COMCODE_TAGS[$potential_tag]))
						{
							if (!$IMPORTED_CUSTOM_COMCODE)
								_custom_comcode_import($GLOBALS['SITE_DB']);
						}
						if ((isset($VALID_COMCODE_TAGS[$potential_tag])) && (substr($ahead,0,2)!='i ')) // The "i" bit is just there to block a common annoyance: [i] doesn't take parameters and we don't want "[i think]" (for example) being parsed.
						{
							$close=false;
							$current_tag='';
							$xml.=$continuation;
							$continuation='';
							if (($potential_tag=='html') || ($potential_tag=='semihtml'))
							{
								list($close_list,$list_indent)=_convert_close_open_lists($list_indent);
								$xml.=$close_list;
							}
							$status=CCP_STARTING_TAG;
							continue;
						}
					}
				}

				if ((($in_html) || (($in_semihtml) && (($next=='<') || ($next=='>')))))
				{
					$ahead=substr($comcode,$pos-1,20);
					$ahead_lower=strtolower($ahead);

					if ($next==chr(10)) ++$NUM_LINES;

					$continuation.=$next;
				}
				else  // Not in HTML
				{
					// Text-format possibilities
					if (($just_new_line) && ($formatting_allowed))
					{
						$xml.=$continuation;
						$continuation='';

						// List
						$found_list=false;
						$old_list_indent=$list_indent;
						if (($pos+1<$len) && (is_numeric($next)) && ($comcode[$pos]==')') && ($comcode[$pos+1]==' '))
						{
							if (($list_indent!=0) && ($list_type=='ul'))
							{
								list($temp_tpl,$old_list_indent)=_close_open_lists($list_indent,$list_type);
								$xml.=$temp_tpl;
							}
							$list_indent=1;
							$found_list=true;
							$scan_pos=$pos;
							$list_type='1';
						}
						elseif (($pos+1<$len) && (ord($next)>=ord('a')) && (ord($next)<=ord('z')) && ($comcode[$pos]==')') && ($comcode[$pos+1]==' '))
						{
							if (($list_indent!=0) && ($list_type=='ul'))
							{
								list($temp_tpl,$old_list_indent)=_close_open_lists($list_indent,$list_type);
								$xml.=$temp_tpl;
							}
							$list_indent=1;
							$found_list=true;
							$scan_pos=$pos;
							$list_type='a';
						}
						elseif ($next==' ')
						{
							if (($old_list_indent!=0) && ($list_type!='ul'))
							{
								list($temp_tpl,$old_list_indent)=_close_open_lists($list_indent,$list_type);
								$xml.=$temp_tpl;
							}

							$scan_pos=$pos-1;
							$list_indent=0;
							while ($scan_pos<$len)
							{
								$scan_next=$comcode[$scan_pos];
								if (($scan_next=='-') && ($comcode[$scan_pos+1]==' '))
								{
									$found_list=true;
									break;
								} else
								{
									if ($scan_next==' ') ++$list_indent; else break;
								}
								++$scan_pos;
							}
							if (!$found_list) $list_indent=0;
						}
						// Rule?
						else
						{
							list($close_list,$list_indent)=_convert_close_open_lists($list_indent);
							$xml.=$close_list;

							if (($next=='-') && (!$just_title))
							{
								$scan_pos=$pos;
								$found_rule=true;
								while ($scan_pos<$len)
								{
									$scan_next=$comcode[$scan_pos];
									if ($scan_next!='-')
									{
										if ($scan_next==chr(10))
										{
											++$NUM_LINES;
											break;
										} else $found_rule=false;
									}
									++$scan_pos;
								}
								if ($found_rule)
								{
									$xml.='<rule />';
									$pos=$scan_pos+1;
									$just_ended=true;
									$none_wrap_length=0;
									continue;
								}
							}
						}

						// List handling
						if (($list_indent==$old_list_indent) && ($old_list_indent!=0))
						{
							$xml.='</listElement>';
						}
						for ($i=$list_indent;$i<$old_list_indent;++$i) // Close any ended
						{
							$xml.='</listElement>';
							$xml.='</list>';
						}
						if (($list_indent<$old_list_indent) && ($list_indent!=0)) // Go down one final level, because the list tag must have been nested within an li tag (we closed open li tags recursively except for the final one)
						{
							$xml.='</listElement>';
						}
						if ($found_list)
						{
							if ((($list_indent-$old_list_indent)>1) && (!$lax))
							{
								$error=comcode_parse_error($preparse_mode,array('CCP_LIST_JUMPYNESS'),$pos,$comcode);
								return $error->evaluate();
							}
							for ($i=$old_list_indent;$i<$list_indent;++$i) // Or open any started
							{
								switch ($list_type)
								{
									case 'ul':
										$xml.='<list>';
										break;
									case '1':
										$xml.='<list type="1">';
										break;
									case 'a':
										$xml.='<list type="a">';
										break;
								}
								if ($i<$list_indent-1) $xml.='<listElement>';
							}
							$xml.='<listElement>';
							$just_ended=true;
							$none_wrap_length=0;
							$next='';
							$pos=$scan_pos+2;
						}
					}

					if (($next==chr(10)) && ($white_space_area) && (!$just_ended)) // Hard-new-lines
					{
						++$NUM_LINES;
						$line_starting=true;
						$xml.=$continuation;
						$continuation='';
						$just_new_line=true;
						$none_wrap_length=0;
						if ($list_indent==0)
						{
							$xml.='<br />'.chr(10);
						}
					}
					else
					{
						$just_new_line=false;

						if (($next==' ') && ($white_space_area))
						{
							if (($line_starting) || (($pos!=0) && ($comcode[$pos-2]==' '))) // Hard spaces
							{
								$next='&nbsp;';
								++$none_wrap_length;
							} else $none_wrap_length=0;
							$continuation.=$next;
						}
						elseif (($next=="\t") && ($white_space_area))
						{
							$xml.=$continuation;
							$continuation='';
							$tab_tpl=do_template('COMCODE_TEXTCODE_TAB'); // &nbsp;&nbsp;&nbsp;&nbsp;
							$_tab_tpl=$tab_tpl->evaluate();
							$none_wrap_length+=strlen($_tab_tpl);
							$xml.=$tab_tpl->evaluate();
						} else
						{
							if (($next==' ') || ($next=="\t") || ($just_ended)) $none_wrap_length=0; else
							{
								if ((!is_null($wrap_pos)) && ($none_wrap_length>=$wrap_pos) && ($textual_area) && (!$in_semihtml))
								{
									$xml.=$continuation;
									$continuation='';
									$xml.='<br />'.chr(10);
									$none_wrap_length=0;
								} elseif ($textual_area) ++$none_wrap_length;
							}
							$line_starting=false;
							$just_ended=false;

							$differented=false; // If somehow via lookahead we've changed this to HTML and thus won't use it in raw form

							// Symbol lookahead
							if (!$in_code_tag)
							{
								if (($next=='{') && (($comcode[$pos]=='$') || ($comcode[$pos]=='+') || ($comcode[$pos]=='!')) && ($comcode_dangerous))
								{
									$xml.=$continuation;
									$continuation='';
									if ($comcode[$pos]=='+')
									{
										$p_end=$pos+5;
										while ($p_end<$len)
										{
											$p_portion=substr($comcode,$pos-1,$p_end-($pos-1)+5);
											if (substr_count($p_portion,'{+START')==substr_count($p_portion,'{+END')) break;
											$p_end++;
										}
										$p_len=1;
										while ($pos+$p_len<$len)
										{
											$p_portion=substr($comcode,$pos-1,$p_len);
											if (substr_count($p_portion,'{')==substr_count($p_portion,'}')) break;
											$p_len++;
										}
										$p_len--;
										$p_portion=substr($comcode,$pos+$p_len,$p_end-($pos+$p_len));
										$_ret=template_to_tempcode_static(substr($comcode,$pos-1,$p_len+1).'!'.substr($comcode,$p_end,6));
										$ret='<directive type="'.escape_html($_ret->bits[0][2]).'">';
										foreach ($_ret->bits[0][3] as $val)
										{
											$ret.='<directiveParam>'.escape_html($val->evaluate()).'</directiveParam>';
										}
										$ret.=comcode_text__to__comcode_xml($p_portion,true);
										$ret.='</directive>';
										$pos=$p_end+6;
									} else
									{
										$_ret=new ocp_tempcode();
										$_ret->bits=array(read_single_uncompiled_variable($comcode,$pos,$len));
										if ($_ret->bits[0][1]==TC_SYMBOL)
										{
											$ret='<symbol>';
											if (isset($_ret->bits[0][3]))
											{
												foreach ($_ret->bits[0][3] as $val)
												{
													$ret.='<symbolParam>'.escape_html($val).'</symbolParam>';
												}
											}
											$ret.=$_ret->bits[0][2].'</symbol>';
										} else
										{
											$ret='<language>';
											if (isset($_ret->bits[0][3]))
											{
												foreach ($_ret->bits[0][3] as $val)
												{
													$ret.='<languageParam>'.escape_html($val).'</languageParam>';
												}
											}
											$ret.=$_ret->bits[0][2].'</language>';
										}
									}
									$differented=true;
									$xml.=$ret;
								}
							}

							// Escaping of comcode tag starts lookahead
							if (($next=='\\') && (!$in_code_tag)) // We are changing \[ to [ with the side-effect of blocking a tag start. To get \[ literal, we need the symbols \\[... and add extra \-pairs as needed. We are only dealing with \ and [ (update: and now {) here, it's not a further extended means of escaping.
							{
								if (($pos!=$len) && ($comcode[$pos]=='"'))
								{
									$continuation.='"';
									++$pos;
									$differented=true;
								}
								elseif (($pos!=$len) && ($comcode[$pos]=='['))
								{
									$continuation.='[';
									++$pos;
									$differented=true;
								}
								elseif (($pos!=$len) && ($comcode[$pos]=='{'))
								{
									$continuation.='{';
									++$pos;
									$differented=true;
								}
								elseif (($pos==$len) || ($comcode[$pos]=='\\'))
								{
									$continuation.='\\';
									++$pos;
									$differented=true;
								}
							}

							// Smiley lookahead
							if (!$differented)
							{
								if ((($textual_area) || ($in_semihtml)) && (trim($next)!=''))
								{
									foreach ($smilies as $smiley=>$imgcode)
									{
										if ($in_semihtml) $smiley=' '.$smiley.' ';

										if ($next==$smiley[0]) // optimisation
										{
											if (substr($comcode,$pos-1,strlen($smiley))==$smiley)
											{
												$xml.=$continuation;
												$continuation='';
												$pos+=strlen($smiley)-1;
												$differented=true;
												$xml.='<emoticon>'.escape_html($imgcode).'</emoticon>';
												break;
											}
										}
									}
								}
							}
							if (($textual_area) && (trim($next)!='') && (!$differented) && (addon_installed('cedi')))
							{
								// Wiki+ pages
								if (($pos<$len) && ($next=='['))
								{
									$matches=array();
									if (preg_match('#^\[([^\[\]]*)\]\]#',substr($comcode,$pos,40),$matches)!=0)
									{
										$wiki_page_name=$matches[1];
										$xml.=$continuation;
										$continuation='';
										$hash_pos=strpos($wiki_page_name,'#');
										if ($hash_pos!==false)
										{
											$jump_to=substr($wiki_page_name,$hash_pos+1);
											$wiki_page_name=substr($wiki_page_name,0,$hash_pos);
											$xml.='<wiki anchor="'.escape_html($jump_to).'">'.escape_html($wiki_page_name).'</wiki>';
										} else
										{
											$xml.='<wiki>'.escape_html($wiki_page_name).'</wiki>';
										}
										$pos+=strlen($matches[1])+3;
										$differented=true;
									}
								}

								// Usernames
								if (($pos<$len) && ($next=='{'))
								{
									$matches=array();
									if (preg_match('#^\{([^"{}&\'\$<>]*)\}\}#',substr($comcode,$pos,40),$matches)!=0)
									{
										$xml.=$continuation;
										$continuation='';

										$username=$matches[1];
										if ($username[0]=='?')
										{
											$username=substr($username,1);
											$xml.='<member boxed="1">'.escape_html($username).'</member>';
										} else
										{
											$xml.='<member>'.escape_html($username).'</member>';
										}

										$pos+=strlen($matches[1])+3;
										$differented=true;
									}
								}

								if ((!$in_code_tag) && (trim($next)!='') && (!$differented))
								{
									// Shortcut lookahead
									if (!$differented)
									{
										foreach ($shortcuts as $code=>$replacement)
										{
											if (($next==$code[0]) && (substr($comcode,$pos-1,strlen($code))==$code))
											{
												$xml.=$continuation;
												$continuation='';
												$pos+=strlen($code)-1;
												$differented=true;
												$xml.=$replacement;
												break;
											}
										}
									}
								}

								// Table syntax
								if (!$differented)
								{
									if (($pos<$len) && ($comcode[$pos]=='|'))
									{
										$end_tbl=strpos($comcode,chr(10).'|}',$pos);
										if ($end_tbl!==false)
										{
											$end_fst_line_pos=strpos($comcode,chr(10),$pos);
											$caption=substr($comcode,$pos+2,max($end_fst_line_pos-$pos-2,0));
											$pos+=strlen($caption)+1;

											$rows=preg_split('#(\|-|\|\})#Um',substr($comcode,$pos,$end_tbl-$pos));
											if ((count($rows)==1) && ($caption=='floats'))
											{
												$cells=preg_split('/(\n\! | \!\! |\n\| | \|\| )/',$rows[0],-1,PREG_SPLIT_DELIM_CAPTURE);
												array_shift($cells); // First one is non-existant empty
												$spec=true;
												// Find which to float
												$to_float=NULL;
												foreach ($cells as $i=>$cell)
												{
													if (!$spec)
													{
														if ((strpos($cell,'!')!==false) || (is_null($to_float))) $to_float=$i;
													}
													$spec=!$spec;
												}

												$xml.='<float>';

												// Do floated one
												$xml.='<fh>';
												$xml.=comcode_text__to__comcode_xml(rtrim($cells[$to_float]),true);
												$xml.='</fh>';
												// Do non-floated ones
												foreach ($cells as $i=>$cell)
												{
													if (($i%2==1) && ($i!=$to_float))
													{
														$xml.='<fd>';
														$xml.=comcode_text__to__comcode_xml(rtrim($cells[$to_float]),true);
														$xml.='</fd>';
													}
												}

												$xml.='</float>';
											} else
											{
												$xml.='<table summary="'.escape_html($caption).'">';
												foreach ($rows as $table_row)
												{
													$xml.='<tr>';

													$cells=preg_split('/(\n\! | \!\! |\n\| | \|\| )/',$table_row,-1,PREG_SPLIT_DELIM_CAPTURE);
													array_shift($cells); // First one is non-existant empty
													$spec=true;
													$c_type='';
													foreach ($cells as $cell)
													{
														if ($spec)
														{
															$c_type=(strpos($cell,'!')!==false)?'th':'td';
														} else
														{
															$xml.='<'.$c_type.'>';
															$xml.=comcode_text__to__comcode_xml(rtrim($cell),true);
															$xml.='</'.$c_type.'>';
														}
														$spec=!$spec;
													}

													$xml.='</tr>';
												}

												$xml.='</table>';
											}

											$pos=$end_tbl+3;
											$differented=true;
										}
									}
								}

								// Link lookahead
								if (!$differented)
								{
									if ((!$in_semihtml) && ($next=='h') && ((substr($comcode,$pos-1,strlen('http://'))=='http://') || (substr($comcode,$pos-1,strlen('https://'))=='https://') || (substr($comcode,$pos-1,strlen('ftp://'))=='ftp://')))
									{
										list($link_end_pos,$auto_link)=detect_link($comcode,$pos);
										$xml.=$continuation;
										$continuation='';
										$downloaded_at_link=http_download_file($auto_link,3000,false);
										$link_captions_title='';
										if (is_string($downloaded_at_link))
										{
											$matches=array();
											if (preg_match('#<title>\s*(.*)\s*</title>#',$downloaded_at_link,$matches)!=0)
											{
												require_code('character_sets');

												$link_captions_title=@html_entity_decode(convert_to_internal_encoding($matches[1]),ENT_QUOTES,get_charset());
											}
										}
										$xml.='<url param="'.escape_html($auto_link).'">'.escape_html($link_captions_title).'</url>';
										$pos+=$link_end_pos-$pos;
										$differented=true;
										break;
									}
								}
							}

							if (!$differented)
							{
								if ((!$in_separate_parse_section) && ((!$in_semihtml) || ((!$comcode_dangerous) && (!$is_all_semihtml)))) // Display char. We try and support entities
								{
									if ($next=='&')
									{
										$ahead=substr($comcode,$pos,20);
										$ahead_lower=strtolower($ahead);
										$matches=array();
										$entity=preg_match('#(\#)?([\w]*);#',$ahead_lower,$matches)!=0; // If it is a SAFE entity, use it

										if ($entity)
										{
											if (($matches[1]=='') && (isset($ALLOWED_ENTITIES[$matches[2]])))
											{
												$pos+=strlen($matches[2])+1;
												$continuation.='&'.$matches[2].';';
											} elseif ((is_numeric($matches[2])) && ($matches[1]=='#'))
											{
												$matched_entity=intval(base_convert($matches[1],16,10));
												if (($matched_entity<127) && (array_key_exists(chr($matched_entity),$POTENTIAL_JS_NAUGHTY_ARRAY)))
												{
													$continuation.=escape_html($next);
												} else
												{
													$pos+=strlen($matches[2])+2;
													$continuation.='&#'.$matches[2].';';
												}
											} else $continuation.='&amp;';
										} else $continuation.='&amp;';
									} else $continuation.=escape_html($next);
								} else
								{
									$continuation.=$next;
								}
							}
						}
					}
				}
				break;
			case CCP_IN_TAG_NAME:
				if ($next=='=')
				{
					$status=CCP_IN_TAG_BETWEEN_ATTRIBUTE_NAME_VALUE_RIGHT;
					$current_attribute_name='param';
				}
				elseif (trim($next)=='')
				{
					$status=CCP_IN_TAG_BETWEEN_ATTRIBUTES;
				}
				elseif ($next=='[')
				{
					warn_exit(do_lang_tempcode('CCP_TAG_OPEN_ANOMALY'));
				}
				elseif ($next==']')
				{
					if ($close)
					{
						if ($formatting_allowed)
						{
							list($close_list,$list_indent)=_convert_close_open_lists($list_indent);
							$xml.=$close_list;
						}

						if (count($tag_stack)==0) warn_exit(do_lang_tempcode('CCP_NO_CLOSE',escape_html($current_tag)));
						$_last=array_pop($tag_stack);
						if ($_last[0]!=$current_tag) warn_exit(do_lang_tempcode('CCP_NO_CLOSE_MATCH',escape_html($current_tag),escape_html($_last)));

						// Do the comcode for this tag
						if ($in_semihtml) // We need to perform some magic to clean up the Comcode sections
						{
							foreach ($_last[1] as $index=>$conv)
							{
								$_last[1][$index]=@html_entity_decode(str_replace('<br />',chr(10),$conv),ENT_QUOTES,get_charset());
							}
						}

						$attributes=$_last[1];

						if ($current_tag=='html')
						{
							$in_html=false;
							$_last[0]='htmlWrap';
						}
						elseif ($current_tag=='semihtml')
						{
							$in_semihtml=false;
							$_last[0]='htmlWrap';
						}
						elseif (($current_tag=='external_table') || ($current_tag=='internal_table'))
						{
							$_last[0]='box';
						}
						elseif ($current_tag=='php')
						{
							$_last[0]='code';
							$attributes['param']='php';
						}
						elseif ($current_tag=='codebox')
						{
							$_last[0]='code';
							$attributes['scroll']='1';
						}
						elseif ($current_tag=='sql')
						{
							$_last[0]='code';
							$attributes['param']='sql';
						}
						elseif ($current_tag=='snapback')
						{
							$_last[0]='post';
						}
						elseif ($current_tag=='thread')
						{
							$_last[0]='topic';
						}
						elseif ($current_tag=='list')
						{
							$sub_elements=explode('[*]',str_replace('[/*]','',$xml));
							$xml='';
							foreach ($sub_elements as $sub_element)
							{
								$xml.='<listElement>'.$sub_element.'</listElement>';
							}
						}

						if (($_last[0]=='page') && (array_keys($attributes)!=array('param')))
						{
							$zone=isset($attributes['param'])?$attributes['param']:'_SEARCH';
							$page=$xml;
							$xml=$attributes['caption'];
							unset($attributes['param']);
							unset($attributes['caption']);
							$pagelink=$zone.':'.$page;
							foreach ($attributes as $key=>$val)
							{
								$pagelink.=':'.$key.'='.$val;
							}
							$attributes=array('pageLink'=>$pagelink);
						}

						if ($_last[0]=='block')
						{
							foreach ($attributes as $key=>$val)
							{
								$xml.='<blockParam key="'.escape_html($key).'" value="'.escape_html($val).'" />';
							}
							$attributes=array();
						}

						if ($_last[0]=='random')
						{
							foreach ($attributes as $key=>$val)
							{
								$xml.='<randomTarget pickIfAbove="'.escape_html($key).'">'.comcode_text__to__comcode_xml($val,true).'</randomTarget>';
							}
							$attributes=array();
						}

						if ($_last[0]=='jumping')
						{
							foreach ($attributes as $key=>$val)
							{
								$xml.='<jumpingTarget>'.comcode_text__to__comcode_xml($val,true).'</jumpingTarget>';
							}
							$attributes=array();
						}

						if ($_last[0]=='concepts')
						{
							foreach ($attributes as $_key=>$_value)
							{
								if (substr($_key,-4)=='_key')
								{
									$key=$_value;
									$cid=substr($_key,0,strlen($_key)-4);
									$value=$attributes[$cid.'_value'];
									$xml.='<showConcept key="'.escape_html($key).'" value="'.escape_html($value).'" />';
								}
							}
							$attributes=array();
						}

						if ((($_last[0]=='attachment') || ($_last[0]=='attachment_safe')) && (isset($attributes['description'])))
						{
							$xml.='<attachmentDescription>'.comcode_text__to__comcode_xml($attributes['description'],true).'</attachmentDescription>';
							unset($attributes['description']);
						}

						if (($_last[0]=='hide') && (isset($attributes['param'])))
						{
							$xml.='<hideTitle>'.comcode_text__to__comcode_xml($attributes['param'],true).'</hideTitle>';
							unset($attributes['param']);
						}

						if (($_last[0]=='tooltip') && (isset($attributes['param'])))
						{
							$xml.='<tooltipMessage>'.comcode_text__to__comcode_xml($attributes['param'],true).'</tooltipMessage>';
							unset($attributes['param']);
						}

						global $COMCODE_XML_PARAM_RENAMING,$COMCODE_XML_SWITCH_AROUND;
						if ((isset($attributes['param'])) && (isset($COMCODE_XML_PARAM_RENAMING[$_last[0]])))
						{
							$attributes[$COMCODE_XML_PARAM_RENAMING[$_last[0]]]=$attributes['param'];
							unset($attributes['param']);
						}
						$comcode_xml_switch_around=$COMCODE_XML_SWITCH_AROUND;
						if (($_last[0]=='email') && ((!isset($attributes['param'])) || (!is_valid_email_address($attributes['param']))) && (is_valid_email_address($xml)))
						{
							$comcode_xml_switch_around[]='email';
						}
						if (($_last[0]=='url') && ((!isset($attributes['param'])) || (!looks_like_url($attributes['param']))) && (looks_like_url($xml)))
						{
							$comcode_xml_switch_around[]='url';
						}
						if (in_array($_last[0],$comcode_xml_switch_around))
						{
							$x='param';
							if ($_last[0]=='reference') $x='title';
							if (isset($attributes[$x]))
							{
								$temp=$attributes[$x];
								$attributes[$x]=$xml;
								$xml=comcode_text__to__comcode_xml($temp,true);
							} else
							{
								$attributes[$x]=$xml;
							}
						}

						$in_code_tag=false;
						$white_space_area=$_last[3];
						$in_separate_parse_section=$_last[4];
						$formatting_allowed=$_last[5];
						$textual_area=$_last[6];

						if ($_last[0]=='htmlWrap')
						{
							$embed_output='<htmlWrap xmlns="http://www.w3.org/1999/xhtml">';
						} else
						{
							$embed_output='<'.to_camelCase($_last[0]);
							foreach ($attributes as $key=>$val)
							{
								$embed_output.=' '.to_camelCase($key).'="'.escape_html($val).'"';
							}
							$embed_output.='>';
						}
						$embed_output.=$xml.'</'.to_camelCase($_last[0]).'>';
						$just_ended=isset($BLOCK_TAGS[$current_tag]);
						$xml=$_last[2].$embed_output;

						if ($current_tag=='title')
						{
							if ((strlen($comcode)>$pos+1) && ($comcode[$pos]==chr(10)) && ($comcode[$pos+1]==chr(10))) // Linux newline
							{
								$NUM_LINES+=2;
								$pos+=2;
								$just_new_line=true;
								list($close_list,$list_indent)=_convert_close_open_lists($list_indent);
								$xml.=$close_list;
							}
						}

						$status=CCP_NO_MANS_LAND;
					} else
					{
						array_push($tag_stack,array($current_tag,$attribute_map,$xml,$white_space_area,$in_separate_parse_section,$formatting_allowed,$textual_area));

						list(,,,$white_space_area,$formatting_allowed,$in_separate_parse_section,$textual_area,$attribute_map,$status,$in_html,$in_semihtml,$pos,$in_code_tag)=_opened_tag(false,false,get_member(),$attribute_map,$current_tag,$pos,$comcode_dangerous,$comcode_dangerous_html,$in_separate_parse_section,$in_html,$in_semihtml,$close,$len,$comcode);
						$xml='';
					}
				}
				else $current_tag.=strtolower($next);
				break;
			case CCP_STARTING_TAG:
				if ($next=='[') warn_exit(do_lang_tempcode('CCP_TAG_OPEN_ANOMALY'));
				elseif ($next==']') warn_exit(do_lang_tempcode('CCP_TAG_CLOSE_ANOMALY'));
				elseif ($next=='/')
				{
					$close=true;
				}
				else
				{
					$current_tag.=strtolower($next);
					$status=CCP_IN_TAG_NAME;
				}
				break;
			case CCP_IN_TAG_BETWEEN_ATTRIBUTES:
				if ($next==']')
				{
					array_push($tag_stack,array($current_tag,$attribute_map,$xml,$white_space_area,$in_separate_parse_section,$formatting_allowed,$textual_area));

					list(,,,$white_space_area,$formatting_allowed,$in_separate_parse_section,$textual_area,$attribute_map,$status,$in_html,$in_semihtml,$pos,$in_code_tag)=_opened_tag(false,false,get_member(),$attribute_map,$current_tag,$pos,$comcode_dangerous,$comcode_dangerous_html,$in_separate_parse_section,$in_html,$in_semihtml,$close,$len,$comcode);
					$xml='';
				}
				elseif ($next=='[')
				{
					warn_exit(do_lang_tempcode('CCP_TAG_OPEN_ANOMALY'));
				}
				elseif (trim($next)!='')
				{
					$status=CCP_IN_TAG_ATTRIBUTE_NAME;
					$current_attribute_name=$next;
				}
				break;
			case CCP_IN_TAG_ATTRIBUTE_NAME:
				if ($next=='[') warn_exit(do_lang_tempcode('CCP_TAG_OPEN_ANOMALY'));
				elseif ($next==']')
				{
					$at_map_keys=array_keys($attribute_map);
					$old_attribute_name=$at_map_keys[count($at_map_keys)-1];
					$attribute_map[$old_attribute_name].=' '.$current_attribute_name;

					array_push($tag_stack,array($current_tag,$attribute_map,$xml,$white_space_area,$in_separate_parse_section,$formatting_allowed,$textual_area));

					list(,,,$white_space_area,$formatting_allowed,$in_separate_parse_section,$textual_area,$attribute_map,$status,$in_html,$in_semihtml,$pos,$in_code_tag)=_opened_tag(false,false,get_member(),$attribute_map,$current_tag,$pos,$comcode_dangerous,$comcode_dangerous_html,$in_separate_parse_section,$in_html,$in_semihtml,$close,$len,$comcode);
					$xml='';
				}
				elseif ($next=='=') $status=CCP_IN_TAG_BETWEEN_ATTRIBUTE_NAME_VALUE_RIGHT;
				elseif ($next!=' ') $current_attribute_name.=strtolower($next);
				else $status=CCP_IN_TAG_BETWEEN_ATTRIBUTE_NAME_VALUE_LEFT;
				break;
			case CCP_IN_TAG_BETWEEN_ATTRIBUTE_NAME_VALUE_LEFT:
				if ($next=='=') $status=CCP_IN_TAG_BETWEEN_ATTRIBUTE_NAME_VALUE_RIGHT;
				elseif (trim($next)!='') warn_exit(do_lang_tempcode('CCP_ATTRIBUTE_ERROR',escape_html($current_attribute_name),escape_html($current_tag)));
				break;
			case CCP_IN_TAG_BETWEEN_ATTRIBUTE_NAME_VALUE_RIGHT:
				if ($next=='[') warn_exit(do_lang_tempcode('CCP_TAG_OPEN_ANOMALY'));
				elseif ($next==']') warn_exit(do_lang_tempcode('CCP_TAG_CLOSE_ANOMALY'));
				elseif ((($next=='"')/* && (!$in_semihtml)*/) || (($in_semihtml) && (substr($comcode,$pos-1,6)=='&quot;')))
				{
					if ($next!='"') $pos+=5;
					$status=CCP_IN_TAG_ATTRIBUTE_VALUE;
					$current_attribute_value='';
				}
				elseif ($next!='')
				{
					$status=CCP_IN_TAG_ATTRIBUTE_VALUE_NO_QUOTE;
					$current_attribute_value=$next;
				}
				break;
			case CCP_IN_TAG_ATTRIBUTE_VALUE_NO_QUOTE:
				if ($next==' ')
				{
					$status=CCP_IN_TAG_BETWEEN_ATTRIBUTES;
					if (isset($attribute_map[$current_attribute_name])) warn_exit(do_lang_tempcode('CCP_DUPLICATE_ATTRIBUTES',escape_html($current_attribute_name),escape_html($current_tag)));
					$attribute_map[$current_attribute_name]=$current_attribute_value;
				}
				elseif ($next==']')
				{
					if (isset($attribute_map[$current_attribute_name])) warn_exit(do_lang_tempcode('CCP_DUPLICATE_ATTRIBUTES',escape_html($current_attribute_name),escape_html($current_tag)));
					$attribute_map[$current_attribute_name]=$current_attribute_value;

					array_push($tag_stack,array($current_tag,$attribute_map,$xml,$white_space_area,$in_separate_parse_section,$formatting_allowed,$textual_area));

					list(,,,$white_space_area,$formatting_allowed,$in_separate_parse_section,$textual_area,$attribute_map,$status,$in_html,$in_semihtml,$pos,$in_code_tag)=_opened_tag(false,false,get_member(),$attribute_map,$current_tag,$pos,$comcode_dangerous,$comcode_dangerous_html,$in_separate_parse_section,$in_html,$in_semihtml,$close,$len,$comcode);
					$xml='';
				}
				else
				{
					$current_attribute_value.=$next;
				}
				break;
			case CCP_IN_TAG_ATTRIBUTE_VALUE:
				if ((($next=='"')/* && (!$in_semihtml)*/) || (($in_semihtml) && (substr($comcode,$pos-1,6)=='&quot;')))
				{
					if ($next!='"') $pos+=5;
					$status=CCP_IN_TAG_BETWEEN_ATTRIBUTES;
					if (isset($attribute_map[$current_attribute_name])) warn_exit(do_lang_tempcode('CCP_DUPLICATE_ATTRIBUTES',escape_html($current_attribute_name),escape_html($current_tag)));
					$attribute_map[$current_attribute_name]=$current_attribute_value;
				}
				else
				{
					if ($next=='\\')
					{
						if ($comcode[$pos]=='"')
						{
							$current_attribute_value.='"';
							++$pos;
						}
						elseif ($comcode[$pos]=='\\')
						{
							$current_attribute_value.='\\';
							++$pos;
						} else $current_attribute_value.=$next;
					} else $current_attribute_value.=$next;
				}
				break;
		}
	}
	$xml.=$continuation;
	$continuation='';

	list($close_list,$list_indent)=_convert_close_open_lists($list_indent);
	$xml.=$close_list;

	if (($status!=CCP_NO_MANS_LAND) || (count($tag_stack)!=0))
	{
		$stack_top=array_pop($tag_stack);
		warn_exit(do_lang_tempcode('CCP_BROKEN_END',escape_html($stack_top[0])));
	}

	if (!$skip_wrapper) $xml='<comcode>'.$xml.'</comcode>';

	return $xml;
}

/**
 * Get HTML to close any open lists.
 *
 * @param  integer		The depth level of lists that we need to close
 * @return array			The output needed to close the lists, and the new list indentation (always zero). Done like this so we can use 'list' to set both at once in the main parser.
 */
function _convert_close_open_lists($list_indent)
{
	$xml='';
	for ($i=0;$i<$list_indent;++$i) // Close any lists that exist
	{
		$xml.='</listElement></list>';
	}
	$list_indent=0;
	return array($xml,$list_indent);
}

/**
 * Convert template text into tempcode format.
 *
 * @param  string			The template text
 * @param  integer		The position we are looking at in the text
 * @param  boolean		Whether this text is infact a directive, about to be put in the context of a wider template
 * @param  ID_TEXT		The codename of the template (e.g. foo)
 * @param  ?ID_TEXT		The theme it is for (NULL: current theme)
 * @param  ?ID_TEXT		The language it is for (NULL: current language)
 * @return mixed			The converted/compiled template as tempcode, OR if a directive, encoded directive information
 */
function template_to_tempcode_static(/*&*/$text,$symbol_pos=0,$inside_directive=false,$codename='',$theme=NULL,$lang=NULL)
{
	if (is_null($theme)) $theme=$GLOBALS['FORUM_DRIVER']->get_theme();

	if (defined('HIPHOP_PHP'))
	{
		$out=new ocp_tempcode();
	} else
	{
		$out=new ocp_tempcode_static();
	}
	$continuation='';
	$chr_10=chr(10);
	$symbol_len=strlen($text);
	while (true)
	{
		$jump_to=strpos($text,'{',$symbol_pos);
		$jump_to_b=strpos($text,'\\',$symbol_pos);
		if (($jump_to_b!==false) && (($jump_to===false) || ($jump_to_b<$jump_to)))
		{
			$continuation.=substr($text,$symbol_pos,$jump_to_b-$symbol_pos);
			$symbol_pos=$jump_to_b+1;
			$nn=@$text[$symbol_pos];

			if (($nn=='{') || ($nn=='}') || ($nn==','))
			{
				continue; // Used to escape. We will pick up on in next iteration and also re-detect it is escaped.
			} else
			{
				$continuation.='\\'; // Just a normal slash, not for escaping.
				continue;
			}
		}

		if ($jump_to===false)
		{
			$continuation.=substr($text,$symbol_pos);
			break;
		} else // We're opening a variable if we meet a { followed by [\dA-Z\$\+\!\_]
		{
			$continuation.=substr($text,$symbol_pos,$jump_to-$symbol_pos);

			$symbol_pos=$jump_to+1;

			$nn_pre=($symbol_pos>=2)?$text[$symbol_pos-2]:'';
			$nn=@$text[$symbol_pos];
			if ((preg_match('#[\dA-Z\$\+\!\_]#',$nn)!=0) && ($nn_pre!=='\\'))
			{
				if ($continuation!='') $out->attach($continuation);
				$continuation='';
				$ret=read_single_uncompiled_variable($text,$symbol_pos,$symbol_len,$theme);
				if ($ret[1]==TC_DIRECTIVE)
				{
					if ($ret[2]=='START')
					{
						$temp=template_to_tempcode_static($text,$symbol_pos,true);
						if (is_array($temp))
						{
							list($_out,$symbol_pos)=$temp;
							if ($ret[3]===NULL) // Error, but don't die
							{
								$ret[3][]=$_out; // The inside of the directive becomes the final parameter
								$out->bits[]=array($ret[0],TC_DIRECTIVE,'',$ret[3]);
							} else
							{
								$name=array_shift($ret[3]);
								$ret[3][]=$_out; // The inside of the directive becomes the final parameter
								$directive_type=$name->evaluate();
								$out->bits[]=array($ret[0],TC_DIRECTIVE,$directive_type,$ret[3]);
		//						$out->children[]=array(':directive: '.$directive_type,$_out->children,true);
							}
						}
					} elseif ($ret[2]=='END')
					{
						if ($inside_directive) return array($out,$symbol_pos);
						if (!$GLOBALS['LAX_COMCODE'])
						{
							require_code('site');
							attach_message(make_string_tempcode(do_lang('UNMATCHED_DIRECTIVE').' just before... '.substr($text,$symbol_pos,100).' ['.$codename.']'),'warn');
						}
					} else
					{
						$out->bits[]=$ret;
					}
				} else
				{
					if (($ret[1]!=TC_SYMBOL) || ($ret[2]!=''))
						$out->bits[]=$ret;
				}
			} else
			{
				$continuation.='{';
			}
		}
	}
	if ($continuation!='') $out->attach($continuation);
	return $out;
}

/**
 * Convert and return an uncompiled textual variable (as used in templates, and comcode) into tempcode (these pieces are attached to other pieces, in a certain way, forming a tempcode tree for a template or a variable-in-comcode).
 *
 * @param  string				The full text that is being parsed (we only look into this - the whole thing will be passed into PHP by reference, hence avoiding us a memory block copy)
 * @param  integer			The position we are looking at in the text
 * @param  integer			The length of our variable
 * @param  ?ID_TEXT			The theme it is for (NULL: current theme)
 * @return array				The tempcode variable array that our variable gets represented of
 */
function read_single_uncompiled_variable($text,&$symbol_pos,$symbol_len,$theme=NULL)
{
	if (is_null($theme)) $theme=$GLOBALS['FORUM_DRIVER']->get_theme();

	$type=TC_PARAMETER;
	$escaped=array();
	$mode=SYMBOL_PARSE_NAME;
	$name='';
	$param=array();
	$params=0;
	$starting=true;
	$matches=array();
	$dirty_param=false;

	//$quicker=$GLOBALS['PREG_MATCH_OFFSET'];

	while (true)
	{
		/*if ($quicker)
		{
			preg_match('#[^\\\\\{\}\,\+\!\'\$:%\*;\#~\.\^|\&/@=`]*#m',$text,$matches,0,$symbol_pos); // Guarded by $quicker, as only works on newer PHP versions
			$next=$matches[0];
		} else */$next='';
		if ($next!='')
		{
			$symbol_pos+=strlen($next);
		} else
		{
			$next=$text[$symbol_pos];
			++$symbol_pos;
		}

		switch ($mode)
		{
			case SYMBOL_PARSE_PARAM:
				switch ($next)
				{
					case '}':
						if (($type==TC_SYMBOL) && ($name=='IMG') && (count($param)==1))
						{
							$param[]='0';
							$param[]=$theme;
						}
						$ret=array($escaped,$type,$name,$param);
						return $ret;

					case ',':
						$dirty_param=($type==TC_DIRECTIVE);
						if ($dirty_param)
						{
							$param[$params]=new ocp_tempcode();
						} else
						{
							$param[$params]='';
						}
						++$params;
						break;

					case '{':
						if (!$dirty_param)
						{
							$param_string=$param[$params-1];
							$t=new ocp_tempcode(); // For some very odd reason, PHP 4.3 doesn't allow you to do $param[$params-1]=new ocp_tempcode(); $param[$params-1]->attach($param_string); (causes memory corruption apparently)
							$t->attach($param_string);
							$param[$params-1]=$t;
							$dirty_param=true;
						}
						$ret=read_single_uncompiled_variable($text,$symbol_pos,$symbol_len,$theme);
						$param[$params-1]->bits[]=$ret;
						break;

					case '\\':
						if (($text[$symbol_pos]=='{') || ($text[$symbol_pos]=='}') || ($text[$symbol_pos]==','))
						{
							$next=$text[$symbol_pos];
							++$symbol_pos;
						}
					default:
						if (!$dirty_param)
						{
							$param[$params-1].=$next;
						} else
						{
							/*if ($quicker)
								$param[$params-1]->bits[]=array(array(),TC_KNOWN,$next,NULL);
							else*/
							$param[$params-1]->attach($next);
						}
				}
				break;

			case SYMBOL_PARSE_NAME:
				if ($starting)
				{
					$starting=false;
					switch($next)
					{
						case '+':
							$type=TC_DIRECTIVE;
							continue 2;

						case '!':
							$type=TC_LANGUAGE_REFERENCE;
							continue 2;

						case '$':
							$type=TC_SYMBOL;
							continue 2;
					}
				}
				switch ($next)
				{
					case '}':
						$ret=array($escaped,$type,$name,NULL);
						return $ret;

					case ',':
						$dirty_param=($type==TC_DIRECTIVE);
						$mode=SYMBOL_PARSE_PARAM;
						if ($dirty_param)
						{
							$param[$params]=new ocp_tempcode();
						} else
						{
							$param[$params]='';
						}
						++$params;
						break;

					case '%':
						$escaped[]=NAUGHTY_ESCAPED;
						break;

					case '*':
						$escaped[]=ENTITY_ESCAPED;
						break;

					case '=':
						$escaped[]=FORCIBLY_ENTITY_ESCAPED;
						break;

					case ';':
						$escaped[]=SQ_ESCAPED;
						break;

					case '#':
						$escaped[]=DQ_ESCAPED;
						break;

					case '~':
						$escaped[]=NL_ESCAPED;
						break;

					case '^':
						$escaped[]=NL2_ESCAPED;
						break;

					case '|':
						$escaped[]=ID_ESCAPED;
						break;

					case '\'':
						$escaped[]=CSS_ESCAPED;
						break;

					case '&':
						$escaped[]=UL_ESCAPED;
						break;

					case '.':
						$escaped[]=UL2_ESCAPED;
						break;

					case '/':
						$escaped[]=JSHTML_ESCAPED;
						break;

					case '`':
						$escaped[]=NULL_ESCAPED;
						break;

					case '@':
						if (in_array($text[$symbol_pos],array(':','&','/','^',';','~','#','}',',')))
						{
							$escaped[]=CC_ESCAPED;
							break;
						}

					default:
						$name.=$next;
				}
				break;
		}

		if ($symbol_pos>=$symbol_len)
		{
			if (!$GLOBALS['LAX_COMCODE'])
			{
				require_code('site');
				attach_message(do_lang_tempcode('UNCLOSED_SYMBOL'),'warn');
			}
			return array(array(),TC_KNOWN,'',NULL);
		}
	}
	return array(array(),TC_KNOWN,'',NULL);
}

/**
 * Static implementation of Tempcode.
 * @package		core_rich_media
 */
class ocp_tempcode_static
{
	// An array of bits where each bit is array($escape,$type,$value)
	//	NB: 'escape' doesn't apply for tempcode-typed-parameters or language-references
	var $bits;

	var $codename=':container'; // The name of the template it came from

	/**
	 * Constructor of tempcode
	 */
	function ocp_tempcode()
	{
		$this->bits=array();
	}

	/**
	 * Find whether a variable within this Tempcode is parameterless.
	 *
	 * @param  integer			Offset to the variable
	 * @return boolean			Whether it is parameterless
	 */
	function parameterless($at)
	{
		return ((!array_key_exists(3,$this->bits[$at])) || (count($this->bits[$at][3])==0));
	}

	/**
	 * Parse a single symbol from an input stream and append it.
	 *
	 * @param  string				Code string (input stream)
	 * @param  integer			Read position
	 * @param  integer			Length of input string
	 */
	function parse_from(&$code,&$pos,&$len)
	{
		$this->bits=array(read_single_uncompiled_variable($code,$pos,$len));
	}

	/**
	 * Set the embedment of a directive within this Tempcode.
	 *
	 * @param  integer			Offset to directive
	 * @param  tempcode			New embedment
	 */
	function set_directive_embedment($at,$set)
	{
		$this->bits[$at][3][count($this->bits[$at][3])-1]=$set;
	}

	/**
	 * Find the identifier component of a variable within this Tempcode.
	 *
	 * @param  integer			Offset to the variable
	 * @return string				Variable component
	 */
	function extract_identifier_at($at)
	{
		return $this->bits[$at][2];
	}

	/**
	 * Attach the specified tempcode to the right of the current tempcode object.
	 *
	 * @param  mixed				The tempcode/string to attach
	 * @param  ?array				Extra escaping (NULL: none)
	 * @param  boolean			If we've already merged the children from what we're attaching into the child tree (at bind stage)
	 */
	function attach($attach,$escape=NULL,$avoid_children_merge=false)
	{
		if ($attach==='') return;

		$last=count($this->bits)-1;

		if (is_object($attach)) // Consider it another piece of tempcode
		{
			//$done_one=false;
			if (is_null($escape)) $escape=array();
			$simple_escaped=array(ENTITY_ESCAPED);

			foreach ($attach->bits as $bit)
			{
				if (($bit[1]==TC_DIRECTIVE) && (($bit[2]=='IF_NON_ADJACENT') || ($bit[2]=='IF_ADJACENT')))
				{
					if (!isset($this->last_attach)) $this->last_attach='';
					if ((($bit[2]=='IF_NON_ADJACENT') && ($this->last_attach!=$bit[3][0]->evaluate()))
						|| (($bit[2]=='IF_ADJACENT') && ($this->last_attach==$bit[3][0]->evaluate())))
					{
						$this->attach($bit[3][1],$avoid_children_merge);
						$last=count($this->bits)-1;
					}
				} else
				{
					if ($escape!=array()) $bit[0]=array_merge($escape,$bit[0]);

					// Can we add into another string at our edge
					if (/*($done_one) || */($last==-1) || ($bit[1]!=TC_KNOWN) || ($this->bits[$last][1]!=TC_KNOWN) || (($this->bits[$last][0]!=$bit[0]) && (((array_merge($bit[0],$this->bits[$last][0]))!=$simple_escaped) || (preg_match('#[&<>"\']#',$bit[2])!=0)))) // No
					{
						$this->bits[]=$bit;
						$last++;
						//$done_one=true;
					} else // Yes
					{
						$this->bits[$last][2].=$bit[2];
					}
				}
			}

			$this->last_attach=$attach->codename;

		} else // Consider it a string
		{
			// Can we add into another string at our edge
			if (is_null($escape)) $escape=array();
			if (($last==-1) || ($this->bits[$last][1]!=TC_KNOWN) || (($this->bits[$last][0]!=$escape) && (((array_merge($escape,$this->bits[$last][0]))!=array(ENTITY_ESCAPED)) || (preg_match('#[&<>:��"\']#',$attach)!=0)))) // No
			{
				$this->bits[]=array($escape,TC_KNOWN,$attach,NULL);
			} else // Yes
			{
				$this->bits[$last][2].=$attach;
			}
		}
	}

	/**
	 * Find whether the current tempcode object is blank or not.
	 *
	 * @return boolean			Whether the tempcode object is empty
	 */
	function is_empty()
	{
		return count($this->bits)==0;
	}

	/**
	 * Parses the current tempcode object, then return the parsed string
	 *
	 * @param  ?LANGUAGE_NAME The language to evaluate with (NULL: current user's language)
	 * @param  mixed			 Whether to escape the tempcode object (children may be recursively escaped regardless if those children/parents are marked to be)
	 * @return string			The evaluated thing. Voila, it's all over!
	 */
	function evaluate($lang=NULL,$_escape=false)
	{
		$empty_array=array();
		$out='';

		foreach ($this->bits as $bit)
		{
			$bit_0=$bit[0];
			if ($_escape!==false) array_unshift($bit_0,$_escape);

			if ($bit[1]==TC_KNOWN) // Just pick up the string
			{
				apply_tempcode_escaping($bit_0,$bit[2]);
				$out.=$bit[2];
			} else
			{
				$bit_3=$bit[3];
				if (($bit_3) && ($bit[1]!=TC_DIRECTIVE))
				{
					foreach ($bit_3 as $i=>$decode_bit)
					{
						if (is_object($decode_bit))
						{
							$bit_3[$i]=$decode_bit->evaluate($lang,false);
						}
					}
				}

				$out.=ecv($lang,$bit_0,$bit[1],$bit[2],is_null($bit_3)?array():$bit_3);
			}
		}

		return $out;
	}
}

