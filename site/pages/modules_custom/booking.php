<?php /*

 ocPortal
 Copyright (c) ocProducts, 2004-2012

 See text/EN/licence.txt for full licencing information.


 NOTE TO PROGRAMMERS:
   Do not edit this file. If you need to make changes, save your changed file to the appropriate *_custom folder
   **** If you ignore this advice, then your website upgrades (e.g. for bug fixes) will likely kill your changes ****

*/

/**
 * @license		http://opensource.org/licenses/cpal_1.0 Common Public Attribution License
 * @copyright	ocProducts Ltd
 * @package		booking
 */

/**
 * Module page class.
 */
class Module_booking
{

	/**
	 * Standard modular info function.
	 *
	 * @return ?array	Map of module info (NULL: module is disabled).
	 */
	function info()
	{
		$info=array();
		$info['author']='Chris Graham';
		$info['organisation']='ocProducts';
		$info['hacked_by']=NULL;
		$info['hack_version']=NULL;
		$info['version']=1;
		$info['locked']=false;
		return $info;
	}

	/**
	 * Standard modular uninstall function.
	 */
	function uninstall()
	{
		$GLOBALS['SITE_DB']->drop_if_exists('bookable');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_blacked');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_blacked_for');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_codes');
		$GLOBALS['SITE_DB']->drop_if_exists('booking');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_supplement');
		$GLOBALS['SITE_DB']->drop_if_exists('bookable_supplement_for');
		$GLOBALS['SITE_DB']->drop_if_exists('booking_supplement');

		delete_config_option('bookings_show_warnings_for_months');
		delete_config_option('bookings_max_ahead_months');
	}

	/**
	 * Standard modular install function.
	 *
	 * @param  ?integer	What version we're upgrading from (NULL: new install)
	 * @param  ?integer	What hack version we're upgrading from (NULL: new-install/not-upgrading-from-a-hacked-version)
	 */
	function install($upgrade_from=NULL,$upgrade_from_hack=NULL)
	{
		$GLOBALS['SITE_DB']->create_table('bookable',array(
			'id'=>'*AUTO',
			//'num_available'=>'INTEGER',		Implied by number of bookable_codes attached to bookable_id
			'title'=>'SHORT_TRANS',
			'description'=>'LONG_TRANS',
			'price'=>'REAL',
			'categorisation'=>'SHORT_TRANS', // (will work as a heading, for the booking form)
			'cycle_type'=>'ID_TEXT', // (same as event recurrences in the calendar addon; can be none [which would remove date chooser]) - a room cycles daily for example
			'cycle_pattern'=>'SHORT_TEXT',
			'user_may_choose_code'=>'BINARY',
			'supports_notes'=>'BINARY',
			'dates_are_ranges'=>'BINARY', // (if not, will only ask for a single date)
			'calendar_type'=>'?AUTO_LINK', // (this is auto-added and synched on edits; type has no perms by default)
			'add_date'=>'TIME',
			'edit_date'=>'?TIME',
			'submitter'=>'USER',
			'sort_order'=>'INTEGER',

			'enabled'=>'BINARY',

			// (useful for defining seasonable bookables- e.g. summer bookable costing more, or with more rooms)
			'active_from_day'=>'SHORT_INTEGER',
			'active_from_month'=>'SHORT_INTEGER',
			'active_from_year'=>'INTEGER',
			'active_to_day'=>'?SHORT_INTEGER',
			'active_to_month'=>'?SHORT_INTEGER',
			'active_to_year'=>'?INTEGER',
		));

		$GLOBALS['SITE_DB']->create_table('bookable_blacked',array(
			'id'=>'*AUTO',
			'blacked_from_day'=>'SHORT_INTEGER',
			'blacked_from_month'=>'SHORT_INTEGER',
			'blacked_from_year'=>'INTEGER',
			'blacked_to_day'=>'SHORT_INTEGER',
			'blacked_to_month'=>'SHORT_INTEGER',
			'blacked_to_year'=>'INTEGER',
			'blacked_explanation'=>'LONG_TRANS',
		));

		$GLOBALS['SITE_DB']->create_table('bookable_blacked_for',array(
			'bookable_id'=>'*AUTO_LINK',
			'blacked_id'=>'*AUTO_LINK',
		));

		$GLOBALS['SITE_DB']->create_table('bookable_codes',array(
			'bookable_id'=>'*AUTO_LINK',
			'code'=>'*ID_TEXT', // (room numbers, seats, etc) ; can be auto-generated if requested
		));

		$GLOBALS['SITE_DB']->create_table('bookable_supplement',array(
			'id'=>'*AUTO',
			'price'=>'REAL',
			'price_is_per_period'=>'BINARY', // If this is the case, the supplement will actually be repeated out in separate records, each tied to a booking for that date
			'supports_quantities'=>'BINARY',
			'title'=>'SHORT_TRANS',
			'promo_code'=>'ID_TEXT', // If non-blank, the user must enter this promo-code to purchase this
			'supports_notes'=>'BINARY',
			'sort_order'=>'INTEGER',
		));

		$GLOBALS['SITE_DB']->create_table('bookable_supplement_for',array(
			'supplement_id'=>'*AUTO_LINK',
			'bookable_id'=>'*AUTO_LINK',
		));

		$GLOBALS['SITE_DB']->create_table('booking',array(
			'id'=>'*AUTO',
			'bookable_id'=>'AUTO_LINK',
			'member_id'=>'USER',
			'b_day'=>'SHORT_INTEGER',
			'b_month'=>'SHORT_INTEGER',
			'b_year'=>'INTEGER',
			'code_allocation'=>'ID_TEXT', // These code allocations will be given out arbitrarily, which means later on if things get busy, things could be suboptimal (e.g. people's 'stay' split across different codes on different dates, whilst reorganising could solve that). So a human would probably reorganise this manually in some cases, and it should not be considered a real-world guarantee, or a necessary thing to make sure people get a full run-length on a single code
			'notes'=>'LONG_TEXT',
			'booked_at'=>'TIME', // time booking was made
			'paid_at'=>'?TIME',
			'paid_trans_id'=>'?AUTO_LINK',
		));

		$GLOBALS['SITE_DB']->create_table('booking_supplement',array(
			'booking_id'=>'*AUTO_LINK',
			'supplement_id'=>'*AUTO_LINK',
			'quantity'=>'INTEGER',
			'notes'=>'LONG_TEXT',
		));

		add_config_option('BOOKINGS_SHOW_WARNINGS_FOR_MONTHS','bookings_show_warnings_for_months','integer','return \'6\';','FEATURES','BOOKINGS');
		add_config_option('BOOKINGS_MAX_AHEAD_MONTHS','bookings_max_ahead_months','integer','return \'36\';','FEATURES','BOOKINGS');
	}

	/**
	 * Standard modular entry-point finder function.
	 *
	 * @return ?array	A map of entry points (type-code=>language-code) (NULL: disabled).
	 */
	function get_entry_points()
	{
		require_lang('booking');
		return array('misc'=>'CREATE_BOOKING');
	}

	/**
	 * Standard modular run function.
	 *
	 * @return tempcode	The result of execution.
	 */
	function run()
	{
		require_lang('booking');
		require_code('booking');
		require_code('ocf_join');
		require_javascript('javascript_booking');

		$type=get_param('type','misc');

		if ((is_guest()) && (get_forum_type()!='ocf'))
		{
			access_denied('NOT_AS_GUEST');
		}
		elseif (is_guest()) check_joining_allowed();

		// Decide what to do
		if ($type=='misc') return $this->choose_bookables_and_dates(); // NB: This may be skipped, if blocks were used to access
		if ($type=='flesh_out') return $this->flesh_out(); // Finish full details for the booking
		if ($type=='account') return $this->join_or_login(); // NB: This may be skipped if user already logged in
		if ($type=='done') return $this->thanks();

		return new ocp_tempcode();
	}

	/**
	 * Allow the user to choose what to book, on a high level - what bookables, what dates.
	 *
	 * @return tempcode	The result of execution.
	 */
	function choose_bookables_and_dates()
	{
		global $M_SORT_KEY;

		$title=get_screen_title('CREATE_BOOKING');

		$query='SELECT * FROM '.get_table_prefix().'bookable WHERE enabled=1';
		$filter=get_param('filter','*');
		require_code('ocfiltering');
		$query.=' AND '.ocfilter_to_sqlfragment($filter,'id');
		$bookables=$GLOBALS['SITE_DB']->query($query.' ORDER BY sort_order');

		$has_date_ranges=false;
		$has_single_dates=false;
		$has_details=false;

		$min_min_date=time();
		$max_max_date=mixed();

		$date_from=time();
		$date_to=time();

		$categories=array();
		foreach ($bookables as $bookable)
		{
			$active_from=mktime(0,0,0,$bookable['active_from_month'],$bookable['active_from_day'],$bookable['active_from_year']);
			$active_to=mixed();
			$active_to=is_null($bookable['active_to_year'])?NULL:mktime(0,0,0,$bookable['active_to_month'],$bookable['active_to_day'],$bookable['active_to_year']);
			$min_date=$active_from;
			$max_date=$active_to;

			if ($min_date<$min_min_date) $min_min_date=$min_date;
			if ((is_null($max_max_date)) || (!is_null($active_to)))
			{
				if ($max_date>$max_max_date) $max_max_date=$max_date;
			}

			if ($bookable['dates_are_ranges']==1) $has_date_ranges=true;
			elseif ($bookable['dates_are_ranges']==0) $has_single_ranges=true;

			$messages=array();

			// Message if not currently active
			if ($active_from>time())
			{
				$messages[]=do_lang_tempcode('NOTE_BOOKING_IMPOSSIBLE_NOT_STARTED',get_timezoned_date($active_from,false,true,true));
			}

			// Message if becomes inactive within next 6 months
			if ((!is_null($active_to)) && ($active_to<SHOW_WARNINGS_UNTIL))
			{
				$messages[]=do_lang_tempcode('NOTE_BOOKING_IMPOSSIBLE_ENDED',get_timezoned_date($active_to,false,true,true));
			}

			// Message about any black-outs within next 6 months
			$blacked=$GLOBALS['SITE_DB']->query_select(
				'bookable_blacked b JOIN '.get_table_prefix().'bookable_blacked_for f ON f.blacked_id=b.id',
				array('blacked_from_day','blacked_from_month','blacked_from_year','blacked_to_day','blacked_to_month','blacked_to_year','blacked_explanation'),
				array(
					'bookable_id'=>$bookable['id'],
				),
				'ORDER BY id'
			);
			foreach ($blacked as $black)
			{
				$black_from=mktime(0,0,0,$black['blacked_from_month'],$black['blacked_from_day'],$black['blacked_from_year']);
				$black_to=mixed();
				$black_to=is_null($black['blacked_to_year'])?NULL:mktime(0,0,0,$black['blacked_to_month'],$black['blacked_to_day'],$black['blacked_to_year']);
				if (($black_from>time()) && ($black_to<SHOW_WARNINGS_UNTIL))
				{
					$messages[]=do_lang_tempcode(
						($black_from==$black_to)?'NOTE_BOOKING_IMPOSSIBLE_BLACKED_ONEOFF':'NOTE_BOOKING_IMPOSSIBLE_BLACKED_PERIOD',
						get_timezoned_date($black_from,false,true,true),
						get_timezoned_date($black_to,false,true,true),
						get_translated_tempcode($black['blacked_explanation'])
					);
				}
			}

			$category=get_translated_text($bookable['categorisation']);

			if (!array_key_exists($category,$categories))
				$categories[$category]=array('CATEGORY_TITLE'=>$category,'BOOKABLES'=>array());

			$quantity_available=$GLOBALS['SITE_DB']->query_value('bookable_codes','COUNT(*)',array('bookable_id'=>$bookable['id']));

			list($quantity,$date_from,$date_to)=$this->_read_chosen_bookable_settings($bookable);

			if (is_null($max_max_date)) $max_max_date=MAX_AHEAD_BOOKING_DATE;

			$description=get_translated_tempcode($bookable['description']);

			if ((!$description->is_empty()) || (count($messages)>0)) $has_details=true;

			$categories[$category]['BOOKABLES'][]=array(
				'BOOKABLE_ID'=>strval($bookable['id']),
				'BOOKABLE_QUANTITY_AVAILABLE'=>strval($quantity_available),
				'BOOKABLE_MESSAGES'=>$messages,
				'BOOKABLE_TITLE'=>get_translated_tempcode($bookable['title']),
				'BOOKABLE_DESCRIPTION'=>$description,
				'BOOKABLE_PRICE'=>float_format($bookable['price']),
				'BOOKABLE_PRICE_RAW'=>float_to_raw_string($bookable['price']),

				'BOOKABLE_SELECT_DATE_RANGE'=>$bookable['dates_are_ranges']==1,
				'BOOKABLE_MIN_DATE_DAY'=>date('d',$min_date),
				'BOOKABLE_MIN_DATE_MONTH'=>date('m',$min_date),
				'BOOKABLE_MIN_DATE_YEAR'=>date('Y',$min_date),
				'BOOKABLE_MAX_DATE_DAY'=>date('d',$max_date),
				'BOOKABLE_MAX_DATE_MONTH'=>date('m',$max_date),
				'BOOKABLE_MAX_DATE_YEAR'=>date('Y',$max_date),

				// For re-entrancy
				'BOOKABLE_QUANTITY'=>strval($quantity),
				'BOOKABLE_DATE_FROM_DAY'=>date('d',$date_from),
				'BOOKABLE_DATE_FROM_MONTH'=>date('m',$date_from),
				'BOOKABLE_DATE_FROM_YEAR'=>date('Y',$date_from),
				'BOOKABLE_DATE_TO_DAY'=>date('d',$date_to),
				'BOOKABLE_DATE_TO_MONTH'=>date('m',$date_to),
				'BOOKABLE_DATE_TO_YEAR'=>date('Y',$date_to),
			);

			/*$M_SORT_KEY='BOOKABLE_TITLE';	Wrong - we're sorting by sort_order
			usort($categories[$category]['BOOKABLES'],'multi_sort');*/
		}

		ksort($categories);

		// Messages shared by all bookables will be transferred so as to avoid repetition
		$shared_messages=array();
		$done_one=false;
		foreach ($categories as $category_title=>$bookables)
		{
			foreach ($bookables['BOOKABLES'] as $i=>$bookable)
			{
				foreach ($bookable['BOOKABLE_MESSAGES'] as $j=>$message)
				{
					if (!$done_one) // Ah, may be in all
					{
						$in_all=true;
						foreach ($categories as $_category_title=>$_bookables)
						{
							foreach ($bookables['BOOKABLES'] as $_i=>$_bookable)
							{
								if (!in_array($message,$_bookable['BOOKABLE_MESSAGES']))
								{
									$in_all=false;
									break 2;
								}
							}
						}
						if ($in_all)
						{
							$shared_messages[]=$message;
						}
						$done_one=true;
					}
					if (in_array($message,$shared_messages)) // Known to be in all
					{
						unset($categories[$category_title]['BOOKABLES'][$i]['BOOKABLE_MESSAGES'][$j]);
					}
				}
			}
		}

		return do_template('BOOKING_START_SCREEN',array(
			'TITLE'=>$title,
			'CATEGORIES'=>$categories,
			'POST_URL'=>build_url(array('page'=>'_SELF','type'=>'flesh_out','usergroup'=>get_param_integer('usergroup',NULL)),'_SELF'),
			'SHARED_MESSAGES'=>$shared_messages,
			'HAS_DATE_RANGES'=>$has_date_ranges,
			'HAS_SINGLE_DATES'=>$has_single_dates,
			'HAS_DETAILS'=>$has_details,
			'HAS_MIXED_DATE_TYPES'=>$has_single_dates && $has_date_ranges,
			'MIN_DATE_DAY'=>date('d',$min_min_date),
			'MIN_DATE_MONTH'=>date('m',$min_min_date),
			'MIN_DATE_YEAR'=>date('Y',$min_min_date),
			'MAX_DATE_DAY'=>date('d',$max_max_date),
			'MAX_DATE_MONTH'=>date('m',$max_max_date),
			'MAX_DATE_YEAR'=>date('Y',$max_max_date),
			'DATE_FROM_DAY'=>date('d',$date_from),
			'DATE_FROM_MONTH'=>date('m',$date_from),
			'DATE_FROM_YEAR'=>date('Y',$date_from),
			'DATE_TO_DAY'=>date('d',$date_to),
			'DATE_TO_MONTH'=>date('m',$date_to),
			'DATE_TO_YEAR'=>date('Y',$date_to),
			'HIDDEN'=>build_keep_post_fields(),
		));
	}

	/**
	 * Read settings the user has chosen, from the POST environment.
	 *
	 * @param  array		Details of the particular bookable.
	 * @return array		Tuple of details: number wanted, date from, date to).
	 */
	function _read_chosen_bookable_settings($bookable)
	{
		$quantity=post_param_integer('bookable_'.strval($bookable['id']).'_quantity',0);
		$date_from=get_input_date('bookable_'.strval($bookable['id']).'_date_from');
		if (is_null($date_from)) $date_from=get_input_date('bookable_date_from'); // allow to be specified for whole form (the norm actually)
		if (is_null($date_from)) $date_from=time();
		$date_to=get_input_date('bookable_'.strval($bookable['id']).'_date_to');
		if (is_null($date_to)) $date_to=get_input_date('bookable_date_to'); // allow to be specified for whole form (the norm actually); may still be null, if ranges not being used
		if (is_null($date_to)) $date_to=$date_from;

		return array($quantity,$date_from,$date_to);
	}

	/**
	 * Flesh out the details of a booking.
	 *
	 * @return tempcode	The result of execution.
	 */
	function flesh_out()
	{
		$title=get_screen_title('CREATE_BOOKING');

		// Check booking: redirect to last step as re-entrant if not valid
		$request=get_booking_request_from_form();
		$test=check_booking_dates_available($request,array());
		if (!is_null($test))
		{
			attach_message($test,'warn');
			return $this->choose_bookables_and_dates();
		}

		$bookables=array();

		$found=false;

		$bookable_rows=$GLOBALS['SITE_DB']->query_select('bookable',array('*'),NULL,'ORDER BY sort_order');
		foreach ($bookable_rows as $bookable_row)
		{
			if (post_param_integer('bookable_'.strval($bookable_row['id']).'_quantity',0)>0)
			{
				$found=true;

				$supplements=array();
				$supplement_rows=$GLOBALS['SITE_DB']->query_select('bookable_supplement a JOIN '.get_table_prefix().'bookable_supplement_for b ON a.id=b.supplement_id',array('a.*'),array('bookable_id'=>$bookable_row['id']),'ORDER BY sort_order');
				foreach ($supplement_rows as $supplement_row)
				{
					$supplements[]=array(
						'SUPPLEMENT_ID'=>strval($supplement_row['id']),
						'SUPPLEMENT_TITLE'=>get_translated_tempcode($supplement_row['title']),
						'SUPPLEMENT_SUPPORTS_QUANTITY'=>$supplement_row['supports_quantities']==1,
						'SUPPLEMENT_QUANTITY'=>strval(post_param_integer('bookable_'.strval($bookable_row['id']).'_supplement_'.strval($supplement_row['id']).'_quantity',0)),
						'SUPPLEMENT_SUPPORTS_NOTES'=>$supplement_row['supports_notes']==1,
						'SUPPLEMENT_NOTES'=>post_param('bookable_'.strval($bookable_row['id']).'_supplement_'.strval($supplement_row['id']).'_notes',''),
					);
				}

				$bookables[]=array(
					'BOOKABLE_ID'=>strval($bookable_row['id']),
					'BOOKABLE_TITLE'=>get_translated_tempcode($bookable_row['title']),
					'BOOKABLE_SUPPORTS_NOTES'=>$bookable_row['supports_notes']==1,
					'BOOKABLE_NOTES'=>post_param('bookable_'.strval($bookable_row['id']).'_notes',''),
					'BOOKABLE_SUPPLEMENTS'=>$supplements,

					'BOOKABLE_QUANTITY'=>strval(post_param_integer('bookable_'.strval($bookable_row['id']).'_quantity')), // Can select up to this many supplements
				);
			}
		}

		if (!$found) warn_exit(do_lang_tempcode('BOOK_QUANTITY_NOTHING_CHOSEN'));

		require_javascript('javascript_ajax');
		require_javascript('javascript_validation');

		return do_template('BOOKING_FLESH_OUT_SCREEN',array(
			'TITLE'=>$title,
			'BOOKABLES'=>$bookables,
			'PRICE'=>float_format(find_booking_price($request)),
			'POST_URL'=>build_url(array('page'=>'_SELF','type'=>'account','usergroup'=>get_param_integer('usergroup',NULL)),'_SELF'),
			'BACK_URL'=>build_url(array('page'=>'_SELF','type'=>'misc','usergroup'=>get_param_integer('usergroup',NULL)),'_SELF'),
			'HIDDEN'=>build_keep_post_fields(),
		));
	}

	/**
	 * Let the user login / do an inline join.
	 *
	 * @return tempcode	The result of execution.
	 */
	function join_or_login()
	{
		$title=get_screen_title('CREATE_BOOKING');

		// Check login: skip to thanks if logged in
		if (!is_guest())
		{
			return $this->thanks();
		}

		$url=build_url(array('page'=>'_SELF','type'=>'done'),'_SELF');

		list($javascript,$form)=ocf_join_form($url,true,false,false,false);

		$hidden=build_keep_post_fields();
		return do_template('BOOKING_JOIN_OR_LOGIN_SCREEN',array('_GUID'=>'b6e499588de8e2136122949478bac2e7','TITLE'=>$title,'JAVASCRIPT'=>$javascript,'FORM'=>$form,'HIDDEN'=>$hidden));
	}

	/**
	 * E-mails staff and receipt notice to user, and saves everything.
	 *
	 * @return tempcode	The result of execution.
	 */
	function thanks()
	{
		$title=get_screen_title('CREATE_BOOKING');

		// Finish join operation, if applicable
		if (is_guest())
		{
			list($messages)=ocf_join_actual(true,false,false,true,false,false,false,true);
			if (!$messages->is_empty())
				return inform_screen($title,$messages);
		}

		// Read request
		$request=get_booking_request_from_form();

		// Save
		$test=save_booking_form_to_db($request,array());
		if (is_null($test)) warn_exit(do_lang_tempcode('BOOKING_ERROR'));

		// Send emails
		send_booking_emails($request);

		// Show success
		return inform_screen($title,do_lang_tempcode('BOOKING_SUCCESS',escape_html($GLOBALS['FORUM_DRIVER']->get_username(get_member()))));
	}

}

/*

NOTE (for future expansion, not critical base functionality)...

Implement online payment support; will need nice way to remove unpaid bookings in future too

Promo codes

Implement permissions for bookables

Manual choice of codes (seats or whatever)

Implement support for the defined cycle patterns (currently just daily or none)

What if we want to run on a reduced capacity for a period?

Implement blocks

*/
